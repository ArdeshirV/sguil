#!/usr/bin/tcl

# Copyright (C) 2002 Robert (Bamm) Visscher <bamm@satx.rr.com>
#
# This program is distributed under the terms of version 1.0 of the 
# Q Public License.  See LICENSE.QPL for further details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

########################## GLOBALS ##################################

set VERSION "SGUIL-0.2.1"

# Config options moved to sguild.conf

######################## END GLOBALS ################################

########################## PROCS ####################################

proc DisplayUsage { cmdName } {
  puts "Usage: $cmdName \[-D\] \[-h\] \[-o\] \[-c <filename>\] \[-u <filename>\] \[-P <filename>\]"
  puts "       \[-O <filename>\] \[-C <directory\]"
  puts "  -c <filename>: PATH to the sguild config (sguild.conf) file."
  puts "  -u <filename>: PATH to the sguild users (sguild.users) file."
  puts "  -P <filename>: Name of file to write the PID to."
  puts "                 Default is /var/run/sguild.pid"
  puts "  -o Enable OpenSSL"
  puts "  -O <filename>: Enable OpenSSL using PATH to tls (tcl openssl) lib (libtls1.4.so)"
  puts "  -C <directory>: Directory that contains sguild.pem and sguild.key"
  puts "  -D Runs sguild in daemon mode."
  puts "  -h Display this help"
  CleanExit
}
proc CleanExit {} {
  global PID_FILE
  if { [info exists PID_FILE] && [file exists $PID_FILE] } {
    if [catch {file delete -force $PID_FILE} delError] {
      puts "ERROR: $delError"
    }
  }
  puts "Exiting..."
  exit
}
#
# CheckLineFormat - Parses CONF_FILE lines to make sure they are formatted
#                   correctly (set varName value). Returns 1 if good.
#
proc CheckLineFormat { line } {
  
  set RETURN 1
  # Right now we just check the length and for "set".
  if { [llength $line] != 3 || [lindex $line 0] != "set" } { set RETURN 0 }
  return $RETURN
}   

proc ValidateUser { socketID username passwd } {
  global USERS_FILE validSockets socketInfo userIDArray
  if { ![file exists $USERS_FILE] } {
    puts "Fatal Error! Cannot access $USERS_FILE."
    exit 1
  } 
  set VALID 0
  for_file line $USERS_FILE {
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      # Probably should check for corrupted info here
      set splitInfo [split $line :]
      if { [lindex $splitInfo 0] == $username && [lindex $splitInfo 1] == $passwd } {
        set VALID 1
      }
    }
  }
  if {$VALID} {
    set userIDArray($socketID) [GetUserID $username]
    DBCommand\
     "UPDATE user_info SET last_login='[GetCurrentTimeStamp]' WHERE uid=$userIDArray($socketID)"
    lappend validSockets $socketID
    catch { SendSocket $socketID "UserID $userIDArray($socketID)" } tmpError
    SendSystemInfoMsg sguild "User $username logged in from [lindex $socketInfo($socketID) 0]"
    lappend socketInfo($socketID) $username
  } else {
    set validSockets [ldelete $validSockets $socketID]
    catch {SendSocket $socketID "UserID INVALID"} tmpError
    SendSystemInfoMsg sguild "User $username denied access from [lindex $socketInfo($socketID) 0]"
  } 
}
proc GetUserID { username } {
  set uid [FlatDBQuery "SELECT uid FROM user_info WHERE username='$username'"]
  if { $uid == "" } {
    DBCommand\
     "INSERT INTO user_info (username, last_login) VALUES ('$username', '[GetCurrentTimeStamp]')"
    set uid [FlatDBQuery "SELECT uid FROM user_info WHERE username='$username'"]
  }
  return $uid
}
#
# ClientCmdRcvd: Called when client sends commands.
#
proc ClientCmdRcvd { socketID } {
  global DEBUG clientList validSockets

  if { [eof $socketID] || [catch {gets $socketID data}] } {
    # Socket closed
    close $socketID
    ClientExitClose $socketID
    if {$DEBUG} { puts "Socket $socketID closed" }
  } else {
    if {$DEBUG} {puts "Clent Command Recieved: $data"}
    set origData $data
    set clientCmd [ctoken data " "]
    # Check to make the client validated itself
    if { $clientCmd != "ValidateUser" && $clientCmd != "GetIcmpData" &&\
         $clientCmd != "GetIPData" && $clientCmd != "GetPayloadData" &&\
         $clientCmd != "GetPSData" && $clientCmd != "GetTcpData" &&\
         $clientCmd != "GetUdpData" && $clientCmd != "PING" } {
      if { [lsearch -exact $validSockets $socketID] < 0 } {
        catch {SendSocket $socketID\
         "InfoMessage {Client does not appear to be logged in. Please exit and log back in.}"} tmpError
      return
      }
    }
    set data1 $data
    # data1 will contain the list from index 1 on. 
    set index1 [ctoken data " "]
    set data2 $data
    # data2 now contains only indices 2 on, because ctoken chops tokens off
    set index2 [ctoken data " "]
    # data now contains indicies 3 on
    switch -exact $clientCmd {
      DeleteEventID { $clientCmd $socketID $index1 $index2 }
      DeleteEventIDList { $clientCmd $socketID $index1 $index2 $data }
      EventHistoryRequest { $clientCmd $socketID $index1 $index2 $data }
      ExecDB { $clientCmd $socketID $index1 }
      GetIcmpData { $clientCmd $socketID $index1 $index2 }
      GetIPData { $clientCmd $socketID $index1 $index2 }
      GetPayloadData { $clientCmd $socketID $index1 $index2 }
      GetPSData { $clientCmd $socketID $index1 $index2 }
      GetTcpData { $clientCmd $socketID $index1 $index2 }
      GetUdpData { $clientCmd $socketID $index1 $index2 }
      MonitorSensors { $clientCmd $socketID $data1 } 
      QueryDB { $clientCmd $socketID $index1 $index2 }
      RuleRequest { $clientCmd $socketID $index1 $data2 }
      SendSensorList { $clientCmd $socketID }
      SendEscalatedEvents { $clientCmd $socketID }
      SendDBInfo { $clientCmd $socketID }
      ValidateUser { ValidateUser $socketID $index1 $index2 }
      PING { puts $socketID "PONG" }
      default { if {$DEBUG} {puts "Unrecognized command from $socketID: $origData"} }
    }
  }
}

proc ClientExitClose { socketID } {
  global clientList  clientMonitorSockets validSockets socketInfo
  if { [info exists clientList] } {
    set clientList [ldelete $clientList $socketID]
  }
  if { [info exists clientMonitorSockets] } {
    foreach sensorName [array names clientMonitorSockets] {
      set clientMonitorSockets($sensorName) [ldelete $clientMonitorSockets($sensorName) $socketID]
    }
  }
  if { [info exists validSockets] } {
    set validSockets [ldelete $validSockets $socketID]
  }
  if { [info exists socketInfo($socketID)] } {
    SendSystemInfoMsg sguild "User [lindex $socketInfo($socketID) 2] has disconnected."
    unset socketInfo($socketID)
  }
}

#
# EventRcvd: Called by main when events are received. File id sent as arg.
#
proc EventRcvd { data } {
  global DEBUG
  puts "IN EventRcvd"
  set eventDataList [lrange [split $data |] 1 end]
  if { [lindex $eventDataList 2] == "system-info" } {
    if {$DEBUG} {
      puts "SYSTEM INFO: $eventDataList"
    }
    set sensorName [lindex $eventDataList 3]
    set message [lindex $eventDataList 5]
    SendSystemInfoMsg $sensorName $message
  } else {
    if {$DEBUG} {
      puts "Alert Received: $eventDataList"
    }
    AddEventToEventArray $eventDataList
    SendEvent $eventDataList
  }
}

proc GetCurrentTimeStamp {} {
  set timestamp [clock format [clock seconds] -gmt true -f "%Y-%m-%d %T"]
  return $timestamp 
} 


#
# ldelete: Delete item from a list
#
proc ldelete { list value } {
  set ix [lsearch -exact $list $value]
  if {$ix >= 0} {
    return [lreplace $list $ix $ix]
  } else {
    return $list
  }
}


#
# SendSocket: Send command to client
#
proc SendSocket { socketID command } {
  global clientList DEBUG
  if {$DEBUG} {puts "Sending $socketID: $command"}
  if { [catch {puts $socketID $command} sendError] } {
    if {$DEBUG} { puts "Error sending \"$command\" to $socketID" }
    catch { close $socketID } closeError
    # Remove socket from the client list
    ClientExitClose $socketID
    return -code error -errorinfo $sendError
  }
  catch {flush $socketID} flushError
}

#
# SendEvent: Send events to connected clients
#
proc SendEvent { eventDataList } {
  global DEBUG clientList
  if { [info exists clientList] && [llength $clientList] > 0 } {
    foreach clientSocket $clientList {
      catch {SendSocket $clientSocket "InsertEvent $eventDataList"} tmpError
    }
  } else {
    if {$DEBUG} { puts "No clients to send alert to." }
  }
}
proc SendSystemInfoMsg { sensor msg } {
  global clientList DEBUG
  if { [info exists clientList] && [llength $clientList] > 0 } {
    foreach clientSocket $clientList {
      catch {SendSocket $clientSocket "InsertSystemInfoMsg $sensor $msg"} tmpError
    }
  } else {
    if {$DEBUG} { puts "No clients to send info msg to." }
  }
}
#
# AddEventToEventArray: Global eventIDArray contains current events.
#
proc AddEventToEventArray { eventDataList } {
  global eventIDArray eventIDList sensorIDList
  set eventID [join [lrange $eventDataList 5 6] .]
  set sensorName [lindex $eventDataList 3]
  set eventIDArray($eventID) $eventDataList
  # Arrays are not kept in any particular order so we have to keep
  # a list in order to control the order the clients recieve events
  lappend eventIDList $eventID
}

proc DeleteEventIDList { socketID status comment deleteEventIDList } {
  global eventIDArray eventIDList clientList escalateArray escalateIDList
  global userIDArray
  puts "status: $status"
  puts "comment: $comment"
  puts "deleteEventIDList: $deleteEventIDList"
  set count 0
  set updateTmp ""
  foreach socket $clientList {
    # Sending a DeleteEventID to the originating client allows us
    # to remove events from the RT panes when deleting from a query.
    # Problem is, we could delete a correlated event parent without
    # deleting the children thus leaving alerts that haven't been 
    # dealt with. 
    catch {SendSocket $socket "DeleteEventIDList $deleteEventIDList"} tmpError
  }
  foreach eventID $deleteEventIDList {
    if { [info exists escalateIDList] } {set escalateIDList [ldelete $escalateIDList $eventID]}
    # If status == 2 then escalate
    if {$status == 2} {
      lappend escalateIDList $eventID
      if [info exists eventIDArray($eventID)] {
        set escalateArray($eventID) $eventIDArray($eventID)
      } else {
        set escalateArray($eventID) [FlatDBQuery\
         "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.sid=[lindex [split $eventID .] 0] AND event.cid=[lindex [split $eventID .] 1]"]
      }
      foreach socket $clientList {
        catch {SendSocket $socket "InsertEscalatedEvent $escalateArray($eventID)"} tmpError
      }
    }
    if { [info exists eventIDArray($eventID)] } { unset eventIDArray($eventID) }
    if [info exists eventIDList] {
      set eventIDList [ldelete $eventIDList $eventID]
    }
    set splitID [split $eventID .]
    set sid [lindex $splitID 0]
    set cid [lindex $splitID 1]
    if { $count < 1000 } {
      set updateTmp "$updateTmp (sid=$sid AND cid=$cid)"
    } else {
      regsub -all {\) \(} $updateTmp {) OR (} whereTmp
      UpdateDBStatusList $whereTmp [GetCurrentTimeStamp] $status
      set count 0
      set updateTmp "(sid=$sid AND cid=$cid)"
    }
    # Update the history here
    InsertHistory $sid $cid $userIDArray($socketID) [GetCurrentTimeStamp] $status $comment
    incr count
  }
  regsub -all {\) \(} $updateTmp {) OR (} whereTmp
  UpdateDBStatusList $whereTmp [GetCurrentTimeStamp] $status
}

proc InsertHistory { sid cid uid timestamp status comment} {
  if {$comment == "none"} {
    DBCommand "INSERT INTO history (sid, cid, uid, timestamp, status) VALUES ( $sid, $cid, $uid, '$timestamp', $status)"
  } else {
    DBCommand "INSERT INTO history (sid, cid, uid, timestamp, status, comment) VALUES ( $sid, $cid, $uid, '$timestamp', $status, '$comment')"
  }
}

proc DeleteEventID { socketID eventID status } {
  global eventIDArray eventIDList clientList escalateArray escalateIDList
  global userIDArray
  
  foreach socket $clientList {
    # See comments in DeleteEventIDList
    catch {SendSocket $socket "DeleteEventID $eventID"} tmpError
  }
  # If status == 2 then escalate
  if { $status == 2 } {
    lappend escalateIDList $eventID
    set escalateArray($eventID) $eventIDArray($eventID)
    foreach socket $clientList {
      catch {SendSocket $socket "InsertEscalatedEvent $escalateArray($eventID)"} tmpError
    }
  }
  if { [info exists escalateArray($eventID)] } { unset escalateArray($eventID) }
  if { [info exists escalateIDList] } {set escalateIDList [ldelete $escalateIDList $eventID]}
  if { [info exists eventIDArray($eventID)] } { unset eventIDArray($eventID) }
  set eventIDList [ldelete $eventIDList $eventID]
  InsertHistory [lindex [split $eventID .] 0] [lindex [split $eventID .] 1]\
   $userIDArray($socketID) [GetCurrentTimeStamp] $status
  UpdateDBStatus $eventID [GetCurrentTimeStamp] $status
}

proc SendDBInfo { socketID } {
  global tableNameList tableArray 
  catch {SendSocket $socketID "TableNameList $tableNameList"} tmpError
  foreach tableName $tableNameList {
    catch {SendSocket $socketID "TableColumns $tableName $tableArray($tableName)"} tmpError
  }
}
#
# ClientConnect: Sets up comms for client/server
#
proc ClientConnect { socketID IPAddr port } {
  global DEBUG socketInfo VERSION
  global OPENSSL KEY PEM
  if {$DEBUG} {
    puts "Client Connect: $IPAddr $port $socketID"
  }
  set socketInfo($socketID) "$IPAddr $port"
  fconfigure $socketID -buffering line
  # Do version checks
  if [catch {SendSocket $socketID "$VERSION"} sendError ] {
    return
  }
  if [catch {gets $socketID} clientVersion] {
    if {$DEBUG} {puts "$ERROR: $clientVersion"}
    return
  }
  if { $clientVersion != $VERSION } {
    catch {close $socketID} tmpError
    if {$DEBUG} {puts "ERROR: Client connect denied - mismatched versions" }
    if {$DEBUG} {puts "CLIENT VERSION: $clientVersion" }
    if {$DEBUG} {puts "SERVER VERSION: $VERSION" }
    ClientExitClose $socketID
    return
  }
  if {$OPENSSL} {
    tls::import $socketID -server true -keyfile $KEY -certfile $PEM
    fileevent $socketID readable [list HandShake $socketID ClientCmdRcvd]
  } else {
    fileevent $socketID readable [list ClientCmdRcvd $socketID]
  } 
} 
proc HandShake { socketID cmd } {
  if {[eof $socketID]} {
    close $socketID
    ClientExitClose socketID
  } elseif { [catch {tls::handshake $socketID} results] } {
    puts "ERROR: $results"
    close $socketID
    ClientExitClose socketID
  } elseif {$results == 1} {
    puts "Handshake complete for $socketID"
    fileevent $socketID readable [list $cmd $socketID]
  }
}


proc SensorConnect { socketID IPAddr port } {
  global DEBUG
  if {$DEBUG} {puts "Connect from $IPAddr:$port $socketID"}
  fconfigure $socketID -buffering line
  fileevent $socketID readable [list SensorCmdRcvd $socketID]
}
proc GetSensorID { sensorName } {
  # For now we query the DB everytime we need the sid.
  set sid [FlatDBQuery "SELECT sid FROM sensor WHERE hostname='$sensorName'"]
  return $sid
}
proc RcvSsnFile { socketID fileName sensorName } {
  global DEBUG TMPDATADIR DBHOST DBPORT DBNAME DBUSER DBPASS
  set sensorID [GetSensorID $sensorName]
  if {$DEBUG} {puts "Recieving session file $fileName."}
  fconfigure $socketID -translation binary
  set DB_OUTFILE $TMPDATADIR/$fileName
  set fileID [open $DB_OUTFILE w]
  fcopy $socketID $fileID
  close $fileID
  close $socketID
  if {$sensorID == 0} {
    if {$DEBUG} {
      puts "ERROR: $sensorName is not in DB!!"
    }
    SendSystemInfoMsg sguild "ERROR: Received session file from unkown sensor - $sensorName"
    return
  }
  set inFileID [open $DB_OUTFILE r]
  set outFileID [open $DB_OUTFILE.tmp w]
  # Use i to keep track of how many lines we loaded into the database for DEBUG.
  set i 0
  # Load the entire file into memory (read $inFileID), then create a list
  # delimited by \n. Finally loop through each 'line', prepend the sensorID (sid)
  # to it, and append the new line to the tmp file.
  foreach line [split [read $inFileID] \n] {
    if {$line != ""} {puts $outFileID "$sensorID|$line"; incr i}
  }
  close $inFileID
  close $outFileID
  file delete $DB_OUTFILE

  if {$DEBUG} {puts "Loading $i cnxs from $fileName into DB."}
  if {$DBPASS != "" } {
    set cmd "mysql -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER --password=$DBPASS\
     -e \"LOAD DATA LOCAL INFILE '$DB_OUTFILE.tmp' INTO TABLE sessions FIELDS TERMINATED\
     BY '|'\""
    if {$DEBUG} {puts $cmd}
  } else {
    set cmd "mysql -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER\
     -e \"LOAD DATA LOCAL INFILE '$PS_OUTFILE'.tmp INTO TABLE sessions FIELDS TERMINATED\
     BY '|'\""
    if {$DEBUG} {puts $cmd}
  }
  if [catch {eval exec $cmd} loadError] {
    puts "Unable to load session data into DB."
    puts $loadError
  } else {
    file delete $DB_OUTFILE.tmp
  }
}
proc RcvPortscanFile { socketID fileName } {
  global DEBUG TMPDATADIR DBHOST DBPORT DBNAME DBUSER DBPASS
  if {$DEBUG} {puts "Recieving portscan file $fileName."}
  fconfigure $socketID -translation binary
  set PS_OUTFILE $TMPDATADIR/$fileName
  set fileID [open $PS_OUTFILE w]
  fcopy $socketID $fileID
  close $fileID
  close $socketID
  if {$DEBUG} {puts "Loading $fileName into DB."}
  if {$DBPASS != "" } {
    set cmd "mysql -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER --password=$DBPASS\
     -e \"LOAD DATA LOCAL INFILE '$PS_OUTFILE' INTO TABLE portscan FIELDS TERMINATED\
     BY '|'\""
    if {$DEBUG} {puts $cmd}
  } else {
    set cmd "mysql -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER\
     -e \"LOAD DATA LOCAL INFILE '$PS_OUTFILE' INTO TABLE portscan FIELDS TERMINATED\
     BY '|'\""
    if {$DEBUG} {puts $cmd}
  }
  if [catch {eval exec $cmd} loadError] {
    puts "Unable to load PS data into DB."
    puts $loadError
  } else {
    file delete $PS_OUTFILE
  }
}

proc DiskReport { socketID fileSystem percentage } {
  global agentSensorName
  SendSystemInfoMsg $agentSensorName($socketID) "$fileSystem $percentage"
}
proc SensorAgentConnect { socketID sensorName } {
  global connectedAgents agentSocket agentSensorName
  lappend connectedAgents $sensorName
  set agentSocket($sensorName) $socketID
  set agentSensorName($socketID) $sensorName
  SendSystemInfoMsg $sensorName "Agent connected."
}
proc CleanUpDisconnectedAgent { socketID } {
  global connectedAgents agentSocket agentSensorName

  set connectedAgents [ldelete $connectedAgents $agentSensorName($socketID)]
  set sensorName $agentSensorName($socketID)
  unset agentSocket($sensorName)
  unset agentSensorName($socketID)
}
proc SensorCmdRcvd { socketID } {
  global DEBUG connectedAgents agentSensorName
  if { [eof $socketID] || [catch {gets $socketID data}] } {
    # Socket closed
    close $socketID
    if {$DEBUG} { puts "Socket $socketID closed" }
    if { [info exists connectedAgents] && [info exists agentSensorName($socketID)] } {
      CleanUpDisconnectedAgent $socketID
    }
  } else {
    if {$DEBUG} { puts "Sensor Data Rcvd: $data" }
    # note that ctoken changes the string that it is operating on 
    # so instead of re-writing all of the proc to move up one in 
    # the index when looking at $data, I wrote $data to $tmpData
    # before using ctoken.  Probably should drop this and fix the
    # procs, but that can happen later
    set tmpData $data
    set sensorCmd [ctoken tmpData " "]
    # set sensorCmd [lindex $data 0]
    switch -exact -- $sensorCmd {
      RTEvent	{ EventRcvd $data }
      PSFile	{ RcvPortscanFile $socketID [lindex $data 1] }
      CONNECT   { SensorAgentConnect $socketID [lindex $data 1] }
      DiskReport { $sensorCmd $socketID [lindex $data 1] [lindex $data 2] }
      SsnFile	{ RcvSsnFile $socketID [lindex $data 1] [lindex $data 2] }
      PING	{ puts $socketID "PONG" }
      default	{ puts "Sensor Cmd Unkown: $sensorCmd" }
    }
  }
}

#
# RuleRequest finds rule based on message. Should change this to
# use sig ids in the future.
#
proc RuleRequest { socketID sensor message } {
  global RULESDIR DEBUG

  set RULEFOUND 0
  set ruleDir $RULESDIR/$sensor
  if { [file exists $ruleDir] } {
    foreach ruleFile [glob -nocomplain $ruleDir/*.rules] {
      if {$DEBUG} {puts "Checking $ruleFile..."}
      set ruleFileID [open $ruleFile r]
      while { [gets $ruleFileID data] >= 0 } {
        if { [string match "*$message*" $data] } {
          set RULEFOUND 1
          if {$DEBUG} {puts "Matching rule found in $ruleFile."}
          break
        }
      }
      close $ruleFileID
      if {$RULEFOUND} {break}
    }
  } else {
    set data "Could not find $ruleDir."
  }
  if {$RULEFOUND} { 
    catch {SendSocket $socketID "InsertRuleData \{$data\}"} tmpError
  } else {
    catch {SendSocket $socketID "InsertRuleData \{Unable to find matching rule in $ruleDir.\}"} tmpError
  }
}
proc GetPSData { socketID timestamp srcIP } {
  global MAX_PS_ROWS DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG
  set query\
   "SELECT * FROM portscan WHERE timestamp > '$timestamp' AND src_ip='$srcIP' LIMIT $MAX_PS_ROWS"
  if {$DEBUG} {puts "Getting PS data: $query"}
  if {$DBPASS == ""} {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  foreach row [mysqlsel $dbSocketID "$query" -list] {
    catch {SendSocket $socketID "PSDataResults $row"} tmpError
  }
  mysqlclose $dbSocketID
  catch {SendSocket $socketID "PSDataResults DONE"} tmpError
}
proc ExecDB { socketID query } {
  global DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG
    if { [lindex $query 0] == "OPTIMIZE" } {
	SendSystemInfoMsg sguild "Table Optimization begging, please stand by"
    }
  if {$DEBUG} {puts "Sending DB Query: $query"}
  if { $DBPASS == "" } {
      set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
      set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  if [catch {mysqlexec $dbSocketID $query} execResults] {
	catch {SendSocket $socketID "InfoMessage \{ERROR running query, perhaps you don't have permission. Error:$execResults\}"} tmpError
  } else {
      if { [lindex $query 0] == "DELETE" } {
	  catch {SendSocket $socketID "InfoMessage \{Query deleted $execResults rows.\}"} tmpError
      } elseif { [lindex $query 0] == "OPTIMIZE" } {
	  catch {SendSocket $socketID "InfoMessage \{Database Command Completed.\}"} tmpError
	  SendSystemInfoMsg sguild "Table Optimization Completed."
      } else { 
	  catch {SendSocket $socketID "InfoMessge \{Database Command Completed.\}"} tmpError
      }
  }
  mysqlclose $dbSocketID
}
 
proc QueryDB { socketID clientWinName query } {
  global DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG 

  if {$DEBUG} {puts "Sending DB Query: $query"}
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  if [catch {mysqlsel $dbSocketID "$query" -list} selResults] {
    catch {SendSocket $socketID "InfoMessage \{$selResults\}"} tmpError
  } else {
    set count 0
    foreach row $selResults {
      catch {SendSocket $socketID "InsertQueryResults $clientWinName $row"} tmpError
      incr count
    }
    catch {SendSocket $socketID "InfoMessage \{Query returned $count row(s).\}"} tmpError
  }
  catch {SendSocket $socketID "InsertQueryResults $clientWinName done"} tmpError
  mysqlclose $dbSocketID
}
proc FlatDBQuery { query } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS

  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  set queryResults [mysqlsel $dbSocketID $query -flatlist]
  mysqlclose $dbSocketID
  return $queryResults
}
proc EventHistoryRequest { socketID winName sid cid } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  set query "SELECT history.sid, history.cid, user_info.username, history.timestamp, history.status, status.description, history.comment FROM history, user_info, status WHERE history.uid=user_info.uid AND history.status=status.status_id AND history.sid=$sid and history.cid=$cid"
  if [catch {mysqlsel $dbSocketID "$query" -list} selResults] {
    catch {SendSocket $socketID "InfoMessage \{$selResults\}"} tmpError
  } else {
    foreach row $selResults {
      catch {SendSocket $socketID "InsertHistoryResults $winName $row"} tmpError
    }
  }
  mysqlclose $dbSocketID
  catch {SendSocket $socketID "InsertHistoryResults $winName done"} tmpError
}
proc DBCommand { query } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS

  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }

  mysqlexec $dbSocketID $query
  mysqlclose $dbSocketID
  return 
}
proc UpdateDBStatusList { whereTmp timestamp status } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS
  set updateString "UPDATE event SET status=$status, last_modified='$timestamp' WHERE $whereTmp"
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  
  set execResults [mysqlexec $dbSocketID $updateString]
  mysqlclose $dbSocketID
}
proc UpdateDBStatus { eventID timestamp status } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS
  set sid [lindex [split $eventID .] 0]
  set cid [lindex [split $eventID .] 1]
  set updateString\
   "UPDATE event SET status=$status, last_modified='$timestamp' WHERE sid=$sid AND cid=$cid"
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  set execResults [mysqlexec $dbSocketID $updateString]
  mysqlclose $dbSocketID
}
proc GetIPData { socketID sid cid } {
  set query\
   "SELECT INET_NTOA(src_ip), INET_NTOA(dst_ip), ip_ver, ip_hlen, ip_tos, ip_len, ip_id,\
    ip_flags, ip_off, ip_ttl, ip_csum\
   FROM event\
   WHERE sid=$sid and cid=$cid"

  set queryResults [FlatDBQuery $query]
  catch {SendSocket $socketID "InsertIPHdr $queryResults"} tmpError
}
proc GetTcpData { socketID sid cid } {
  set query\
   "SELECT tcp_seq, tcp_ack, tcp_off, tcp_res, tcp_flags, tcp_win, tcp_csum, tcp_urp\
   FROM tcphdr\
   WHERE sid=$sid and cid=$cid"
  set queryResults [FlatDBQuery $query]
  set portQuery [FlatDBQuery "SELECT src_port, dst_port FROM event WHERE sid=$sid AND cid=$cid"]
  catch {SendSocket $socketID "InsertTcpHdr $queryResults $portQuery"} tmpError
}
proc GetIcmpData { socketID sid cid } {
  set query\
   "SELECT event.icmp_type, event.icmp_code, icmphdr.icmp_csum, icmphdr.icmp_id, icmphdr.icmp_seq\
   FROM event, icmphdr\
   WHERE event.sid=icmphdr.sid AND event.cid=icmphdr.cid AND event.sid=$sid AND event.cid=$cid"

  set queryResults [FlatDBQuery $query]
  
  set query\
   "SELECT data_payload FROM data WHERE sid=$sid and cid=$cid"
  
  set plqueryResults [FlatDBQuery $query]

  catch {SendSocket $socketID "InsertIcmpHdr $queryResults $plqueryResults"} tmpError
}
proc GetPayloadData { socketID sid cid } {
  set query\
   "SELECT data_payload FROM data WHERE sid=$sid and cid=$cid"

  set queryResults [FlatDBQuery $query]
  catch {SendSocket $socketID "InsertPayloadData \{$queryResults\}"} tmpError
}
proc GetUdpData { socketID sid cid } {
  set query\
   "SELECT udp_len, udp_csum FROM udphdr WHERE sid=$sid and cid=$cid"

  set queryResults [FlatDBQuery $query]
  set portQuery [FlatDBQuery "SELECT src_port, dst_port FROM event WHERE sid=$sid AND cid=$cid"]
  catch {SendSocket $socketID "InsertUdpHdr $queryResults $portQuery"} tmpError
}

#
# SendSensorList: Sends a list of sensors for the end user to select from.
#
proc SendSensorList { socketID } {
  global sensorList
  set query "SELECT hostname FROM sensor"
  set sensorList [FlatDBQuery $query]
  if { $sensorList != "" } {
    puts $socketID "SensorList $sensorList"
  } else {
    puts $socketID "SensorList 0none0"
  }
}
#
# MonitorSensors: Sends current events to client. Adds client to clientList
#                 In the future sensorList will contain a list of sensors, for
#                 now the client gets everything.
#
proc MonitorSensors { socketID sensorList } {
  global DEBUG clientList clientMonitorSockets connectedAgents socketInfo
  if {$DEBUG} {puts "$socketID added to clientList"}
  lappend clientList $socketID
  foreach sensorName $sensorList {
    lappend clientMonitorSockets($sensorName) $socketID
  }
  SendSystemInfoMsg sguild "User [lindex $socketInfo($socketID) 2] is monitoring sensors: $sensorList"
  SendCurrentEvents $socketID
  #if { [info exists connectedAgents] } {
  #  SendSystemInfoMsg sguild "Connected sensors - $connectedAgents"
  #}
}

proc SendEscalatedEvents { socketID } {
  global escalateIDList escalateArray
  if [info exists escalateIDList] {
    foreach escalateID $escalateIDList {
      catch {SendSocket $socketID "InsertEscalatedEvent $escalateArray($escalateID)"} tmpError
    }
  }
}

#
# SendCurrentEvents: Sends newly connected clients the current event list
#
proc SendCurrentEvents { socketID } {
  global eventIDArray eventIDList DEBUG clientMonitorSockets
  
  if { [info exists eventIDList] && [llength $eventIDList] > 0 } {
    foreach eventID $eventIDList {
      set sensorName [lindex $eventIDArray($eventID) 3]
      if { [info exists clientMonitorSockets($sensorName)] } {
        if { [lsearch -exact $clientMonitorSockets($sensorName) $socketID] >= 0} {
          if {$DEBUG} { puts "Sending client $socketID: InsertEvent $eventIDArray($eventID)" }
          catch {SendSocket $socketID "InsertEvent $eventIDArray($eventID)"} tmpError
        }
      }
    }
  }
}
proc CreateDB { DBNAME } {
  global dbSocketID
  puts -nonewline "The database $DBNAME does not exist. Create it (\[y\]/n)?: "
  flush stdout
  set answer [gets stdin]
  if { $answer == "" } { set answer y }
  if { ![regexp {^[yY]} $answer] } { return 0 }
  set fileName "./sql_scripts/create_sguildb.sql"
  puts -nonewline "Path to create_sguildb.sql \[$fileName\]: "
  flush stdout
  set answer [gets stdin]
  if { $answer != "" } { set fileName $answer }
  if { ! [file exists $fileName] } {
    puts "File does not exist: $fileName"
    return 0
  }
  puts -nonewline "Creating the DB $DBNAME..."
  if [ catch {mysqlexec $dbSocketID "CREATE DATABASE $DBNAME"} createDBError] {
    puts $createDBError
    return 0
  }
  mysqluse $dbSocketID $DBNAME
  puts "Okay."
  if [catch {set fileID [open $fileName r]} openFileError] {
    puts $openFileError
    return 0
  }
  puts -nonewline "Creating the structure for $DBNAME: "
  foreach line [split [read $fileID] \n] {
    puts -nonewline "."
    if { $line != "" && ![regexp {^--} $line]} {
      #puts "LINE: $line"
      if { [regexp {(^.*);\s*$} $line match data] } {
        lappend mysqlCmd $data
        #puts "CMD: [join $mysqlCmd]"
        mysqlexec $dbSocketID [join $mysqlCmd]
        set mysqlCmd ""
      } else {
        lappend mysqlCmd $line
      }
    }
  }
  close $fileID
  puts "Done."
  return 1
}
proc Daemonize {} {
  global PID_FILE DEBUG
  set DEBUG 0
  set childPID [fork]
  # Parent exits.
  if { $childPID == 0 } { exit }
  id process group set
  if {[fork]} {exit 0}
  set PID [id process]
  if { ![info exists PID_FILE] } { set PID_FILE "/var/run/sguild.pid" }
  set PID_DIR [file dirname $PID_FILE]
  if { ![file exists $PID_DIR] || ![file isdirectory $PID_DIR] || ![file writable $PID_DIR] } {
    puts "ERROR: Directory $PID_DIR does not exists or is not writable."
    puts "Process ID will not be written to file."
  } else {
    set pidFileID [open $PID_FILE w]
    puts $pidFileID $PID
    close $pidFileID
  }
  signal trap {QUIT TERM} CleanExit
}
######################## END PROCS ##############################

###################### MAIN #####################################

set validSockets ""

# Load mysql support.
package require mysqltcl
# Load extended tcl
package require Tclx

# GetOpts
set state flag
foreach arg $argv {
  switch -- $state {
    flag {
      switch -glob -- $arg {
        -- { set state flag }
        -h { DisplayUsage }
        -c { set state conf }
        -u { set state users_file }
        -D { set DAEMON_CONF_OVERRIDE 1 }
        -P { set state pid_file }
        -O { set state openssl }
        -o { set OPENSSL 1 }
        -C { set state certs }
        default { DisplayUsage $argv0 }
      }
    }
    conf { set CONF_FILE $arg; set state flag }
    users_file { set USERS_FILE $arg; set state flag }
    pid_file { set PID_FILE $arg; set state flag }
    openssl { set OPENSSL 1; set TLS_PATH $arg; set state flag }
    certs { set CERTS_PATH $arg; set state flag }
    default { DisplayUsage $argv0 }
  }
}

# Check openssl requirements if enabled
if { [info exists OPENSSL] && $OPENSSL } {
  set VERSION "$VERSION OPENSSL ENABLED"
  # Need a path to the tls libs
  if { [info exists TLS_PATH] } {
    if [catch {load $TLS_PATH} tlsError] {
      puts "ERROR: Unable to load tls libs ($TLS_PATH): $tlsError"
      DisplayUsage $argv0
    }
  }
  package require tls
  # Check for certs
  if {![info exists CERTS_PATH]} {
    set CERTS_PATH /etc/sguild/certs
  }
  if {![file exists $CERTS_PATH] || ![file isdirectory $CERTS_PATH]} {
    puts "ERROR: $CERTS_PATH does not exist or is not a directory"
    DisplayUsage $argv0
  }
  # Need sguild.key and sguild.pem
  set PEM [file join $CERTS_PATH sguild.pem]
  set KEY [file join $CERTS_PATH sguild.key]
  global KEY
  puts "KEY is $KEY"
  if {![file exists $PEM] || ![file readable $PEM] } {
    puts "ERROR: $PEM does not exist or is not readable"
    DisplayUsage $argv0
  }
  if {![file exists $KEY] || ![file readable $KEY] } {
    puts "ERROR: $KEY does not exist or is not readable"
    DisplayUsage $argv0
  }
  # If we get this far we should be good.
} else {
  set OPENSSL 0
  set VERSION "$VERSION OPENSSL DISABLED"
}

if { ![info exists CONF_FILE] } {
  # No conf file specified check the defaults
  if { [file exists ./sguild.conf] } {
    set CONF_FILE ./sguild.conf
  } elseif { [file exists /etc/sguil/sguild.conf] } {
    set CONF_FILE /etc/sguil/sguild.conf
  } else {
    puts "Couldn't determine where the sguil config file is"
    puts "Looked for ./sguild.conf and /etc/sguil/sguild.conf."
    DisplayUsage $argv0
  }
}
set i 0
if { [info exists CONF_FILE] } {
  # Parse the config file. Currently the only option is to 
  # create a variable using 'set varName value' 
  for_file line $CONF_FILE {
    incr i
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      if { [CheckLineFormat $line] } {
        if { [catch {eval $line} evalError] } {
          puts "Error at line $i in $CONF_FILE: $line"
          CleanExit
        }
      } else {
        puts "Error at line $i in $CONF_FILE: $line"
        CleanExit
      }
    }
  }
} else {
  DisplayUsage $argv0
}
# Deamon
if {[info exists DAEMON_CONF_OVERRIDE] && $DAEMON_CONF_OVERRIDE} { set DAEMON 1}
if {$DAEMON} { Daemonize }
# Check for a valid USERS file
if { ![info exists USERS_FILE] } {
  # No users file was specified. Go with the defaults
  if { [file exists /etc/sguil/sguild.users] } {
    set USERS_FILE "/etc/sguil/sguild.users"
  } elseif { [file exists ./sguild.users] } {
    set USERS_FILE "./sguild.users"
  } else {
    puts "ERROR: Could not find a sguild.users file."
    puts "       Checked in ./ and /etc/sguil/"
    DisplayUsage $argv0
  }
} else {
  if { ![file exists $USERS_FILE] } {
    puts "ERROR: $USERS_FILE does not exist"
    DisplayUsage $argv0
  }
}

# Get archived alerts from the DB
if { $DBPASS == "" } {
  set dbSocketID [mysqlconnect -host $DBHOST -user $DBUSER -port $DBPORT]
} else {
  set dbSocketID [mysqlconnect -host $DBHOST -user $DBUSER -port $DBPORT -password $DBPASS]
}
# See if the DB we want to use exists
if { [catch {mysqluse $dbSocketID $DBNAME} noDBError] } {
  puts "Error: $noDBError"
  # Create the DB or die.
  if {![CreateDB $DBNAME]} { exit }
}
if {$DEBUG} {
  puts "Querying DB for archived events..."
  puts "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=0"
}
foreach row [mysqlsel $dbSocketID "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=0" -list] {
  if {$DEBUG} {puts "Archived Alert: $row"}
  AddEventToEventArray $row
  SendEvent $row
}
if {$DEBUG} {
  puts "Querying DB for escalated events..."
  puts "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=2"
}
foreach row [mysqlsel $dbSocketID "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=2" -list] {
  if {$DEBUG} {puts "Escalated Event: $row"}
  set escalatedEventID "[lindex $row 5].[lindex $row 6]"
  lappend escalateIDList $escalatedEventID
  set escalateArray($escalatedEventID) $row
}
# Get DB info (table names and column info)
if {$DEBUG} { puts "Retrieving DB info..." }
set tableNameList [mysqlinfo $dbSocketID tables]
foreach tableName $tableNameList {
  set tableArray($tableName) [mysqlcol $dbSocketID $tableName {name type length}]
}
mysqlclose $dbSocketID
set sensorQuery "SELECT hostname FROM sensor"
set sensorList [FlatDBQuery $sensorQuery]


# Open a socket for clients to connect to
if [catch {socket -server ClientConnect $SERVERPORT} serverSocket] {
  puts "ERROR: $serverSocket"
  exit
}
# Open a socket for sensors to connect to
if [catch {socket -server SensorConnect $SENSORPORT} sensorSocket] {
  puts "ERROR: $sensorSocket"
}
puts "Sguild Initialized."

# Infinate wait
vwait FOREVER

