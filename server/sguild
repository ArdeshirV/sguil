#!/bin/sh
# Run tcl from users PATH \
exec tclsh "$0" "$@"

# $Id: sguild,v 1.74 2004/01/02 18:29:21 bamm Exp $ #

# Copyright (C) 2002-2003 Robert (Bamm) Visscher <bamm@satx.rr.com>
#
# This program is distributed under the terms of version 1.0 of the 
# Q Public License.  See LICENSE.QPL for further details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

########################## GLOBALS ##################################

set VERSION "SGUIL-0.3.0"
set DB_VERSION "0.7"

# Config options moved to sguild.conf

######################## END GLOBALS ################################

########################## PROCS ####################################

proc ForkLoader {} {
  global DEBUG loaderWritePipe
  # First create some pipes to communicate thru
  pipe loaderReadPipe loaderWritePipe
  # Fork the child
  if {[set childPid [fork]] == 0 } {
    # We are the child now.
    proc ParentCmdRcvd { pipeID } {
      global DEBUG
      fconfigure $pipeID -buffering line
      if { [eof $pipeID] || [catch {gets $pipeID data}] } {
        exit
      } else {
        set fileName [lindex $data 0]
        set cmd [lindex $data 1]
        if [catch {eval exec $cmd} loadError] {
          puts "Unable to load PS data into DB."
          puts $loadError
        } else {
          file delete $fileName
          if {$DEBUG} {puts "$cmd"}
        }
      }
    }
    fileevent $loaderReadPipe readable [list ParentCmdRcvd $loaderReadPipe]
    if {$DEBUG} { puts "Loader Forked" }
  }
  return $childPid
}
proc DisplayUsage { cmdName } {
  puts "Usage: $cmdName \[-D\] \[-h\] \[-o\] \[-c <filename>\] \[-u <filename>\] \[-P <filename>\]"
  puts "         \[-O <filename>\] \[-C <directory\]"
  puts "       $cmdName \[-u <filename\] \[-adduser <username>\] \[-deluser <username\]"
  puts "  -c <filename>: PATH to the sguild config (sguild.conf) file."
  puts "  -a <filename>: PATH to the sguild config (autocat.conf) file."
  puts "  -g <filename>: PATH to the sguild global queries (sguild.queries) file."
  puts "  -u <filename>: PATH to the sguild users (sguild.users) file."
  puts "  -P <filename>: Name of file to write the PID to."
  puts "                 Default is /var/run/sguild.pid"
  puts "  -o Enable OpenSSL"
  puts "  -O <filename>: Enable OpenSSL using PATH to tls (tcl openssl) lib (libtls1.4.so)"
  puts "  -C <directory>: Directory that contains sguild.pem and sguild.key"
  puts "  -D Runs sguild in daemon mode."
  puts "  -adduser <username>: Add user to sguild.users"
  puts "  -deluser <username>: Delete user from sguild.users"
  puts "  -h Display this help"
  CleanExit
}
proc HupTrapped {} {
  global DEBUG AUTOCAT_FILE GLOBAL_QRY_FILE GLOBAL_QRY_LIST clientList
  global acRules acCat 
  if { $DEBUG } { puts "HUP signal caught." }
  # Reload auto cat rules
  if { $DEBUG } { puts "Reloading AutoCat rules: $AUTOCAT_FILE" }
  # Clear the current rules
  if [info exists acRules] { unset acRules }
  if [info exists acCat] { unset acCat }
  if { [ file exists $AUTOCAT_FILE] } {
    LoadAutoCatFile $AUTOCAT_FILE
  }
  # reload global queries.
  if { $DEBUG } { puts "Reloaded Global Queries: $GLOBAL_QRY_FILE" }
  # Clear the current list
  set GLOBAL_QRY_LIST ""
  if { [file exists $GLOBAL_QRY_FILE] } {
    LoadGlobalQueries $GLOBAL_QRY_FILE
  } else {
    set GLOBAL_QRY_LIST none
  }
  foreach clientSocket $clientList {
    SendSocket $clientSocket "GlobalQryList $GLOBAL_QRY_LIST"
  }
}
proc LoadAutoCatFile { filename } {
  set i 0
  for_file line $filename {
    if ![regexp ^# $line] {
      set cTime [ctoken line "||"]
      if { $cTime != "none" && $cTime != "NONE" } {
        set cTimeSecs [clock scan "$cTime" -gmt true]
        if { $cTimeSecs > [clock seconds] } {
          # Set up the removal
          set DELAY [expr ($cTimeSecs - [clock seconds]) * 1000]
          after $DELAY RemoveAutoCatRule $i
          AddAutoCatRule $line $i
          incr i
        }
      } else {
        AddAutoCatRule $line $i
        incr i
      }
    }
  }
}
proc RemoveAutoCatRule { rid } {
  global acRules acCat DEBUG
  if {$DEBUG} { puts "Removing Rule: $acRules($rid)" }
  unset acRules($rid)
  unset acCat($rid)
}
proc AddAutoCatRule { line rid } {
  global acRules acCat DEBUG
  if {$DEBUG} {puts "Adding AutoCat Rule: $line"}
  foreach dIndex [list 3 8 11 9 12 10 7] {
    set tmpVar [ctoken line "||"]
    if { $tmpVar != "any" && $tmpVar != "ANY" } {
      lappend acRules($rid) [list $dIndex $tmpVar]
    }
  }
  set acCat($rid) [ctoken line "||"]
}
proc AutoCat { data } {
  global acRules acCat DEBUG AUTOID
  foreach rid [array names acRules] {
    set MATCH 1
    foreach rule [lrange $acRules($rid) 0 end] {
      set rIndex [lindex $rule 0]
      set rMatch [lindex $rule 1]
      if { [lindex $data $rIndex] != $rMatch } {
        set MATCH 0
        break
      } 
    }
    if { $MATCH } {
      if {$DEBUG} {puts "AUTO MARKING EVENT AS : $acCat($rid)"}
      UpdateDBStatus "[lindex $data 5].[lindex $data 6]" [GetCurrentTimeStamp] $AUTOID $acCat($rid)
      InsertHistory [lindex $data 5] [lindex $data 6] $AUTOID [GetCurrentTimeStamp] $acCat($rid) "Auto Update"
      return 1
    }
  }
  return 0
}
proc CleanExit {} {
  global PID_FILE
  if { [info exists PID_FILE] && [file exists $PID_FILE] } {
    if [catch {file delete -force $PID_FILE} delError] {
      puts "ERROR: $delError"
    }
  }
  puts "Exiting..."
  exit
}
proc CreateUsersFile { fileName } {
  set dirName [file dirname $fileName]
  if { ![file exists $dirName] || ![file isdirectory $dirName] } {
    if [catch {file mkdir $dirName} dirError] {
      puts "Error: Could not create $dirName: $dirError"
      exit
    }
  }
  if [catch {open $fileName w} fileID] {
    puts "Error: Could not create $fileName: $fileID"
    exit
  } else {
    puts $fileID "#"
    puts $fileID "# WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING"
    puts $fileID "#"
    puts $fileID "# This file is automatically generated. Please do not edit it by hand."
    puts $fileID "# Doing so could corrupt the file and make it unreadable. Only when used"
    puts $fileID "# with OpenSSL enabled, is this considered secure."
    puts $fileID "#"
    puts $fileID "# WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING"
    puts $fileID "#"
    close $fileID
  }
}
proc DelUser { userName USERS_FILE } {
  set fileID [open $USERS_FILE r]
  set USERFOUND 0
  for_file line $USERS_FILE {
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      # User file is boobie deliminated
      set tmpLine $line
      if { $userName == [ctoken tmpLine "(.)(.)"] } {
        set USERFOUND 1
      } else {
        lappend tmpData $line
      }
    } else {
      lappend tmpData $line
    }
  }
  close $fileID
  if { !$USERFOUND } {
    puts "ERROR: User \'$userName\' does NOT exist in $USERS_FILE"
  } else {
    if [catch {open $USERS_FILE w} fileID] {
      puts "ERROR: Could not edit $USERS_FILE: $fileID"
    } else {
      foreach line $tmpData {
        puts $fileID $line
      }
      close $fileID
    }
  }
}
proc AddUser { userName USERS_FILE } {
  # Usernames must be alpha-numeric
  if { ![string is alnum $userName] } {
    puts "ERROR: Unsername must be alpha-numeric"
    return
  }
  # Make sure we aren't adding a dupe.
  set fileID [open $USERS_FILE r]
  for_file line $USERS_FILE {
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      # User file is boobie deliminated
      if { $userName == [ctoken line "(.)(.)"] } {
        puts "ERROR: User \'$userName\' already exists in $USERS_FILE."
        return
      }
    }
  }
  close $fileID
  # Get a passwd
  puts -nonewline "Please enter a passwd for $userName: "
  flush stdout
  exec stty -echo
  set passwd1 [gets stdin]
  exec stty echo
  puts -nonewline "\nRetype passwd: "
  flush stdout
  exec stty -echo
  set passwd2 [gets stdin]
  exec stty echo
  puts ""
  if { $passwd1 != $passwd2} {
    puts "ERROR: Passwords didn't match."
    puts "$USERS_FILE NOT updated."
    return
  }
  set salt [format "%c%c" [GetRandAlphaNumInt] [GetRandAlphaNumInt] ]
  # make a hashed passwd
  set hashPasswd [::sha1::sha1 "${passwd1}${salt}"]
  set fileID [open $USERS_FILE a]
  puts $fileID "${userName}(.)(.)${salt}${hashPasswd}"
  close $fileID
  puts "User \'$userName\' added successfully"
}
proc GetRandAlphaNumInt {} {
  set x [expr [random 74] + 48]
  while {!($x >= 48 && $x <= 57) && !($x >= 65 && $x <= 90)\
      && !($x >= 97 && $x <= 122)} {
     set x [expr [random 74] + 48]
  }
  return $x
}
# Reads file and adds queries to GLOBAL_QRY_LIST
proc LoadGlobalQueries { fileName } {
  global GLOBAL_QRY_LIST
  for_file line $fileName {
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      lappend GLOBAL_QRY_LIST $line
    }
  }
}
#
# CheckLineFormat - Parses CONF_FILE lines to make sure they are formatted
#                   correctly (set varName value). Returns 1 if good.
#
proc CheckLineFormat { line } {
  
  set RETURN 1
  # Right now we just check the length and for "set".
  if { [llength $line] != 3 || [lindex $line 0] != "set" } { set RETURN 0 }
  return $RETURN
}   

proc ValidateUser { socketID username } {
  global USERS_FILE validSockets socketInfo userIDArray
  fileevent $socketID readable {}
  fconfigure $socketID -buffering line
  if { ![file exists $USERS_FILE] } {
    puts "Fatal Error! Cannot access $USERS_FILE."
    exit 1
  } 
  set VALID 0
  set nonce [format "%c%c%c" [GetRandAlphaNumInt] [GetRandAlphaNumInt] [GetRandAlphaNumInt] ]
  for_file line $USERS_FILE {
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      # Probably should check for corrupted info here
      set tmpUserName [ctoken line "(.)(.)"]
      set tmpSaltHash [ctoken line "(.)(.)"]
      if { $tmpUserName == $username } {
        set VALID 1
        set tmpSalt [string range $tmpSaltHash 0 1]
        set finalCheck [::sha1::sha1 "${nonce}${tmpSaltHash}"]
        break
      }
    }
  }
  if {$VALID} {
    puts $socketID "$tmpSalt $nonce"
    set finalClient [gets $socketID]
    if { $finalClient == $finalCheck } {
      set userIDArray($socketID) [GetUserID $username]
      DBCommand\
       "UPDATE user_info SET last_login='[GetCurrentTimeStamp]' WHERE uid=$userIDArray($socketID)"
      lappend validSockets $socketID
      catch { SendSocket $socketID "UserID $userIDArray($socketID)" } tmpError
      SendSystemInfoMsg sguild "User $username logged in from [lindex $socketInfo($socketID) 0]"
      lappend socketInfo($socketID) $username
    } else {
      set validSockets [ldelete $validSockets $socketID]
      catch {SendSocket $socketID "UserID INVALID"} tmpError
      SendSystemInfoMsg sguild "User $username denied access from [lindex $socketInfo($socketID) 0]"
    } 
  } else {
    #Not a valid user. Make up info.
    set tmpSalt [format "%c%c" [GetRandAlphaNumInt] [GetRandAlphaNumInt] ]
    set finalCheck [::sha1::sha1 "${nonce}${tmpSalt}"]
    puts $socketID "$tmpSalt $nonce"
    set finalClient [gets $socketID]
    set validSockets [ldelete $validSockets $socketID]
    catch {SendSocket $socketID "UserID INVALID"} tmpError
    SendSystemInfoMsg sguild "User $username denied access from [lindex $socketInfo($socketID) 0]"
  }
  fileevent $socketID readable [list ClientCmdRcvd $socketID]
}
proc GetUserID { username } {
  set uid [FlatDBQuery "SELECT uid FROM user_info WHERE username='$username'"]
  if { $uid == "" } {
    DBCommand\
     "INSERT INTO user_info (username, last_login) VALUES ('$username', '[GetCurrentTimeStamp]')"
    set uid [FlatDBQuery "SELECT uid FROM user_info WHERE username='$username'"]
  }
  return $uid
}
#
# ClientCmdRcvd: Called when client sends commands.
#
proc ClientCmdRcvd { socketID } {
  global DEBUG clientList validSockets GLOBAL_QRY_LIST

  if { [eof $socketID] || [catch {gets $socketID data}] } {
    # Socket closed
    close $socketID
    ClientExitClose $socketID
    if {$DEBUG} { puts "Socket $socketID closed" }
  } else {
    if {$DEBUG} {puts "Clent Command Recieved: $data"}
    set origData $data
    set clientCmd [ctoken data " "]
    # Check to make the client validated itself
    if { $clientCmd != "ValidateUser" && $clientCmd != "PING" } {
      if { [lsearch -exact $validSockets $socketID] < 0 } {
        catch {SendSocket $socketID\
         "InfoMessage {Client does not appear to be logged in. Please exit and log back in.}"} tmpError
      return
      }
    }
    set data1 [string trimleft $data]
    # data1 will contain the list from index 1 on. 
    set index1 [ctoken data " "]
    set data2 [string trimleft $data]
    # data2 now contains only indices 2 on, because ctoken chops tokens off
    set index2 [ctoken data " "]
    # data3 now contains indicies 3 on
    set data3 [string trimleft $data]
    set index3 [ctoken data " "]
    set index4 [ctoken data " "]
    switch -exact $clientCmd {
      DeleteEventID { $clientCmd $socketID $index1 $index2 }
      DeleteEventIDList { $clientCmd $socketID $data1 }
      EventHistoryRequest { $clientCmd $socketID $index1 $index2 $data3 }
      ExecDB { $clientCmd $socketID $data1 }
      GetIcmpData { $clientCmd $socketID $index1 $index2 }
      GetIPData { $clientCmd $socketID $index1 $index2 }
      GetPayloadData { $clientCmd $socketID $index1 $index2 }
      GetPSData { $clientCmd $socketID $index1 $index2 $data3 }
      GetTcpData { $clientCmd $socketID $index1 $index2 }
      GetUdpData { $clientCmd $socketID $index1 $index2 }
      MonitorSensors { $clientCmd $socketID $data1 } 
      QueryDB { $clientCmd $socketID $index1 $data2 }
      RuleRequest { $clientCmd $socketID $index1 $data2 }
      SendSensorList { $clientCmd $socketID }
      SendEscalatedEvents { $clientCmd $socketID }
      SendDBInfo { $clientCmd $socketID }
      ValidateUser { ValidateUser $socketID $index1 }
      PING { puts $socketID "PONG" }
      UserMessage { UserMsgRcvd $socketID $data1 }
      SendGlobalQryList { SendSocket $socketID "GlobalQryList $GLOBAL_QRY_LIST" }
      ReportRequest { ReportBuilder $socketID $index1 $index2 $index3 }
      default { if {$DEBUG} {puts "Unrecognized command from $socketID: $origData"} }
    }
  }
}

proc UserMsgRcvd { socketID userMsg } {
  global socketInfo clientList

  set userMsg [lindex $userMsg 0]

  # Simple command crap.
  if { $userMsg == "who" } {
     foreach client $clientList { lappend usersList [lindex $socketInfo($client) 2] }
     SendSocket $socketID "UserMessage sguild \{Connected users: $usersList\}" 
  } else {
    foreach client $clientList {
      SendSocket $client [list UserMessage [lindex $socketInfo($socketID) 2] $userMsg]
    }
  }
}
proc ClientExitClose { socketID } {
  global clientList  clientMonitorSockets validSockets socketInfo
  if { [info exists clientList] } {
    set clientList [ldelete $clientList $socketID]
  }
  if { [info exists clientMonitorSockets] } {
    foreach sensorName [array names clientMonitorSockets] {
      set clientMonitorSockets($sensorName) [ldelete $clientMonitorSockets($sensorName) $socketID]
    }
  }
  if { [info exists validSockets] } {
    set validSockets [ldelete $validSockets $socketID]
  }
  if { [info exists socketInfo($socketID)] } {
    SendSystemInfoMsg sguild "User [lindex $socketInfo($socketID) 2] has disconnected."
    unset socketInfo($socketID)
  }
}

#
# EventRcvd: Called by main when events are received.
#
proc EventRcvd { socketID data } {
  global DEBUG EMAIL_EVENTS EMAIL_CLASSES EMAIL_DISABLE_SIDS EMAIL_ENABLE_SIDS
  global acRules acCat
  set eventDataList [lrange [split $data |] 1 end]
  if { [lindex $eventDataList 2] == "system-info" } {
    if {$DEBUG} {
      puts "SYSTEM INFO: $eventDataList"
    }
    puts $socketID "CONFIRM system msg"
    set sensorName [lindex $eventDataList 3]
    set message [lindex $eventDataList 5]
    SendSystemInfoMsg $sensorName $message
  } else {
    if {$DEBUG} {
      puts "Alert Received: $eventDataList"
    }
    puts $socketID "CONFIRM [lindex $eventDataList 6]"
    flush $socketID
    # I we don't have any auto-cat rules, or we don't match on
    # the autocat, then we send off the rule
    if { ![array exists acRules] || ![AutoCat $eventDataList] } {
      AddEventToEventArray $eventDataList
      SendEvent $eventDataList
      if { $EMAIL_EVENTS } {
        #Ug-ly. Things will get better when the rules are in the DB.
        set sid [lindex $eventDataList 13]
        set class [lindex $eventDataList 2]
        if { ([lsearch -exact $EMAIL_CLASSES $class] >= 0\
             && [lsearch -exact $EMAIL_DISABLE_SIDS $sid] < 0)
             || [lsearch -exact $EMAIL_ENABLE_SIDS $sid] >= 0 } {
          EmailEvent $eventDataList
        }
      }
    }
  }
}
proc EmailEvent { dataList } {
  global SMTP_SERVER EMAIL_RCPT_TO EMAIL_FROM EMAIL_SUBJECT EMAIL_MSG
  global DEBUG
  set msg [lindex $dataList 7]
  set sn [lindex $dataList 3]
  set t [lindex $dataList 4]
  set sip [lindex $dataList 8]
  set dip [lindex $dataList 9]
  set sp [lindex $dataList 11]
  set dp [lindex $dataList 12]
  regsub -all {%} $EMAIL_MSG {$} tmpMsg
  set tmpMsg [subst -nobackslashes -nocommands $tmpMsg]
  if {$DEBUG} {puts "Sending Email: $tmpMsg"}
  set token [mime::initialize -canonical text/plain -string $tmpMsg]
  if { [info exists EMAIL_SUBJECT] } { mime::setheader $token Subject $EMAIL_SUBJECT }
  smtp::sendmessage $token -recipients $EMAIL_RCPT_TO -servers $SMTP_SERVER -originator $EMAIL_FROM
  mime::finalize $token
  if {$DEBUG} {puts "Email sent to: $EMAIL_RCPT_TO"}
}

proc GetCurrentTimeStamp {} {
  set timestamp [clock format [clock seconds] -gmt true -f "%Y-%m-%d %T"]
  return $timestamp 
} 


#
# ldelete: Delete item from a list
#
proc ldelete { list value } {
  set ix [lsearch -exact $list $value]
  if {$ix >= 0} {
    return [lreplace $list $ix $ix]
  } else {
    return $list
  }
}


#
# SendSocket: Send command to client
#
proc SendSocket { socketID command } {
  global clientList DEBUG
  if {$DEBUG} {puts "Sending $socketID: $command"}
  if { [catch {puts $socketID $command} sendError] } {
    if {$DEBUG} { puts "Error sending \"$command\" to $socketID" }
    catch { close $socketID } closeError
    # Remove socket from the client list
    ClientExitClose $socketID
    return -code error -errorinfo $sendError
  }
  catch {flush $socketID} flushError
}

#
# SendEvent: Send events to connected clients
#
proc SendEvent { eventDataList } {
  global DEBUG clientList
  if { [info exists clientList] && [llength $clientList] > 0 } {
    foreach clientSocket $clientList {
      catch {SendSocket $clientSocket "InsertEvent $eventDataList"} tmpError
    }
  } else {
    if {$DEBUG} { puts "No clients to send alert to." }
  }
}
proc SendSystemInfoMsg { sensor msg } {
  global clientList DEBUG
  if { [info exists clientList] && [llength $clientList] > 0 } {
    foreach clientSocket $clientList {
      catch {SendSocket $clientSocket "InsertSystemInfoMsg $sensor $msg"} tmpError
    }
  } else {
    if {$DEBUG} { puts "No clients to send info msg to." }
  }
}
#
# AddEventToEventArray: Global eventIDArray contains current events.
#
proc AddEventToEventArray { eventDataList } {
  global eventIDArray eventIDList sensorIDList
  set eventID [join [lrange $eventDataList 5 6] .]
  set sensorName [lindex $eventDataList 3]
  set eventIDArray($eventID) $eventDataList
  # Arrays are not kept in any particular order so we have to keep
  # a list in order to control the order the clients recieve events
  lappend eventIDList $eventID
}

proc DeleteEventIDList { socketID data } {
  global eventIDArray eventIDList clientList escalateArray escalateIDList
  global userIDArray
  
  regexp {^(.*)::(.*)::(.*)$} $data allMatch status comment deleteEventIDList
  set count 0
  set updateTmp ""
  foreach socket $clientList {
    # Sending a DeleteEventID to the originating client allows us
    # to remove events from the RT panes when deleting from a query.
    # Problem is, we could delete a correlated event parent without
    # deleting the children thus leaving alerts that haven't been 
    # dealt with. 
    catch {SendSocket $socket "DeleteEventIDList $deleteEventIDList"} tmpError
  }
  foreach eventID $deleteEventIDList {
    if { [info exists escalateIDList] } {set escalateIDList [ldelete $escalateIDList $eventID]}
    # If status == 2 then escalate
    if {$status == 2} {
      lappend escalateIDList $eventID
      if [info exists eventIDArray($eventID)] {
        set escalateArray($eventID) $eventIDArray($eventID)
      } else {
        set escalateArray($eventID) [FlatDBQuery\
         "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.sid=[lindex [split $eventID .] 0] AND event.cid=[lindex [split $eventID .] 1]"]
      }
      foreach socket $clientList {
        catch {SendSocket $socket "InsertEscalatedEvent $escalateArray($eventID)"} tmpError
      }
    }
    if { [info exists eventIDArray($eventID)] } { unset eventIDArray($eventID) }
    if [info exists eventIDList] {
      set eventIDList [ldelete $eventIDList $eventID]
    }
    set splitID [split $eventID .]
    set sid [lindex $splitID 0]
    set cid [lindex $splitID 1]
    if { $count < 1000 } {
      set updateTmp "$updateTmp (sid=$sid AND cid=$cid)"
    } else {
      regsub -all {\) \(} $updateTmp {) OR (} whereTmp
      UpdateDBStatusList $whereTmp [GetCurrentTimeStamp] $userIDArray($socketID) $status
      set count 0
      set updateTmp "(sid=$sid AND cid=$cid)"
    }
    # Update the history here
    InsertHistory $sid $cid $userIDArray($socketID) [GetCurrentTimeStamp] $status $comment
    incr count
  }
  regsub -all {\) \(} $updateTmp {) OR (} whereTmp
  UpdateDBStatusList $whereTmp [GetCurrentTimeStamp] $userIDArray($socketID) $status
}

proc InsertHistory { sid cid uid timestamp status comment} {
  if {$comment == "none"} {
    DBCommand "INSERT INTO history (sid, cid, uid, timestamp, status) VALUES ( $sid, $cid, $uid, '$timestamp', $status)"
  } else {
    DBCommand "INSERT INTO history (sid, cid, uid, timestamp, status, comment) VALUES ( $sid, $cid, $uid, '$timestamp', $status, '$comment')"
  }
}

proc DeleteEventID { socketID eventID status } {
  global eventIDArray eventIDList clientList escalateArray escalateIDList
  global userIDArray
  
  foreach socket $clientList {
    # See comments in DeleteEventIDList
    catch {SendSocket $socket "DeleteEventID $eventID"} tmpError
  }
  # If status == 2 then escalate
  if { $status == 2 } {
    lappend escalateIDList $eventID
    set escalateArray($eventID) $eventIDArray($eventID)
    foreach socket $clientList {
      catch {SendSocket $socket "InsertEscalatedEvent $escalateArray($eventID)"} tmpError
    }
  }
  if { [info exists escalateArray($eventID)] } { unset escalateArray($eventID) }
  if { [info exists escalateIDList] } {set escalateIDList [ldelete $escalateIDList $eventID]}
  if { [info exists eventIDArray($eventID)] } { unset eventIDArray($eventID) }
  set eventIDList [ldelete $eventIDList $eventID]
  InsertHistory [lindex [split $eventID .] 0] [lindex [split $eventID .] 1]\
   $userIDArray($socketID) [GetCurrentTimeStamp] $status
  UpdateDBStatus $eventID [GetCurrentTimeStamp] $userIDArray($socketID) $status
}

proc SendDBInfo { socketID } {
  global tableNameList tableArray 
  catch {SendSocket $socketID "TableNameList $tableNameList"} tmpError
  foreach tableName $tableNameList {
    catch {SendSocket $socketID "TableColumns $tableName $tableArray($tableName)"} tmpError
  }
}
#
# ClientConnect: Sets up comms for client/server
#
proc ClientConnect { socketID IPAddr port } {
  global DEBUG socketInfo VERSION
  global OPENSSL KEY PEM
  if {$DEBUG} {
    puts "Client Connect: $IPAddr $port $socketID"
  }
  set socketInfo($socketID) "$IPAddr $port"
  fconfigure $socketID -buffering line
  # Do version checks
  if [catch {SendSocket $socketID "$VERSION"} sendError ] {
    return
  }
  if [catch {gets $socketID} clientVersion] {
    if {$DEBUG} {puts "$ERROR: $clientVersion"}
    return
  }
  if { $clientVersion != $VERSION } {
    catch {close $socketID} tmpError
    if {$DEBUG} {puts "ERROR: Client connect denied - mismatched versions" }
    if {$DEBUG} {puts "CLIENT VERSION: $clientVersion" }
    if {$DEBUG} {puts "SERVER VERSION: $VERSION" }
    ClientExitClose $socketID
    return
  }
  if {$OPENSSL} {
    tls::import $socketID -server true -keyfile $KEY -certfile $PEM
    fileevent $socketID readable [list HandShake $socketID ClientCmdRcvd]
  } else {
    fileevent $socketID readable [list ClientCmdRcvd $socketID]
  } 
} 
proc HandShake { socketID cmd } {
  if {[eof $socketID]} {
    close $socketID
    ClientExitClose socketID
  } elseif { [catch {tls::handshake $socketID} results] } {
    puts "ERROR: $results"
    close $socketID
    ClientExitClose socketID
  } elseif {$results == 1} {
    puts "Handshake complete for $socketID"
    fileevent $socketID readable [list $cmd $socketID]
  }
}
proc SensorConnect { socketID IPAddr port } {
  global DEBUG
  if {$DEBUG} {puts "Connect from $IPAddr:$port $socketID"}
  fconfigure $socketID -buffering line -blocking 0
  fileevent $socketID readable [list SensorCmdRcvd $socketID]
}
proc GetSensorID { sensorName } {
  # For now we query the DB everytime we need the sid.
  set sid [FlatDBQuery "SELECT sid FROM sensor WHERE hostname='$sensorName'"]
  return $sid
}
proc RcvSsnFile { socketID fileName sensorName } {
  global DEBUG TMPDATADIR DBHOST DBPORT DBNAME DBUSER DBPASS loaderWritePipe
  set sensorID [GetSensorID $sensorName]
  if {$DEBUG} {puts "Recieving session file $fileName."}
  fconfigure $socketID -translation binary
  set DB_OUTFILE $TMPDATADIR/$fileName
  set fileID [open $DB_OUTFILE w]
  fcopy $socketID $fileID
  close $fileID
  close $socketID
  if {$sensorID == 0} {
    if {$DEBUG} {
      puts "ERROR: $sensorName is not in DB!!"
    }
    SendSystemInfoMsg sguild "ERROR: Received session file from unkown sensor - $sensorName"
    return
  }
  set inFileID [open $DB_OUTFILE r]
  set outFileID [open $DB_OUTFILE.tmp w]
  # Use i to keep track of how many lines we loaded into the database for DEBUG.
  set i 0
  # Load the entire file into memory (read $inFileID), then create a list
  # delimited by \n. Finally loop through each 'line', prepend the sensorID (sid)
  # to it, and append the new line to the tmp file.
  foreach line [split [read $inFileID] \n] {
    if {$line != ""} {puts $outFileID "$sensorID|$line"; incr i}
  }
  close $inFileID
  close $outFileID
  file delete $DB_OUTFILE

  if {$DEBUG} {puts "Loading $i cnxs from $fileName into DB."}
  if {$DBPASS != "" } {
    set cmd "mysql --local-infile -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER --password=$DBPASS\
     -e \"LOAD DATA LOCAL INFILE '$DB_OUTFILE.tmp' INTO TABLE sessions FIELDS TERMINATED\
     BY '|'\""
  } else {
    set cmd "mysql --local-infile -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER\
     -e \"LOAD DATA LOCAL INFILE '$DB_OUTFILE.tmp' INTO TABLE sessions FIELDS TERMINATED\
     BY '|'\""
  }
  # The loader child proc does the LOAD for us.
  puts $loaderWritePipe [list $DB_OUTFILE.tmp $cmd]
  flush $loaderWritePipe
}
proc RcvPortscanFile { socketID fileName } {
  global DEBUG TMPDATADIR DBHOST DBPORT DBNAME DBUSER DBPASS loaderWritePipe
  if {$DEBUG} {puts "Recieving portscan file $fileName."}
  fconfigure $socketID -translation binary
  set PS_OUTFILE $TMPDATADIR/$fileName
  set fileID [open $PS_OUTFILE w]
  fcopy $socketID $fileID
  close $fileID
  close $socketID
  if {$DEBUG} {puts "Loading $fileName into DB."}
  if {$DBPASS != "" } {
    set cmd "mysql --local-infile -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER --password=$DBPASS\
     -e \"LOAD DATA LOCAL INFILE '$PS_OUTFILE' INTO TABLE portscan FIELDS TERMINATED\
     BY '|'\""
  } else {
    set cmd "mysql --local-infile -D $DBNAME -h $DBHOST -P $DBPORT -u $DBUSER\
     -e \"LOAD DATA LOCAL INFILE '$PS_OUTFILE' INTO TABLE portscan FIELDS TERMINATED\
     BY '|'\""
  }
  # The loader child proc does the LOAD for us.
  puts $loaderWritePipe [list $PS_OUTFILE $cmd]
  flush $loaderWritePipe
}

proc DiskReport { socketID fileSystem percentage } {
  global agentSensorName
  SendSystemInfoMsg $agentSensorName($socketID) "$fileSystem $percentage"
}
proc SensorAgentConnect { socketID sensorName } {
  global connectedAgents agentSocket agentSensorName
  lappend connectedAgents $sensorName
  set agentSocket($sensorName) $socketID
  set agentSensorName($socketID) $sensorName
  SendSystemInfoMsg $sensorName "Agent connected."
}
proc CleanUpDisconnectedAgent { socketID } {
  global connectedAgents agentSocket agentSensorName

  set connectedAgents [ldelete $connectedAgents $agentSensorName($socketID)]
  set sensorName $agentSensorName($socketID)
  unset agentSocket($sensorName)
  unset agentSensorName($socketID)
}
proc SensorCmdRcvd { socketID } {
  global DEBUG connectedAgents agentSensorName
  if { [eof $socketID] || [catch {gets $socketID data}] } {
    # Socket closed
    close $socketID
    if {$DEBUG} { puts "Socket $socketID closed" }
    if { [info exists connectedAgents] && [info exists agentSensorName($socketID)] } {
      CleanUpDisconnectedAgent $socketID
    }
  } else {
    if {$DEBUG} { puts "Sensor Data Rcvd: $data" }
    # note that ctoken changes the string that it is operating on 
    # so instead of re-writing all of the proc to move up one in 
    # the index when looking at $data, I wrote $data to $tmpData
    # before using ctoken.  Probably should drop this and fix the
    # procs, but that can happen later
    set tmpData $data
    set sensorCmd [ctoken tmpData " "]
    # set sensorCmd [lindex $data 0]
    switch -exact -- $sensorCmd {
      RTEvent	{ EventRcvd $socketID $data }
      PSFile	{ RcvPortscanFile $socketID [lindex $data 1] }
      CONNECT   { SensorAgentConnect $socketID [lindex $data 1] }
      DiskReport { $sensorCmd $socketID [lindex $data 1] [lindex $data 2] }
      SsnFile	{ RcvSsnFile $socketID [lindex $data 1] [lindex $data 2] }
      PING	{ puts $socketID "PONG" }
      default	{ if {$DEBUG} {puts "Sensor Cmd Unkown ($socketID): $sensorCmd"} }
    }
  }
}

#
# RuleRequest finds rule based on message. Should change this to
# use sig ids in the future.
#
proc RuleRequest { socketID sensor message } {
  global RULESDIR DEBUG

  set RULEFOUND 0
  set ruleDir $RULESDIR/$sensor
  if { [file exists $ruleDir] } {
    foreach ruleFile [glob -nocomplain $ruleDir/*.rules] {
      if {$DEBUG} {puts "Checking $ruleFile..."}
      set ruleFileID [open $ruleFile r]
      while { [gets $ruleFileID data] >= 0 } {
        if { [string match "*$message*" $data] } {
          set RULEFOUND 1
          if {$DEBUG} {puts "Matching rule found in $ruleFile."}
          break
        }
      }
      close $ruleFileID
      if {$RULEFOUND} {break}
    }
  } else {
    set data "Could not find $ruleDir."
  }
  if {$RULEFOUND} { 
    catch {SendSocket $socketID "InsertRuleData $data"} tmpError
  } else {
    catch {SendSocket $socketID "InsertRuleData Unable to find matching rule in $ruleDir."} tmpError
  }
}
proc GetPSData { socketID timestamp srcIP MAX_PS_ROWS } {
  global DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG
  if { $MAX_PS_ROWS == 0 } {
    set query\
    "SELECT * FROM portscan WHERE timestamp > '$timestamp' AND src_ip='$srcIP'"
  } else {
    set query\
    "SELECT * FROM portscan WHERE timestamp > '$timestamp' AND src_ip='$srcIP' LIMIT $MAX_PS_ROWS"
  }
  if {$DEBUG} {puts "Getting PS data: $query"}
  if {$DBPASS == ""} {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  foreach row [mysqlsel $dbSocketID "$query" -list] {
    catch {SendSocket $socketID "PSDataResults $row"} tmpError
  }
  mysqlclose $dbSocketID
  catch {SendSocket $socketID "PSDataResults DONE"} tmpError
}
proc ExecDB { socketID query } {
  global DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG
    if { [lindex $query 0] == "OPTIMIZE" } {
	SendSystemInfoMsg sguild "Table Optimization beginning, please stand by"
    }
  if {$DEBUG} {puts "Sending DB Query: $query"}
  if { $DBPASS == "" } {
      set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
      set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  if [catch {mysqlexec $dbSocketID $query} execResults] {
	catch {SendSocket $socketID "InfoMessage \{ERROR running query, perhaps you don't have permission. Error:$execResults\}"} tmpError
  } else {
      if { [lindex $query 0] == "DELETE" } {
	  catch {SendSocket $socketID "InfoMessage Query deleted $execResults rows."} tmpError
      } elseif { [lindex $query 0] == "OPTIMIZE" } {
	  catch {SendSocket $socketID "InfoMessage Database Command Completed."} tmpError
	  SendSystemInfoMsg sguild "Table Optimization Completed."
      } else { 
	  catch {SendSocket $socketID "InfoMessge Database Command Completed."} tmpError
      }
  }
  mysqlclose $dbSocketID
}
 
proc QuerydCmdRcvd { pipeID } {
  if { [eof $pipeID] || [catch {gets $pipeID data}] } {
    exit
  } else {
    if [catch {SendSocket [lindex $data 0] [lrange $data 1 end]} tmpErr] { puts "$tmpErr" }
  }
}
proc ForkQueryd {} {
  global DEBUG mainWritePipe mainReadPipe
  # This pipe sends to queryd
  pipe queryReadPipe mainWritePipe
  # THis pipe lets queryd send back.
  pipe mainReadPipe queryWritePipe
  # Fork the child
  if {[set childPid [fork]] == 0 } {
    # We are the child now.
    proc mainCmdRcvd { inPipeID outPipeID } {
      global DEBUG
      fconfigure $inPipeID -buffering line
      if { [eof $inPipeID] || [catch {gets $inPipeID data}] } {
        exit
      } else {
        set dbCmd [lindex $data 3]
        set clientSocketID [lindex $data 0]
        set clientWinName [lindex $data 1]
        set query [lindex $data 2]
        if {$DEBUG} {puts "Sending DB Query: $query"}
        set dbSocketID [eval $dbCmd]
        if [catch {mysqlsel $dbSocketID "$query" -list} selResults] {
          puts $outPipeID "$clientSocketID InfoMessage $selResults"
        } else {
          set count 0
          foreach row $selResults {
            puts $outPipeID "$clientSocketID InsertQueryResults $clientWinName $row"
            incr count
          }
          puts $outPipeID "$clientSocketID InfoMessage Query returned $count row(s)."
        }
        puts $outPipeID "$clientSocketID InsertQueryResults $clientWinName done"
        flush $outPipeID
        mysqlclose $dbSocketID
      }
    }
    fileevent $queryReadPipe readable [list mainCmdRcvd $queryReadPipe $queryWritePipe]
    if {$DEBUG} { puts "Queryd Forked" }
  }
  return $childPid
}
proc QueryDB { socketID clientWinName query } {
  global mainWritePipe
  global DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG 

  # Just pass the query to queryd.
  if { $DBPASS == "" } {
    set dbCmd "mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT"
  } else {
    set dbCmd "mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS"
  }
  puts $mainWritePipe [list $socketID $clientWinName $query $dbCmd]
  flush $mainWritePipe
}
proc FlatDBQuery { query } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS

  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  set queryResults [mysqlsel $dbSocketID $query -flatlist]
  mysqlclose $dbSocketID
  return $queryResults
}
proc EventHistoryRequest { socketID winName sid cid } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  set query "SELECT history.sid, history.cid, user_info.username, history.timestamp, history.status, status.description, history.comment FROM history, user_info, status WHERE history.uid=user_info.uid AND history.status=status.status_id AND history.sid=$sid and history.cid=$cid"
  if [catch {mysqlsel $dbSocketID "$query" -list} selResults] {
    catch {SendSocket $socketID "InfoMessage $selResults"} tmpError
  } else {
    foreach row $selResults {
      catch {SendSocket $socketID "InsertHistoryResults $winName $row"} tmpError
    }
  }
  mysqlclose $dbSocketID
  catch {SendSocket $socketID "InsertHistoryResults $winName done"} tmpError
}
proc DBCommand { query } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS

  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }

  mysqlexec $dbSocketID $query
  mysqlclose $dbSocketID
  return 
}
proc UpdateDBStatusList { whereTmp timestamp uid status } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS
  set updateString "UPDATE event SET status=$status, last_modified='$timestamp', last_uid='$uid' WHERE $whereTmp"
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  
  set execResults [mysqlexec $dbSocketID $updateString]
  mysqlclose $dbSocketID
}
proc UpdateDBStatus { eventID timestamp uid status } {
  global DBNAME DBUSER DBPORT DBHOST DBPASS
  set sid [lindex [split $eventID .] 0]
  set cid [lindex [split $eventID .] 1]
  set updateString\
   "UPDATE event SET status=$status, last_modified='$timestamp', last_uid='$uid' WHERE sid=$sid AND cid=$cid"
  if { $DBPASS == "" } {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
  } else {
    set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
  }
  set execResults [mysqlexec $dbSocketID $updateString]
  mysqlclose $dbSocketID
}
proc GetIPData { socketID sid cid } {
  set query\
   "SELECT INET_NTOA(src_ip), INET_NTOA(dst_ip), ip_ver, ip_hlen, ip_tos, ip_len, ip_id,\
    ip_flags, ip_off, ip_ttl, ip_csum\
   FROM event\
   WHERE sid=$sid and cid=$cid"

  set queryResults [FlatDBQuery $query]
  catch {SendSocket $socketID "InsertIPHdr $queryResults"} tmpError
}
proc GetTcpData { socketID sid cid } {
  set query\
   "SELECT tcp_seq, tcp_ack, tcp_off, tcp_res, tcp_flags, tcp_win, tcp_csum, tcp_urp\
   FROM tcphdr\
   WHERE sid=$sid and cid=$cid"
  set queryResults [FlatDBQuery $query]
  set portQuery [FlatDBQuery "SELECT src_port, dst_port FROM event WHERE sid=$sid AND cid=$cid"]
  catch {SendSocket $socketID "InsertTcpHdr $queryResults $portQuery"} tmpError
}
proc GetIcmpData { socketID sid cid } {
  set query\
   "SELECT event.icmp_type, event.icmp_code, icmphdr.icmp_csum, icmphdr.icmp_id, icmphdr.icmp_seq\
   FROM event, icmphdr\
   WHERE event.sid=icmphdr.sid AND event.cid=icmphdr.cid AND event.sid=$sid AND event.cid=$cid"

  set queryResults [FlatDBQuery $query]
  
  set query\
   "SELECT data_payload FROM data WHERE sid=$sid and cid=$cid"
  
  set plqueryResults [FlatDBQuery $query]

  catch {SendSocket $socketID "InsertIcmpHdr $queryResults $plqueryResults"} tmpError
}
proc GetPayloadData { socketID sid cid } {
  set query\
   "SELECT data_payload FROM data WHERE sid=$sid and cid=$cid"

  set queryResults [FlatDBQuery $query]
  catch {SendSocket $socketID "InsertPayloadData \{$queryResults\}"} tmpError
}
proc GetUdpData { socketID sid cid } {
  set query\
   "SELECT udp_len, udp_csum FROM udphdr WHERE sid=$sid and cid=$cid"

  set queryResults [FlatDBQuery $query]
  set portQuery [FlatDBQuery "SELECT src_port, dst_port FROM event WHERE sid=$sid AND cid=$cid"]
  catch {SendSocket $socketID "InsertUdpHdr $queryResults $portQuery"} tmpError
}


#
# ReportBuilder:  Receive multiple data requests from the client for report building
#
proc ReportBuilder { socketID type sid cid } {
    switch -exact -- $type {
	TCP {
	    set query\
		"SELECT tcp_seq, tcp_ack, tcp_off, tcp_res, tcp_flags, tcp_win, tcp_csum, tcp_urp\
		FROM tcphdr\
		WHERE sid=$sid and cid=$cid"
	    set queryResults [FlatDBQuery $query]
	    set portQuery [FlatDBQuery "SELECT src_port, dst_port FROM event WHERE sid=$sid AND cid=$cid"]
	    catch {SendSocket $socketID "ReportResponse $type $queryResults $portQuery"} tmpError
	}
	UDP {
	    set query\
		"SELECT udp_len, udp_csum FROM udphdr WHERE sid=$sid and cid=$cid"

	    set queryResults [FlatDBQuery $query]
	    set portQuery [FlatDBQuery "SELECT src_port, dst_port FROM event WHERE sid=$sid AND cid=$cid"]
	    catch {SendSocket $socketID "ReportResponse $type $queryResults $portQuery"} tmpError
	}
        ICMP {
	    set query\
		"SELECT event.icmp_type, event.icmp_code, icmphdr.icmp_csum, icmphdr.icmp_id, icmphdr.icmp_seq\
		FROM event, icmphdr\
		WHERE event.sid=icmphdr.sid AND event.cid=icmphdr.cid AND event.sid=$sid AND event.cid=$cid"

	    set queryResults [FlatDBQuery $query]
  
	    set query\
		"SELECT data_payload FROM data WHERE sid=$sid and cid=$cid"
  
	    set plqueryResults [FlatDBQuery $query]
	    catch {SendSocket $socketID "ReportResponse $type $queryResults $plqueryResults"} tmpError
	}
	PAYLOAD {
	    set query\
		"SELECT data_payload FROM data WHERE sid=$sid and cid=$cid"

	    set queryResults [FlatDBQuery $query] 
	    catch {SendSocket $socketID "ReportResponse $type \{$queryResults\}"} tmpError
	}
	PORTSCAN {
	    global DBNAME DBUSER DBPASS DBPORT DBHOST DEBUG
	    set MAX_PS_ROWS 200
	    set timestamp $sid
	    set srcIP $cid
	    if { $MAX_PS_ROWS == 0 } {
		set query\
		    "SELECT * FROM portscan WHERE timestamp > '$timestamp' AND src_ip='$srcIP'"
	    } else {
		set query\
		    "SELECT * FROM portscan WHERE timestamp > '$timestamp' AND src_ip='$srcIP' LIMIT $MAX_PS_ROWS"
	    }
	    if {$DEBUG} {puts "Getting PS data: $query"}
	    if {$DBPASS == ""} {
		set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT]
	    } else {
		set dbSocketID [mysqlconnect -host $DBHOST -db $DBNAME -user $DBUSER -port $DBPORT -password $DBPASS]
	    }
	    foreach row [mysqlsel $dbSocketID "$query" -list] {
		catch {SendSocket $socketID "ReportResponse $type $row"} tmpError
	    }
	    mysqlclose $dbSocketID
	    catch {SendSocket $socketID "ReportResponse $type DONE"} tmpError
       }
       IP {
	    set query\
		"SELECT INET_NTOA(src_ip), INET_NTOA(dst_ip), ip_ver, ip_hlen, ip_tos, ip_len, ip_id,\
		ip_flags, ip_off, ip_ttl, ip_csum\
		FROM event\
		WHERE sid=$sid and cid=$cid"

	    set queryResults [FlatDBQuery $query]
	    catch {SendSocket $socketID "ReportResponse $type $queryResults"} tmpError
       }
    }
}

#
# SendSensorList: Sends a list of sensors for the end user to select from.
#
proc SendSensorList { socketID } {
  global sensorList
  set query "SELECT hostname FROM sensor WHERE active='Y'"
  set sensorList [FlatDBQuery $query]
  if { $sensorList != "" } {
    puts $socketID "SensorList $sensorList"
  } else {
    puts $socketID "SensorList 0none0"
  }
}
#
# MonitorSensors: Sends current events to client. Adds client to clientList
#                 In the future sensorList will contain a list of sensors, for
#                 now the client gets everything.
#
proc MonitorSensors { socketID sensorList } {
  global DEBUG clientList clientMonitorSockets connectedAgents socketInfo
  if {$DEBUG} {puts "$socketID added to clientList"}
  lappend clientList $socketID
  foreach sensorName $sensorList {
    lappend clientMonitorSockets($sensorName) $socketID
  }
  SendSystemInfoMsg sguild "User [lindex $socketInfo($socketID) 2] is monitoring sensors: $sensorList"
  SendCurrentEvents $socketID
  #if { [info exists connectedAgents] } {
  #  SendSystemInfoMsg sguild "Connected sensors - $connectedAgents"
  #}
}

proc SendEscalatedEvents { socketID } {
  global escalateIDList escalateArray
  if [info exists escalateIDList] {
    foreach escalateID $escalateIDList {
      catch {SendSocket $socketID "InsertEscalatedEvent $escalateArray($escalateID)"} tmpError
    }
  }
}

#
# SendCurrentEvents: Sends newly connected clients the current event list
#
proc SendCurrentEvents { socketID } {
  global eventIDArray eventIDList DEBUG clientMonitorSockets
  
  if { [info exists eventIDList] && [llength $eventIDList] > 0 } {
    foreach eventID $eventIDList {
      set sensorName [lindex $eventIDArray($eventID) 3]
      if { [info exists clientMonitorSockets($sensorName)] } {
        if { [lsearch -exact $clientMonitorSockets($sensorName) $socketID] >= 0} {
          if {$DEBUG} { puts "Sending client $socketID: InsertEvent $eventIDArray($eventID)" }
          catch {SendSocket $socketID "InsertEvent $eventIDArray($eventID)"} tmpError
        }
      }
    }
  }
}
proc CreateDB { DBNAME } {
  global dbSocketID
  puts -nonewline "The database $DBNAME does not exist. Create it (\[y\]/n)?: "
  flush stdout
  set answer [gets stdin]
  if { $answer == "" } { set answer y }
  if { ![regexp {^[yY]} $answer] } { return 0 }
  set fileName "./sql_scripts/create_sguildb.sql"
  puts -nonewline "Path to create_sguildb.sql \[$fileName\]: "
  flush stdout
  set answer [gets stdin]
  if { $answer != "" } { set fileName $answer }
  if { ! [file exists $fileName] } {
    puts "File does not exist: $fileName"
    return 0
  }
  puts -nonewline "Creating the DB $DBNAME..."
  if [ catch {mysqlexec $dbSocketID "CREATE DATABASE $DBNAME"} createDBError] {
    puts $createDBError
    return 0
  }
  mysqluse $dbSocketID $DBNAME
  puts "Okay."
  if [catch {set fileID [open $fileName r]} openFileError] {
    puts $openFileError
    return 0
  }
  puts -nonewline "Creating the structure for $DBNAME: "
  foreach line [split [read $fileID] \n] {
    puts -nonewline "."
    if { $line != "" && ![regexp {^--} $line]} {
      #puts "LINE: $line"
      if { [regexp {(^.*);\s*$} $line match data] } {
        lappend mysqlCmd $data
        #puts "CMD: [join $mysqlCmd]"
        mysqlexec $dbSocketID [join $mysqlCmd]
        set mysqlCmd ""
      } else {
        lappend mysqlCmd $line
      }
    }
  }
  close $fileID
  puts "Done."
  return 1
}
proc Daemonize {} {
  global PID_FILE DEBUG
  set DEBUG 0
  set childPID [fork]
  # Parent exits.
  if { $childPID == 0 } { exit }
  id process group set
  if {[fork]} {exit 0}
  set PID [id process]
  if { ![info exists PID_FILE] } { set PID_FILE "/var/run/sguild.pid" }
  set PID_DIR [file dirname $PID_FILE]
  if { ![file exists $PID_DIR] || ![file isdirectory $PID_DIR] || ![file writable $PID_DIR] } {
    puts "ERROR: Directory $PID_DIR does not exists or is not writable."
    puts "Process ID will not be written to file."
  } else {
    set pidFileID [open $PID_FILE w]
    puts $pidFileID $PID
    close $pidFileID
  }
  signal trap {QUIT TERM} CleanExit
}
######################## END PROCS ##############################

###################### MAIN #####################################

set validSockets ""

# Load mysql support.
if [catch {package require mysqltcl} mysqltclVersion] {
  puts "ERROR: The mysqltcl extension does NOT appear to be installed on this sysem."
  puts "Download it at http://www.xdobry.de/mysqltcl/"
  exit
}
# Load extended tcl
if [catch {package require Tclx} tclxVersion] {
  puts "ERROR: The tclx extension does NOT appear to be installed on this sysem."
  puts "Extended tcl (tclx) is available as a port/package for most linux and BSD systems."
  exit
}
# Load sha1 from tcllib
if [catch {package require sha1} sha1Version] {
  puts "ERROR: The sha1 package does NOT appear to be installed on this sysem."
  puts "The sha1 package is part of the tcllib extension. A port/package is available for most linux and BSD systems."
  exit
}
# reset the random
random seed

# GetOpts
set state flag
foreach arg $argv {
  switch -- $state {
    flag {
      switch -glob -- $arg {
        -- { set state flag }
        -h { DisplayUsage $argv0}
        -c { set state conf }
        -a { set state autocat }
        -g { set state gquery }
        -u { set state users_file }
        -D { set DAEMON_CONF_OVERRIDE 1 }
        -P { set state pid_file }
        -O { set state openssl }
        -o { set OPENSSL 1 }
        -C { set state certs }
        -adduser { set state adduser }
        -deluser { set state deluser }
        default { DisplayUsage $argv0 }
      }
    }
    conf { set CONF_FILE $arg; set state flag }
    autocat { set AUTOCAT_FILE $arg; set state flag }
    gquery { set GLOBAL_QRY_FILE $arg; set state flag }
    users_file { set USERS_FILE $arg; set state flag }
    pid_file { set PID_FILE $arg; set state flag }
    openssl { set OPENSSL 1; set TLS_PATH $arg; set state flag }
    certs { set CERTS_PATH $arg; set state flag }
    adduser { set ADDUSER 1; set userName $arg }
    deluser { set DELUSER 1; set userName $arg }
    default { DisplayUsage $argv0 }
  }
}

# Check openssl requirements if enabled
if { [info exists OPENSSL] && $OPENSSL } {
  set VERSION "$VERSION OPENSSL ENABLED"
  # Need a path to the tls libs
  if { [info exists TLS_PATH] } {
    if [catch {load $TLS_PATH} tlsError] {
      puts "ERROR: Unable to load tls libs ($TLS_PATH): $tlsError"
      DisplayUsage $argv0
    }
  }
  package require tls
  # Check for certs
  if {![info exists CERTS_PATH]} {
    set CERTS_PATH /etc/sguild/certs
  }
  if {![file exists $CERTS_PATH] || ![file isdirectory $CERTS_PATH]} {
    puts "ERROR: $CERTS_PATH does not exist or is not a directory"
    DisplayUsage $argv0
  }
  # Need sguild.key and sguild.pem
  set PEM [file join $CERTS_PATH sguild.pem]
  set KEY [file join $CERTS_PATH sguild.key]
  global KEY
  puts "KEY is $KEY"
  if {![file exists $PEM] || ![file readable $PEM] } {
    puts "ERROR: $PEM does not exist or is not readable"
    DisplayUsage $argv0
  }
  if {![file exists $KEY] || ![file readable $KEY] } {
    puts "ERROR: $KEY does not exist or is not readable"
    DisplayUsage $argv0
  }
  # If we get this far we should be good.
} else {
  set OPENSSL 0
  set VERSION "$VERSION OPENSSL DISABLED"
}

if { ![info exists CONF_FILE] } {
  # No conf file specified check the defaults
  if { [file exists /etc/sguild/sguild.conf] } {
    set CONF_FILE /etc/sguild/sguild.conf
  } elseif { [file exists ./sguild.conf] } {
    set CONF_FILE ./sguild.conf
  } else {
    puts "Couldn't determine where the sguil config file is"
    puts "Looked for ./sguild.conf and /etc/sguild/sguild.conf."
    DisplayUsage $argv0
  }
}
set i 0
if { [info exists CONF_FILE] } {
  # Parse the config file. Currently the only option is to 
  # create a variable using 'set varName value' 
  for_file line $CONF_FILE {
    incr i
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      if { [CheckLineFormat $line] } {
        if { [catch {eval $line} evalError] } {
          puts "Error at line $i in $CONF_FILE: $line"
          CleanExit
        }
      } else {
        puts "Error at line $i in $CONF_FILE: $line"
        CleanExit
      }
    }
  }
} else {
  DisplayUsage $argv0
}
# Check for a valid USERS file
if { ![info exists USERS_FILE] } {
  # No users file was specified. Go with the defaults
  if { [file exists /etc/sguild/sguild.users] } {
    set USERS_FILE "/etc/sguild/sguild.users"
  } elseif { [file exists ./sguild.users] } {
    set USERS_FILE "./sguild.users"
  } else {
    if { [info exists ADDUSER] && $ADDUSER } {
      CreateUsersFile "/etc/sguild/sguil.users"
    } else {
      puts "ERROR: Could not find a sguild.users file."
      puts "       Checked in ./ and /etc/sguild/"
      DisplayUsage $argv0
    }
  }
} else {
  if { ![file exists $USERS_FILE] } {
    if { [info exists ADDUSER] && $ADDUSER } {
      CreateUsersFile $USERS_FILE
    } else {
      puts "ERROR: $USERS_FILE does not exist"
      DisplayUsage $argv0
    }
  }
}
# Called in to add a user only
if { [info exists ADDUSER] && $ADDUSER } {
  AddUser $userName $USERS_FILE
  exit
}
# Called in to delte a user only
if { [info exists DELUSER] && $DELUSER} {
  DelUser $userName $USERS_FILE
  exit
}
# Load auto cat config
if { ![info exists AUTOCAT_FILE] } {
   if { [file exists /etc/sguild/autocat.conf] } {
     set AUTOCAT_FILE "/etc/sguild/autocat.conf"
   } else {
     set AUTOCAT_FILE "./autocat.conf"
   }
}
if { [file exists $AUTOCAT_FILE] } {
  LoadAutoCatFile $AUTOCAT_FILE
}
# Load global queries.
if { ![info exists GLOBAL_QRY_FILE] } {
  if { [file exists /etc/sguild/sguild.queries] } {
    set GLOBAL_QRY_FILE "/etc/sguild/sguild.queries"
  } else {
    set GLOBAL_QRY_FILE "./sguild.queries"
  }
}
if { [file exists $GLOBAL_QRY_FILE] } {
  LoadGlobalQueries $GLOBAL_QRY_FILE
} else {
  set GLOBAL_QRY_LIST none
}

# Deamon
if {[info exists DAEMON_CONF_OVERRIDE] && $DAEMON_CONF_OVERRIDE} { set DAEMON 1}
if {$DAEMON} { Daemonize }

# Fork a child to load PS/SSN info
set childPid [ForkLoader]
if { $childPid == 0 } { vwait LOADER }

# Fork a child to handle queries
set childPid [ForkQueryd]
if { $childPid == 0 } { vwait QUERYD }
fileevent $mainReadPipe readable [list QuerydCmdRcvd $mainReadPipe]
fconfigure $mainReadPipe -buffering line

# Get archived alerts from the DB
if { $DBPASS == "" } {
  set connectCmd "-host $DBHOST -user $DBUSER -port $DBPORT"
  #set dbSocketID [mysqlconnect -host $DBHOST -user $DBUSER -port $DBPORT]
} else {
  #set dbSocketID [mysqlconnect -host $DBHOST -user $DBUSER -port $DBPORT -password $DBPASS]
  set connectCmd "-host $DBHOST -user $DBUSER -port $DBPORT -password $DBPASS"
}
if [catch {eval mysqlconnect $connectCmd} dbSocketID] {
  puts "ERROR: Unable to connect to $DBHOST on $DBPORT: Make sure mysql is running."
  puts "$dbSocketID"
  exit
}
# See if the DB we want to use exists
if { [catch {mysqluse $dbSocketID $DBNAME} noDBError] } {
  puts "Error: $noDBError"
  # Create the DB or die.
  if {![CreateDB $DBNAME]} { exit }
}
# Make sure we have a compatible DB version
set currentDBVer [FlatDBQuery "SELECT version FROM version"]
if { $DB_VERSION != $currentDBVer } {
  puts "ERROR: Incompatable DB schema.\nRequired Version: $DB_VERSION\nInstalled Version: $currentDBVer"
  puts "Check the server/sql_scripts directory of the src that came with sguild for scripts to help you upgrade"
  exit
}

# If emailing of events is enabled, we need to make sure the libs are installed.
if { [info exists EMAIL_EVENTS] && $EMAIL_EVENTS } {
  package require mime
  package require smtp
} else {
  # Just in case the var doesn't get set in sguild.conf
  set EMAIL_EVENTS 0
}

# Set the AUTOID before we get events.
set AUTOID [GetUserID auto]

if {$DEBUG} {
  puts "Querying DB for archived events..."
  puts "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=0 ORDER BY event.timestamp ASC"
}
foreach row [mysqlsel $dbSocketID "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=0 ORDER BY event.timestamp ASC" -list] {
  if {$DEBUG} {puts "Archived Alert: $row"}
  if { ![array exists acRules] || ![AutoCat $row] } {
    AddEventToEventArray $row
    SendEvent $row
  }
}
if {$DEBUG} {
  puts "Querying DB for escalated events..."
  puts "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=2 ORDER BY event.timestamp ASC"
}
foreach row [mysqlsel $dbSocketID "SELECT event.status, event.priority, event.class, sensor.hostname, event.timestamp, event.sid, event.cid, event.signature, INET_NTOA(event.src_ip), INET_NTOA(event.dst_ip), event.ip_proto, event.src_port, event.dst_port FROM event, sensor WHERE event.sid=sensor.sid AND event.status=2 ORDER BY event.timestamp ASC" -list] {
  if {$DEBUG} {puts "Escalated Event: $row"}
  set escalatedEventID "[lindex $row 5].[lindex $row 6]"
  lappend escalateIDList $escalatedEventID
  set escalateArray($escalatedEventID) $row
}
# Get DB info (table names and column info)
if {$DEBUG} { puts "Retrieving DB info..." }
set tableNameList [mysqlinfo $dbSocketID tables]
foreach tableName $tableNameList {
  set tableArray($tableName) [mysqlcol $dbSocketID $tableName {name type length}]
}
mysqlclose $dbSocketID
set sensorQuery "SELECT hostname FROM sensor"
set sensorList [FlatDBQuery $sensorQuery]


# Open a socket for clients to connect to
if [catch {socket -server ClientConnect $SERVERPORT} serverSocket] {
  puts "ERROR: $serverSocket"
  exit
}
# Open a socket for sensors to connect to
if [catch {socket -server SensorConnect $SENSORPORT} sensorSocket] {
  puts "ERROR: $sensorSocket"
}
puts "Sguild Initialized."

signal trap {HUP} HupTrapped

# Infinate wait
vwait FOREVER

