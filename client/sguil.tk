#!/bin/sh
# Run wish from users PATH \
exec wish "$0" "$@"

# $Id: sguil.tk,v 1.149 2004/10/20 20:45:38 shalligan Exp $ #

####################################################################
# Sguil - A tcl/tk interface for network security monitoring       #
####################################################################

# Copyright (C) 2002-2004 Robert (Bamm) Visscher <bamm@satx.rr.com>
#
# This program is distributed under the terms of version 1.0 of the 
# Q Public License.  See LICENSE.QPL for further details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

########################## GLOBALS ##################################

set VERSION "SGUIL-0.5.2"

# Load extended tcl
if [catch {package require Tclx} tclxVersion] {
  puts "ERROR: The tclx extension does NOT appear to be installed on this sysem."
  puts "Extended tcl (tclx) is available as a port/package for most linux and BSD systems."
  exit
}
# Load sha1 from tcllib
if [catch {package require sha1} sha1Version] {
  puts "ERROR: The sha1 package does NOT appear to be installed on this sysem."
  puts "The sha1 package is part of the tcllib extension. A port/package is available for most linux and BSD systems."
  exit
}
# Load base64 from tcllib
if [catch {package require base64} base64Version] {
  puts "ERROR: The base64 package does NOT appear to be installed on this sysem."
  puts "The base64 package is part of the tcllib extension. A port/package is available for most linux and BSD systems."
  CleanExit
}


# Load iwidgets and namespaces
if [catch {package require Iwidgets} iwidgetsVersion] {
  puts "ERROR: Cannot fine the Iwidgets extension."
  puts "The iwidgets package is part of the incr tcl extension and is"
  puts "available as a port/package most systems."
  puts "See http://www.tcltk.com/iwidgets/ for more info."
  exit
}
namespace import -force iwidgets::panedwindow
namespace import -force iwidgets::tabnotebook
namespace import -force iwidgets::scrolledtext
namespace import -force iwidgets::optionmenu
namespace import -force iwidgets::buttonbox
namespace import -force iwidgets::entryfield
namespace import -force iwidgets::checkbox
namespace import -force iwidgets::messagedialog
namespace import -force iwidgets::scrolledlistbox
namespace import -force iwidgets::combobox
namespace import -force iwidgets::radiobox
namespace import -force iwidgets::dialogshell
namespace import -force iwidgets::disjointlistbox
namespace import -force iwidgets::timeentry
namespace import -force iwidgets::dateentry
namespace import -force iwidgets::scrolledhtml

set ACTIVE_EVENT 0
set MULTI_SELECT 0
set QUERY_NUMBER 0
set SSN_QUERY_NUMBER 0
set SSN_QUERY 0
set SANCP_QUERY_NUMBER 0
set SANCP_QUERY 0
set SLEEP 0
set SOUND 0
set FONTFILE "$env(HOME)/.sguilrc"
set USER_QRY_FILE "$env(HOME)/.sgqry"
set MotionHighIndex -1
set MotionStart -1
set MotionLowIndex -1
set MOVEMENT_DIR ""
set LASTINDEXSELECTED 1
set MONITORFLAG 0
set BUSY 0
set REPORTNUM 0
set currentSelectedPane 0 
set COUNTER 0
set SEARCHFRAME 1
######################## END GLOBALS ################################


######################## COMMUNICATION PROCS ########################

proc ServerCommandRcvd { socketID } {
  global DEBUG EMAIL_RESULTS CONNECTED GLOBAL_QRY_LIST REPORT_QRY_LIST

  if { [eof $socketID] || [catch {gets $socketID data} errorCheck] } {
    #Close the socket and exit
    catch {close $socketID} tmpError
    set CONNECTED 0
    if { [info exists errorCheck] } {
      UpdateUserName "Not Logged In" "*"
      ErrorMessage "Lost connection to sguild.\nERROR: $errorCheck\nPress Okay to try and reconnect."
    } else {
      UpdateUserName "Not Logged In" "*"
      ErrorMessage "Connection to sguild terminated. Press Okay to try and reconnect."
    }
    ReconnectToSguild
  } else {
    if {$DEBUG} {puts "Server Command Recieved: $data"}
    # store $data in $origData because ctoken changes the var it is working on.
    set origData $data
    set serverCmd [ctoken data " "]
    set data1 [string trimleft $data]
    # data1 has indices 1 on etc etc
    set index1 [ctoken data " "]
    set data2 [string trimleft $data]
   
    switch -exact -- $serverCmd {
      InsertEvent { $serverCmd $data1 }
      IncrEvent { $serverCmd $data1 }
      InsertSystemInfoMsg { $serverCmd $index1 $data2 }
      InsertRuleData { $serverCmd $data1 }
      DeleteEventID { $serverCmd $data1 }
      DeleteEventIDList { $serverCmd $data1 }
      InsertTcpHdr { $serverCmd $data1 }
      InsertIPHdr { $serverCmd $data1 }
      InsertUdpHdr { $serverCmd $data1 }
      # due to the funky ranges in InsertIcmpHeader, ctoken will not work.
      # since it is Icmp Header data, it should be predictable and not
      # subject to user input, so lrange is fine
      InsertIcmpHdr { $serverCmd [lrange $origData 1 5] [lrange $origData 6 end]}
      InsertPayloadData { $serverCmd $data1 }
      InsertQueryResults { $serverCmd $index1 $data2 }
      InfoMessage { $serverCmd $data1 }
      ErrorMessage { $serverCmd $data1 }
      PSDataResults { InsertPSData $data1 }
      InsertEscalatedEvent { $serverCmd $data1 }
      SensorList { $serverCmd $data1 }
      TableNameList { $serverCmd $data1 }
      TableColumns { $serverCmd $index1 $data2 }
      InsertHistoryResults { $serverCmd $index1 $data2 }
      InsertEmailIPHdr { set EMAIL_RESULTS $data1 }
      UserMessage { $serverCmd $index1 $data2 }
      PONG { if {$DEBUG} {puts "Comm test successful"} }
      GlobalQryList { set GLOBAL_QRY_LIST $data1 }
      ReportQryList { set REPORT_QRY_LIST $data1 }
      ReportResponse { $serverCmd $index1 $data2 }
      InsertSancpFlags { $serverCmd $index1 $data2 }
      XscriptDebugMsg { $serverCmd $index1 $data2 }
      XscriptMainMsg { $serverCmd $index1 $data2 }
      EtherealDataBase64 { $serverCmd $index1 $data2 }
      EtherealDataPcap { $serverCmd $socketID $index1 $data2 }
      default { puts "Unrecognized command from $socketID: $origData" }
    }
  } 
}
#
# Send PING/PONG every 60 secs to keep comms open thru pesky FWs.
#
proc HeartBeat {} {
  global CONNECTED
  if {$CONNECTED} { SendToSguild "PING" }
  after 60000 HeartBeat
}
proc ConnectToSguild {} {
  global SERVERHOST SERVERPORT OPENSSL VERSION TLS_PATH DEBUG CONNECTED

  if [catch {socket $SERVERHOST $SERVERPORT} socketID ] {
    return -code error "Unable to connect to $SERVERHOST on port $SERVERPORT"
  } else {
    set CONNECTED 1
    fconfigure $socketID -buffering line
    # Version checking
    if {$OPENSSL} {
      set tmpVERSION "$VERSION OPENSSL ENABLED"
    } else {
      set tmpVERSION "$VERSION OPENSSL DISABLED"
    }     
    if [catch {gets $socketID} serverVersion] {
      puts "ERROR: $serverVersion"
      return -code error "$serverVersion"
    }
    if { $serverVersion == "Connection Refused." } {
      puts $serverVersion
      return -code error $serverVersion
    } elseif { $serverVersion != $tmpVERSION } {
      return -code error "Mismatched versions.\nSERVER: ($serverVersion)\nCLIENT: ($tmpVERSION)"
    }
    puts $socketID "$tmpVERSION"
    if {$OPENSSL} {
      if { [info exists TLS_PATH] } { load $TLS_PATH }
      package require tls
      tls::import $socketID
    }
    after 1000
    if {$DEBUG} {puts "Sending PING"}
    puts $socketID "PING"
    set INIT [gets $socketID]
    if {$DEBUG} {puts "Init successful"}
    return $socketID
  }
}
proc UpdateUserName { userName userID } {
  global userNameText userIDText serverNameText SERVERHOST
  $serverNameText configure -text $SERVERHOST
  $userNameText configure -text $userName
  $userIDText configure -text $userID
}
proc ReconnectToSguild {} {
  global CONNECTED USERNAME PASSWD socketID monitorList
  if [catch {ConnectToSguild} socketID] {
    InsertSystemInfoMsg sguil.tk "${socketID}. Will try again in 60 secs."
    set CONNECTED 0
    after 60000 ReconnectToSguild
  } else {
    set CONNECTED 1
    InfoMessage "Reconnected to sguild. Press 'OK' to Reauthenticate client."
    SendToSguild "ValidateUser $USERNAME"
    set saltNonce [gets $socketID]
    set tmpSalt [lindex $saltNonce 0]
    set tmpNonce [lindex $saltNonce 1]
    set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
    set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
    puts $socketID $finalCheck
    set USERID [lindex [gets $socketID] 1]
    while { $USERID == "INVALID" } {
      set PASSWD ""
      ErrorMessage "Invalid USERNAME and/or PASSWORD"
      GetUserName 
      SendToSguild "ValidateUser $USERNAME"
      set saltNonce [gets $socketID]
      set tmpSalt [lindex $saltNonce 0]
      set tmpNonce [lindex $saltNonce 1]
      set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
      set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
      puts $socketID $finalCheck
      set USERID [lindex [gets $socketID] 1]
    } 
    set CONNECTED 1
    ClearAllEventLists
    fileevent $socketID readable [list ServerCommandRcvd $socketID]
    SendToSguild "MonitorSensors $monitorList"
    SendToSguild "SendEscalatedEvents"
    SendToSguild "SendGlobalQryList"
    UpdateUserName "$USERNAME" $USERID
    SendToSguild "SendReportQryList"
  }
}
proc ChangeSensors {} {
    global CONNECTED USERNAME PASSWD socketID monitorList
	
    ClearAllEventLists
    SendToSguild "SendSensorList"
    tkwait variable MONITORFLAG
    wm deiconify .
    update
    SendToSguild "SendEscalatedEvents"
    SendToSguild "SendGlobalQryList"
    SendToSguild "SendReportQryList"
 
}
proc SendToSguild { data } {
  global socketID CONNECTED
  if {!$CONNECTED} {
     ErrorMessage "Not connected to sguild. Unable to process this request."
  } else {
    if [catch {puts $socketID $data} errorCheck] {
      catch {close $socketID} tmpError
      if { [info exists errorCheck] } {
        UpdateUserName "Not Logged In" "*"
        ErrorMessage "Lost connection to sguild.\nERROR: $errorCheck\nPress Okay to try and reconnect."
      } else {
        UpdateUserName "Not Logged In" "*"
        ErrorMessage "Connection to sguild terminated. Press Okay to try and reconnect."
      }
      set CONNECTED 0
      ReconnectToSguild
    }
  }
}


proc SendUserMsg {} {
  global USERMSG userMsgEntry

  SendToSguild "[list UserMessage $USERMSG]"
  [$userMsgEntry component entry] delete 0 end
}

########################## PROCS ####################################



proc UserMessage { user userMsg } {
  global userMsgText messageTabs MESSAGE_TAB USER_MSG_SCROLL

  set userMsg [lindex $userMsg 0]

  if { [$messageTabs view] != 1 } {
    # BOING!
    #bell
    $messageTabs pageconfigure 1 -foreground red 
  } else {
    $messageTabs pageconfigure 1 -foreground
  }
  [$userMsgText component text] insert end "\n\[[lindex [GetCurrentTimeStamp] 1]\] <$user> $userMsg"
  if { $USER_MSG_SCROLL } { [$userMsgText component text] see end }
}

proc GetComment {} {
  global COMMENT_FLAG
  set COMMENT_FLAG 0
  if { [winfo exists .comment] } {
    destroy .comment
  }
  toplevel .comment
  wm title .comment "Add Comment To Event History"
  wm geometry .comment +[expr [winfo rootx .] + 50]+[winfo pointery .]
  entryfield .comment.e -labeltext "Add a short comment for the event:" -labelpos n -width 80
  buttonbox .comment.bb
    .comment.bb add ok -text "Okay" -command "set COMMENT_FLAG 1"
    .comment.bb add cancel -text "Cancel" -command "set COMMENT_FLAG 0"
  pack .comment.e .comment.bb -side top
  bind [.comment.e component entry] <Return> { set COMMENT_FLAG 1 }
  tkwait variable COMMENT_FLAG
  if {$COMMENT_FLAG} {
    set comment [[.comment.e component entry] get]
  } else {
    set comment ""
  } 
  destroy .comment
  return $comment
}
proc ValidateEvent { status {c_flag {0}} } {
  global ACTIVE_EVENT currentSelectedPane eventArray correlateArray socketID DEBUG
  global MULTI_SELECT CONNECTED

  if {!$CONNECTED} {
    ErrorMessage "Not Connected to sguild. Cannot validate events at this time."
    return
  }
  Working
  set eventComment none
  if {$ACTIVE_EVENT} {
    if { $status == 2 || $c_flag } {
      set eventComment [GetComment]
      if { $eventComment == "" } { InfoMessage "No comment, aborting."; return }
    }
    foreach selectedIndex\
     [lsort -integer -decreasing [$currentSelectedPane.eventIDFrame.list curselection]] {
      # Get the eventID to be deleted
      set eventID [$currentSelectedPane.eventIDFrame.list get $selectedIndex]
      # Remove the selected line from the console
      DeleteLine $currentSelectedPane $selectedIndex
      #update 
      lappend tmpDeletedEIDList $eventID
    }
    update
    if { [llength [$currentSelectedPane.eventIDFrame.list curselection]] > 1} {
      # puts "unslecting multiple events"
      UnHighLightListLine $currentSelectedPane
    } 
    set MULTI_SELECT 0
    if { [info exists selectedIndex] && $selectedIndex != "" } { 
      SelectNextEvent $currentSelectedPane $selectedIndex
    }
    if { [info exists tmpDeletedEIDList] && $tmpDeletedEIDList != "" } {
      SendToSguild "DeleteEventIDList ${status}::${eventComment}::${tmpDeletedEIDList}"
      if {$DEBUG} {
        puts "Sending Server: DeleteEventIDList ${eventComment}::${status}::${tmpDeletedEIDList}"
      }
    }
  }
  Idle
}


#
# GetCurrentTimeStamp: Returns date/time in YYYYY-MM-DD HH:MM:SS.
#
proc GetCurrentTimeStamp { {clockOption {today} } } {
  set timestamp [clock format [clock scan "$clockOption"] -gmt true -f "%Y-%m-%d %T"]
  return $timestamp
}

# System msgs are pretty bland right now. Would like to add some color tagging.
# By using the syslog facility a whole multitude of sensor status info could
# be scripted and then logged here.
proc InsertSystemInfoMsg { sensorName msg } {
  global systemInfoText messageTabs
  if { [$messageTabs view] != 0 } {
    $messageTabs pageconfigure 0 -foreground red 
  } else {
    $messageTabs pageconfigure 0 -foreground
  }
  set timestamp [GetCurrentTimeStamp]
  $systemInfoText insert end "\n\[$timestamp\] $sensorName: $msg"
  $systemInfoText component text see end
}

#
# GetPaneNameByPriority: Returns the correct RT pane based on priority.
#
proc GetPaneNameByPriority { priority } {
  global rtPaneArray RTPANES RTPANE_PRIORITY
  set paneName $rtPaneArray(0)
  if { $RTPANES > 1 } {
    set x 0
    while { $x < $RTPANES } {
      if { [lsearch -exact $RTPANE_PRIORITY($x) $priority] >= 0 } {
        eval set paneName \$rtPaneArray($x)
        break
      }
      incr x
    }
  }
  return $paneName
}
#
# GetColorByPriority: Returns color based on priority.
#
proc GetColorByPriority { priority } {
  global RTCOLORS RTCOLOR_PRIORITY RTCOLOR_NAME
  set rtColor red
  set x 0
  while { $x < $RTCOLORS } {
    if { [lsearch -exact $RTCOLOR_PRIORITY($x) $priority] >= 0 } {
      eval set rtColor $RTCOLOR_NAME($x)
      break
    }
    incr x
  }
  
  return $rtColor
}

#
# DeleteEventID: Called when server sends the DeleteEventID cmd
#                This is ugly right now. 
#
proc DeleteEventID { eventID } {
  global eventArray correlateArray rtPaneArray escalateFrame
  if { [info exists eventArray($eventID)] } { unset eventArray($eventID) }
  if { [info exists correlateArray($eventID)] } {
    foreach event $correlateArray($eventID) {
      if { [info exists eventArray($event)] } { unset eventArray($event) }
    }
  }
  foreach arrayName [array names rtPaneArray] {
    set eventIDList [$rtPaneArray($arrayName).eventIDFrame.list get 0 end]
    set eventIDIndex [lsearch -exact $eventIDList $eventID]
    if { $eventIDIndex >= 0 } { DeleteLine $rtPaneArray($arrayName) $eventIDIndex }
  }
  set escalatedIDList [$escalateFrame.eventIDFrame.list get 0 end]
  set escalatedIDIndex [lsearch -exact $escalatedIDList $eventID]
  if { $escalatedIDIndex >= 0 } { DeleteLine $escalateFrame $escalatedIDIndex }
}
proc DeleteLine { paneName index } {
  
  foreach childWin [winfo children $paneName] {
    if { [winfo name $childWin] != "scroll" } {
      $childWin.list delete $index
    }
  }
}
proc DeleteEventIDList { eventIDList } {
  foreach eventID $eventIDList {
    DeleteEventID $eventID
  }
}

#
# InsertEvent: Parses eventData, locates the correct windowPane calls DisplayEvent
#
proc InsertEvent { eventData } {
  global DEBUG rtPaneArray eventArray SLEEP SOUND
  if {$SLEEP} { WakeUp }
  set priority [lindex $eventData 1]
  set insertPane [GetPaneNameByPriority $priority]
  set eventID [join [lrange $eventData 5 6] .]
  set status RT
  set count [lindex $eventData 13]
  set sensor [lindex $eventData 3]
  set dateTime [lindex $eventData 4]
  set message [lindex $eventData 7]
  set srcIP [lindex $eventData 8]
  set dstIP [lindex $eventData 9]
  set proto [lindex $eventData 10]
  set srcPort [lindex $eventData 11]
  set dstPort [lindex $eventData 12]
  set statusColor [GetColorByPriority $priority]
  # Add event to eventArray
  set eventArray($eventID) $eventData
    DisplayEvent $insertPane $status $priority $count $sensor $dateTime $eventID $message\
     $srcIP $dstIP $proto $srcPort $dstPort $statusColor
    if {$SOUND} { Speak "Alert received from $sensor. $message" }
}
proc IncrEvent { data } {
  global ALTCOLORS
  set eid [lindex $data 0]
  set count [lindex $data 1]
  set paneName [GetPaneNameByPriority [lindex $data 2]]
  set eidMatch [lsearch -exact [$paneName.eventIDFrame.list get 0 end] $eid]
  if { $eidMatch >= 0 } {
    # Change the count value the hard way
    $paneName.countFrame.list delete $eidMatch
    $paneName.countFrame.list insert $eidMatch $count
    if {$ALTCOLORS} {
      set rowColor [lindex [$paneName.dstIPFrame.list itemconfigure $eidMatch -background] 4]
      $paneName.countFrame.list itemconfigure $eidMatch -background $rowColor
    }
    # if the list index was selected, re-select it
    if { [$paneName.eventIDFrame.list selection includes $eidMatch] } { 
      $paneName.countFrame.list selection set $eidMatch
    }
  }
  ScrollHome $paneName
}
proc GetStatusNameByNumber { status } {
  switch -exact $status {
    1  { set statusName NA }
    2  { set statusName ES }
    11 { set statusName C1 }
    12 { set statusName C2 }
    13 { set statusName C3 }
    14 { set statusName C4 }
    15 { set statusName C5 }
    16 { set statusName C6 }
    17 { set statusName C7 }
    default { set statusName UN }
  }
}
proc InsertQueryResults { paneName results } {
  # If the win doesn't exist then the user must of closed
  # the search so we just return.
  if { ![winfo exists $paneName] } { return }
  set queryType [lindex [split [winfo name $paneName] _] 0]
  if { $queryType == "ssnquery" || $queryType == "sancpquery" } {
    InsertSessionQueryResults $paneName $results
  } else {
    InsertEventQueryResults $paneName $results
  }
}
proc InsertEventQueryResults { paneName results } {
  global CATEGORY_COLOR
  set status [lindex $results 0]
  if { $status == "done" } { $paneName configure -cursor left_ptr; return }
  if { $status == "0" } {
    set status RT
    set statusColor [GetColorByPriority [lindex $results 1]]
  } else {
    set status [GetStatusNameByNumber $status]
    set statusColor $CATEGORY_COLOR($status)
  }
  set sensor [lindex $results 2]
  set dateTime [lindex $results 3]
  set eventID [join [lrange $results 4 5] .]
  set message [lindex $results 6] 
  set srcIP [lindex $results 7]
  set dstIP [lindex $results 8]
  set protocol [lindex $results 9]
  set srcPort [lindex $results 10]
  set dstPort [lindex $results 11]
  DisplayEvent $paneName $status [lindex $results 1] 1 $sensor $dateTime $eventID $message\
   $srcIP $dstIP $protocol $srcPort $dstPort $statusColor
}
proc InsertEscalatedEvent { data } {
  global CATEGORY_COLOR escalateFrame
  set status ES
  set statusColor $CATEGORY_COLOR($status)
  set sensor [lindex $data 3]
  set dateTime [lindex $data 4]
  set eventID [join [lrange $data 5 6] .]
  set message [lindex $data 7] 
  set srcIP [lindex $data 8]
  set dstIP [lindex $data 9]
  set protocol [lindex $data 10]
  set srcPort [lindex $data 11]
  set dstPort [lindex $data 12]
  DisplayEvent $escalateFrame $status [lindex $data 1] 1 $sensor $dateTime $eventID $message\
   $srcIP $dstIP $protocol $srcPort $dstPort $statusColor
}
proc InsertSessionQueryResults { paneName results } {
  global ALTCOLORS COLOR1 COLOR2 COLOR3
 
  if { $results == "done" } { $paneName configure -cursor left_ptr; return }

  if {$ALTCOLORS} {
    if { [$paneName.sensorFrame.list size] == 0 } {
      set backgroundColor $COLOR1
    } else {
      set lastBackgroundColor [lindex [$paneName.sensorFrame.list itemconfigure end -background] 4]
      if {$lastBackgroundColor == "$COLOR1"} {
        set backgroundColor "$COLOR2"
      } elseif { $lastBackgroundColor == "$COLOR2" } {
        set backgroundColor "$COLOR3"
      } else {
        set backgroundColor "$COLOR1"
      }
    }
  }

  set i 0
  foreach childWin [winfo children $paneName] {
    if { [winfo name $childWin] != "scroll" } {
      $childWin.list insert end [lindex $results $i]
      if {$ALTCOLORS} {
        # Waste resources for alternating colors this can be a hog when insert 500+ events
        $childWin.list itemconfigure end -background "$backgroundColor"
      }
      incr i
    }
  }
}

#
# DisplayEvent: inserts events into the GUI
#
proc DisplayEvent { paneName status priority count sensor dateTime eventID message srcIP\
 dstIP proto srcPort dstPort statusColor } {
  
  global ALTCOLORS COLOR1 COLOR2 COLOR3

  if {$ALTCOLORS} {
    if { [$paneName.countFrame.list size] == 0 } {
      set backgroundColor $COLOR1
    } else {
      set lastBackgroundColor [lindex [$paneName.countFrame.list itemconfigure end -background] 4]
      if {$lastBackgroundColor == "$COLOR1"} {
        set backgroundColor "$COLOR2"
      } elseif { $lastBackgroundColor == "$COLOR2" } {
        set backgroundColor "$COLOR3"
      } else {
        set backgroundColor "$COLOR1"
      }
    }
  }
  foreach childWin [winfo children $paneName] {
    set winName [winfo name $childWin]
    switch -exact  $winName {
      statusFrame   {
                      $childWin.list insert end $status
                      $childWin.list itemconfigure end -background $statusColor -selectforeground $statusColor
                     }
      priorityFrame { $childWin.list insert end $priority }
      countFrame    { $childWin.list insert end $count}
      sensorFrame   { $childWin.list insert end $sensor}
      eventIDFrame  { $childWin.list insert end $eventID}
      dateTimeFrame { $childWin.list insert end $dateTime}
      srcIPFrame    { $childWin.list insert end $srcIP}
      srcPortFrame  { $childWin.list insert end $srcPort}
      dstIPFrame    { $childWin.list insert end $dstIP}
      dstPortFrame  { $childWin.list insert end $dstPort}
      protoFrame    { $childWin.list insert end $proto}
      msgFrame      { $childWin.list insert end $message}
      default { set nadda nothing }
    }
    if {$ALTCOLORS && $winName != "statusFrame" && $winName != "scroll"} {
      # Waste resources for alternating colors this can be a hog when insert 500+ events
      $childWin.list itemconfigure end -background "$backgroundColor"
    }
  }
  ScrollHome $paneName
  
}

proc UnSelectHostLookups {} {
  global whoisNoneButton dnsButton
  $whoisNoneButton invoke
  $dnsButton deselect
  ClearDNSText
}

#
# DisplayPacketHdr: Determines the correct hdr to display (tcp/udp/icmp).
#
proc DisplayPacketHdr { paneName index } {
  global DISPLAYEDHDR tcpHdrFrame udpHdrFrame icmpHdrFrame ipHdrFrame icmpDecodeFrame
  set proto [$paneName.protoFrame.list get $index]
  if {$proto == 1} {
    set newHdr $icmpHdrFrame
  } elseif {$proto == 17} {
    set newHdr $udpHdrFrame
  } else {
    set newHdr $tcpHdrFrame
  }
  # Hide the ICMP DECODE frame if it was displayed and we don't need it anymore.
  if { $DISPLAYEDHDR == $icmpHdrFrame && $newHdr != $icmpHdrFrame } {
    pack forget $icmpDecodeFrame
  }
  if { $DISPLAYEDHDR != $newHdr } {
    pack forget $DISPLAYEDHDR
    pack $newHdr -after $ipHdrFrame -fill x
    set DISPLAYEDHDR $newHdr
  }
}


proc CleanExit {} {
  puts "Goodbye."
  exit
}

proc ClearPSLists {} {
  global portscanLabelListFrame
  foreach listName [winfo children $portscanLabelListFrame] {
    if { [winfo name $listName] != "scroll" } {
      $listName.list delete 0 end
    }
  }
}
proc DisplayPortscanData {} {
  global ACTIVE_EVENT PSINFO currentSelectedPane DEBUG socketID portscanDataFrame MULTI_SELECT
  global CONNECTED psMaxRows MAX_PS_ROWS
  ClearPSLists
  if {$ACTIVE_EVENT && $PSINFO && !$MULTI_SELECT} {
    if {!$CONNECTED} {
      ErrorMessage "Not connected to sguild. Cannot request portscan data."
      return 
    }
    $psMaxRows configure -state normal
    set selectedIndex [$currentSelectedPane.srcIPFrame.list curselection]
    set srcIP [$currentSelectedPane.srcIPFrame.list get $selectedIndex]
    set timestamp [lindex [$currentSelectedPane.dateTimeFrame.list get $selectedIndex] 0]
    SendToSguild "GetPSData $timestamp $srcIP $MAX_PS_ROWS"
    $portscanDataFrame configure -cursor watch
  } elseif { !$PSINFO } {
    $psMaxRows configure -state disabled
  }
    
}
proc InsertPSData { data } {
  global portscanDataFrame portscanLabelListFrame
  if { $data == "DONE" } { 
    $portscanDataFrame configure -cursor left_ptr
    return
  }
  set i 0
  foreach listName [winfo children $portscanLabelListFrame] {
    if { [winfo name $listName] != "scroll" } {
      $listName.list insert end [lindex $data $i]
      incr i
    }
  }
}
proc GetPacketInfo {} {
  global ACTIVE_EVENT PACKETINFO currentSelectedPane socketID DEBUG MULTI_SELECT SSN_QUERY
  global CONNECTED SANCP_QUERY
  ClearPacketData
  if {$ACTIVE_EVENT && $PACKETINFO && !$MULTI_SELECT && !$SSN_QUERY && !$SANCP_QUERY} {
    if {!$CONNECTED} {
      ErrorMessage "Not connected to sguild. Cannot make a request for packet data."
      return
    }
    Working
    update
    set selectedIndex [$currentSelectedPane.eventIDFrame.list curselection]
    set eventID [$currentSelectedPane.eventIDFrame.list get $selectedIndex]
    set protocol [$currentSelectedPane.protoFrame.list get $selectedIndex]
    set sid [lindex [split $eventID .] 0]
    set cid [lindex [split $eventID .] 1]
    SendToSguild "GetIPData $sid $cid"
    if {$protocol == 17 } {
      SendToSguild "GetUdpData $sid $cid"
    } elseif { $protocol == 1 } {
      SendToSguild "GetIcmpData $sid $cid"
    } else {
      SendToSguild "GetTcpData $sid $cid"
    }
    SendToSguild "GetPayloadData $sid $cid"
  }
}

proc MultiScrollBar { scroll_list args } {
  set len [llength $scroll_list]
  for { set i 0 } { $i < $len } {incr i} {
    set temp_list [lindex $scroll_list $i]
    eval $temp_list yview $args
  }
}

proc DisplayCorrelatedEvents { winName } {
  global ACTIVE_EVENT correlateArray eventTabs eventArray
  if {!$ACTIVE_EVENT} { return }
  set eventIndex [$winName curselection]
  set winParent [winfo parent [winfo parent $winName]]
  set eventID [$winParent.eventIDFrame.list get $eventIndex]
  if { [$winParent.countFrame.list get $eventIndex] == 1 } {
    tk_messageBox -type ok -icon warning -message\
     "$eventID has no correlated events."
    return
  }
  $eventTabs add -label "$eventID"
  regsub {\.} $eventID {_} eventIDNice
  set currentTab [$eventTabs childsite end]
  set tabIndex [$eventTabs index end]
  set correlateFrame [frame $currentTab.$eventIDNice]
  $eventTabs select end
  CreateEventLists $correlateFrame
  set buttonFrame [frame $currentTab.buttonFrame]
  set closeButton [button $buttonFrame.close -text "Close"\
	  -pady 0 -borderwidth 2 -command "DeleteTab $eventTabs $currentTab"]
  set exportButton [button $buttonFrame.export -text "Export"\
	  -pady 0 -borderwidth 2 -command "ExportResults $correlateFrame event"]
  pack $closeButton $exportButton -side left -anchor w
  pack $buttonFrame -side top -anchor w
  pack $correlateFrame -side bottom

  # Correlation/aggregation is done on the server now
  SendToSguild "GetCorrelatedEvents $eventID $correlateFrame"
}
proc DeleteTab { eventTabs tabName } {
  global ACTIVE_EVENT currentSelectedPane

  # If the currenttab had the selected index then we need to let things no that 
  # no event is active anymore
  if [regexp "^$tabName" $currentSelectedPane] { set ACTIVE_EVENT 0 }

  set tabIndex [lsearch -exact [$eventTabs childsite] $tabName]
  $eventTabs delete $tabIndex
  if {$tabIndex > 2} {
    $eventTabs prev
  } else {
    $eventTabs select 0
  }
}


proc CreateSessionLists { ssn_type baseFrame } {
  global SCROLL_HOME
  set SCROLL_HOME($baseFrame) 0
  set sensorFrame [frame $baseFrame.sensorFrame]
    set sensorLabel [label $sensorFrame.sensorLabel -text "Sensor" -background black -foreground white -anchor w]
    set sensorList [listbox $sensorFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $sensorLabel -side top -fill x
    pack $sensorList -side bottom -fill both -expand true
    BindSelectionToAllLists $sensorList
    bind $sensorLabel <Double-Button-1> {
      SortListsBy %W sessions 
    }
  set xidFrame [frame $baseFrame.xidFrame]
    if { $ssn_type == "sancp" } {
      set xidLabel [label $xidFrame.label -text "Sancp ID" -background black -foreground white -anchor w]
    } else {
      set xidLabel [label $xidFrame.label -text "Ssn ID" -background black -foreground white -anchor w]
    }
    set xidList [listbox $xidFrame.list -width 20 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $xidLabel -side top -fill x
    pack $xidList -side bottom -fill both -expand true
    BindSelectionToAllLists $xidList
    bind $xidLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $xidList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchXscriptMenu %W %Y
    }
    bind $xidList <Button-2> { GetXscript xscript 0 }
  set startTimeFrame [frame $baseFrame.startTimeFrame]
    set startTimeLabel [label $startTimeFrame.label -text "Start Time" -background black -foreground white -anchor w]
    set startTimeList [listbox $startTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $startTimeLabel -side top -fill x
    pack $startTimeList -side bottom -fill both -expand true
    BindSelectionToAllLists $startTimeList
    bind $startTimeLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set endTimeFrame [frame $baseFrame.endTimeFrame]
    set endTimeLabel [label $endTimeFrame.label -text "End Time" -background black -foreground white -anchor w]
    set endTimeList [listbox $endTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $endTimeLabel -side top -fill x
    pack $endTimeList -side bottom -fill both -expand true
    BindSelectionToAllLists $endTimeList
    bind $endTimeLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set srcIPFrame [frame $baseFrame.srcIPFrame]
    set srcIPLabel [label $srcIPFrame.srcIPLabel -text "Src IP" -background black -foreground white -anchor w]
    set srcIPList [listbox $srcIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcIPLabel -side top -fill x
    pack $srcIPList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcIPList
    bind $srcIPLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $srcIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set srcPortFrame [frame $baseFrame.srcPortFrame]
    set srcPortLabel [label $srcPortFrame.srcPortLabel -text "SPort" -background black -foreground white -anchor w]
    set srcPortList [listbox $srcPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcPortLabel -side top -fill x
    pack $srcPortList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcPortList
    bind $srcPortLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $srcPortList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set dstIPFrame [frame $baseFrame.dstIPFrame]
    set dstIPLabel [label $dstIPFrame.dstIPLabel -text "Dst IP" -background black -foreground white -anchor w]
    set dstIPList [listbox $dstIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstIPLabel -side top -fill x
    pack $dstIPList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstIPList
    bind $dstIPLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $dstIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set dstPortFrame [frame $baseFrame.dstPortFrame]
    set dstPortLabel [label $dstPortFrame.dstPortLabel -text "DPort" -background black -foreground white -anchor w]
    set dstPortList [listbox $dstPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstPortLabel -side top -fill x
    pack $dstPortList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstPortList
    bind $dstPortLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $dstPortList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set ipProtoFrame [frame $baseFrame.ipProtoFrame]
    set ipProtoLabel [label $ipProtoFrame.label -text "Pr" -background black -foreground white -anchor w]
    set ipProtoList [listbox $ipProtoFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $ipProtoLabel -side top -fill x
    pack $ipProtoList -side bottom -fill both -expand true
    BindSelectionToAllLists $ipProtoList
    bind $ipProtoLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set srcPcktsFrame [frame $baseFrame.srcPcktsFrame]
    set srcPcktsLabel [label $srcPcktsFrame.label -text "S Pckts" -background black -foreground white -anchor w]
    set srcPcktsList [listbox $srcPcktsFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcPcktsLabel -side top -fill x
    pack $srcPcktsList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcPcktsList
    bind $srcPcktsLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set srcBytesFrame [frame $baseFrame.srcBytesFrame]
    set srcBytesLabel [label $srcBytesFrame.label -text "S Bytes" -background black -foreground white -anchor w]
    set srcBytesList [listbox $srcBytesFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcBytesLabel -side top -fill x
    pack $srcBytesList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcBytesList
    bind $srcBytesLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set dstPcktsFrame [frame $baseFrame.dstPcktsFrame]
    set dstPcktsLabel [label $dstPcktsFrame.label -text "D Pckts" -background black -foreground white -anchor w]
    set dstPcktsList [listbox $dstPcktsFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstPcktsLabel -side top -fill x
    pack $dstPcktsList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstPcktsList
    bind $dstPcktsLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set dstBytesFrame [frame $baseFrame.dstBytesFrame]
    set dstBytesLabel [label $dstBytesFrame.label -text "D Bytes" -background black -foreground white -anchor w]
    set dstBytesList [listbox $dstBytesFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstBytesLabel -side top -fill x
    pack $dstBytesList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstBytesList
    bind $dstBytesLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set scroll [scrollbar $baseFrame.scroll -command "MultiScrollBar \"$sensorList $xidList $startTimeList $endTimeList\
   $srcIPList $srcPortList $dstIPList $dstPortList $ipProtoList $srcPcktsList $srcBytesList $dstPcktsList $dstBytesList\""  -width 10]
  pack $scroll -side right -fill y
  pack $sensorFrame $xidFrame $startTimeFrame $endTimeFrame $srcIPFrame $srcPortFrame $dstIPFrame $dstPortFrame\
   $ipProtoFrame $srcPcktsFrame $srcBytesFrame $dstPcktsFrame $dstBytesFrame -side left -fill both -expand true
  pack $baseFrame -fill both -expand true
}
proc CreateEventLists { baseFrame } {
  global SCROLL_HOME
  set SCROLL_HOME($baseFrame) 0
  set statusFrame [frame $baseFrame.statusFrame]
    set statusLabel [label $statusFrame.statusLabel -text "ST" -background black -foreground white -anchor w]
    set statusList [listbox $statusFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $statusLabel -side top -fill x
    pack $statusList -side bottom -fill y -expand true
    BindSelectionToAllLists $statusList
    bind $statusLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $statusList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchStatusMenu %W %Y
    }
  set priorityFrame [frame $baseFrame.priorityFrame]
    set priorityLabel [label $priorityFrame.priorityLabel -text "PR" -background black -foreground white -anchor w]
    set priorityList [listbox $priorityFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
  set countFrame [frame $baseFrame.countFrame]
    set countLabel [label $countFrame.countLabel -text "CNT" -background black -foreground white -anchor w]
    set countList [listbox $countFrame.list -width 5 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $countLabel -side top -fill x
    pack $countList -side bottom -fill y -expand true
    BindSelectionToAllLists $countList
    bind $countLabel <Double-Button-1> {
      SortListsBy %W
    }
    # Middle click on count gives all correlated events
    bind $countList <Button-2> { DisplayCorrelatedEvents %W }
  set sensorFrame [frame $baseFrame.sensorFrame]
    set sensorLabel [label $sensorFrame.sensorLabel -text "Sensor" -background black -foreground white -anchor w]
    set sensorList [listbox $sensorFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $sensorLabel -side top -fill x
    pack $sensorList -side bottom -fill y -expand true
    BindSelectionToAllLists $sensorList
    bind $sensorLabel <Double-Button-1> {
      SortListsBy %W
    }
  set eventIDFrame [frame $baseFrame.eventIDFrame]
    set eventIDLabel [label $eventIDFrame.eventIDLabel -text "sid.cid" -background black -foreground white -anchor w]
    set eventIDList [listbox $eventIDFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $eventIDLabel -side top -fill x
    pack $eventIDList -side bottom -fill y -expand true
    BindSelectionToAllLists $eventIDList
    bind $eventIDLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $eventIDList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchXscriptMenu %W %Y
    }
    bind $eventIDList <Button-2> { GetXscript xscript 0 }
  set dateTimeFrame [frame $baseFrame.dateTimeFrame]
    set dateTimeLabel [label $dateTimeFrame.dateTimeLabel -text "Date/Time" -background black -foreground white -anchor w]
    set dateTimeList [listbox $dateTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dateTimeLabel -side top -fill x
    pack $dateTimeList -side bottom -fill y -expand true
    BindSelectionToAllLists $dateTimeList
    bind $dateTimeLabel <Double-Button-1> {
      SortListsBy %W
    }
  set srcIPFrame [frame $baseFrame.srcIPFrame]
    set srcIPLabel [label $srcIPFrame.srcIPLabel -text "Src IP" -background black -foreground white -anchor w]
    set srcIPList [listbox $srcIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcIPLabel -side top -fill x
    pack $srcIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcIPList
    bind $srcIPLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $srcIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set srcPortFrame [frame $baseFrame.srcPortFrame]
    set srcPortLabel [label $srcPortFrame.srcPortLabel -text "SPort" -background black -foreground white -anchor w]
    set srcPortList [listbox $srcPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcPortLabel -side top -fill x
    pack $srcPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcPortList
    bind $srcPortLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $srcPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set dstIPFrame [frame $baseFrame.dstIPFrame]
    set dstIPLabel [label $dstIPFrame.dstIPLabel -text "Dst IP" -background black -foreground white -anchor w]
    set dstIPList [listbox $dstIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstIPLabel -side top -fill x
    pack $dstIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstIPList
    bind $dstIPLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $dstIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y      
    }
  set dstPortFrame [frame $baseFrame.dstPortFrame]
    set dstPortLabel [label $dstPortFrame.dstPortLabel -text "DPort" -background black -foreground white -anchor w]
    set dstPortList [listbox $dstPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstPortLabel -side top -fill x
    pack $dstPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstPortList
    bind $dstPortLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $dstPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set protoFrame [frame $baseFrame.protoFrame]
    set protoLabel [label $protoFrame.protoLabel -text "Pr" -background black -foreground white -anchor w]
    set protoList [listbox $protoFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $protoLabel -side top -fill x
    pack $protoList -side bottom -fill y -expand true
    BindSelectionToAllLists $protoList
    bind $protoLabel <Double-Button-1> {
      SortListsBy %W
    }
  set msgFrame [frame $baseFrame.msgFrame]
    set msgLabel [label $msgFrame.msgLabel -text "Event Message" -background black -foreground white -anchor w]
    set msgList [listbox $msgFrame.list -width 50 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $msgLabel -side top -fill x
    pack $msgList -side bottom -fill both -expand true
    BindSelectionToAllLists $msgList
    bind $msgLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $msgList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchSigQueryMenu %W %Y
    }
  set scroll [scrollbar $baseFrame.scroll -command "MultiScrollBar \"$statusList $countList $sensorList $eventIDList\
   $dateTimeList $srcIPList $srcPortList $dstIPList $dstPortList $protoList $msgList\""  -width 10]
  pack $scroll -side right -fill y

  pack $statusFrame $countFrame $sensorFrame $eventIDFrame $dateTimeFrame $srcIPFrame\
   $srcPortFrame $dstIPFrame $dstPortFrame $protoFrame -side left -fill y
  pack $msgFrame -side left -fill both -expand true
  pack $baseFrame -fill both -expand true

}
proc ClearAllEventLists {} {
  global rtPaneArray escalateFrame
  foreach arrayName [array names rtPaneArray] {
    foreach childFrame "[winfo children $rtPaneArray($arrayName)] [winfo children $escalateFrame]" {
      if { [winfo name $childFrame] != "scroll" } {
        $childFrame.list delete 0 end
      }
    }
    #set eventIDList [$rtPaneArray($arrayName).eventIDFrame.list get 0 end]
  }
}
proc SortListsBy { clickedListWinName { listType {event} } } {
  # Two words. Ug. Ly. But it works.
  # We take all the data from each list and put it into its own list. Then
  # create an array whose name is listvalue.counter where listvalue is the 
  # corresponding value in the list we are sorting on. Finally we sort the 
  # array names and put the data back into the Tab. Makes sense right?  
  global ALTCOLORS COLOR1 COLOR2 COLOR3 CATEGORY_COLOR
  set sortByName [winfo name [winfo parent $clickedListWinName]]
  set tabName [winfo parent [winfo parent $clickedListWinName] ]
  set tabChildren [winfo children $tabName]
  foreach listFullWinName $tabChildren {
    set listWinName [winfo name $listFullWinName]
    if { $listWinName != "scroll" } {
      set $listWinName [$listFullWinName.list get 0 end]
      lappend winNameList $listWinName
      $listFullWinName.list delete 0 end
    }
    $listFullWinName configure -cursor watch
  }
  update
  set totalLines [eval llength $$sortByName]
  set itemCounter 0
  while { $itemCounter < $totalLines } {
    foreach winName $winNameList {
      lappend tmpArray([eval lindex $$sortByName $itemCounter].$itemCounter)\
       "[eval lindex $$winName $itemCounter]"
    }
    incr itemCounter
  }
  set backgroundColor $COLOR1
  foreach tmpData [lsort -dictionary [array names tmpArray]] {
    set listIndex 0
    foreach winListName $winNameList {
      $tabName.$winListName.list insert end [lindex $tmpArray($tmpData) $listIndex]
      if { $listType == "event" && $listIndex == "0" } {
        if { [lindex $tmpArray($tmpData) $listIndex] != "RT" } {
          $tabName.$winListName.list itemconfigure end\
           -background $CATEGORY_COLOR([lindex $tmpArray($tmpData) $listIndex])
        } else {
          $tabName.$winListName.list itemconfigure end\
           -background [GetColorByPriority [lindex $tmpArray($tmpData) 1]]
        }
      } else {
        $tabName.$winListName.list itemconfigure end -background "$backgroundColor"
      }
      incr listIndex
    }
    if {$ALTCOLORS} {
      if {$backgroundColor == "$COLOR1"} {
        set backgroundColor "$COLOR2"
      } elseif { $backgroundColor == "$COLOR2" } {
        set backgroundColor "$COLOR3"
      } else {
        set backgroundColor "$COLOR1"
      }
    }
  }
  foreach listFullWinName $tabChildren {
    $listFullWinName configure -cursor left_ptr
  }
  update
}
proc GoToSleep {} {
  global SLEEP
  set SLEEP 1
  wm iconify .
}
proc WakeUp {} {
  global SLEEP
  set SLEEP 0
  wm deiconify .
  bell
}
proc DisplayUsage { cmdName } {
  puts "Usage: $cmdName -- -c <filename>"
  puts "  where <filename> is the PATH to the sguil config file"
  exit 1
}
proc ParseFontInfo { fontInfo } {
  set fontFamily [lindex $fontInfo 0]
  set fontSize [lindex $fontInfo 1]
  set fontWeight normal
  set fontSlant roman
  set fontUnderline 0
  set fontOverstrike 0
  if { [llength $fontInfo] == 3 } {
    set fontOptionsList [lindex $fontInfo 2]
    foreach fontOption $fontOptionsList {
      switch -exact $fontOption {
        italic		{ set fontSlant italic }
        bold		{ set fontWeight bold }
        underline 	{ set fontUnderline 1 }
        overstrike	{ set fontOverstrike 1 }
        default		{ puts "Unkonwn option: $fontOption" }
      }
    }
  }
  return "-family {$fontFamily} -size $fontSize -weight $fontWeight -underline $fontUnderline\
   -slant $fontSlant -overstrike $fontOverstrike"
}
proc GetCurrentFont { fontOptionsList } {
  set state flag
  foreach fontOption $fontOptionsList {
    switch -- $state {
      flag {
      	switch -exact -- $fontOption {
          -family 	{set state family}
          -size		{set state size}
	  -weight	{set state weight}
	  -slant	{set state slant}
	  -underline	{set state underline}
	  -overstrike	{set state overstrike}
          default	{set state unknown}
        }
      }
      family	{set family $fontOption; set state flag}
      size	{set size $fontOption; set state flag}
      weight	{lappend options $fontOption; set state flag}
      slant	{lappend options $fontOption; set state flag}
      underline { if {$fontOption} {lappend options underline}; set state flag}
      overstrike { if {$fontOption} {lappend options overstrike}; set state flag}
      unknown	{puts "Unknown flag"; set state flag}
      default	{puts "Unknown option"; set state flag}
    }
  }
  return "{$family} $size [list $options]"
}
proc ChangeFont  { fontType } {
  set newFont [dkf_chooseFont -parent . -title "Font Select" \
   -initialfont [GetCurrentFont [font configure $fontType]] ]
  GetCurrentFont [font configure $fontType]
  if { [llength $newFont] == 0 } { return }
  eval font configure $fontType [ParseFontInfo $newFont]
  SaveNewFonts
}
proc SaveNewFonts {} {
  global FONTFILE
  write_file $FONTFILE "ourStandardFont [font configure ourStandardFont]" "ourFixedFont [font configure ourFixedFont]"
}

proc GetUserName {} {
  global USERNAME PASSWD VERSION SERVERHOST SERVERPORT
  set getUserNameWin [toplevel .getUserNameWin -background white]
  wm title $getUserNameWin "$VERSION"
  set welcomeFrame [frame $getUserNameWin.welcomeFrame -borderwidth 1 -background black]
  set welcomeLabel [label $welcomeFrame.welcomeLabel -background lightblue\
   -foreground navy -text \
   "Sguil - A tcl/tk interface for network security monitoring\n\
   \n\
   Copyright (C) 2002-2004 Robert (Bamm) Visscher <bamm@satx.rr.com>\n\
   \n\
   This program is distributed under the terms of version 1.0 of the\n\
   Q Public License.  See LICENSE.QPL for further details.\n\
   \n\
   This program is distributed in the hope that it will be useful,\n\
   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."]
  pack $welcomeLabel -ipadx 5 -ipady 5
  pack $welcomeFrame -side top -padx 5 -pady 10
  set promptFrame [frame $getUserNameWin.promptFrame -background black -borderwidth 1]
    set osslSelect [checkbutton $promptFrame.osslSelect -text "Enable OpenSSL" -variable OPENSSL]
    set userLabel [label $promptFrame.userLabel -text "Please Login" -foreground navy]
    set sguildHost [entryfield $promptFrame.sguildHost -labeltext "Sguild Host: "\
     -textvariable SERVERHOST]
    set sguildPort [entryfield $promptFrame.sguildPort -labeltext "Sguild Port: "\
     -textvariable SERVERPORT]
    set userName [entryfield $promptFrame.userName -validate alphanumeric\
      -labeltext "Username:"\
      -invalid {ErrorMessage "Please use alphanumeric characters only."}\
      -textvariable USERNAME]
    set userPasswd [entryfield $promptFrame.userPasswd\
      -labeltext "Password:" -textvariable PASSWD -show *]
    iwidgets::Labeledwidget::alignlabels $sguildHost $sguildPort $userName $userPasswd
    set userBB [buttonbox $promptFrame.userBB]
      $userBB add ok -text "Ok" -command "destroy $getUserNameWin"
      $userBB add exit -text "Exit" -command "CleanExit"
    pack $userLabel $sguildHost $sguildPort $userName $userPasswd $osslSelect $userBB\
     -side top -fill both -expand true
  pack $promptFrame -side bottom -pady 5
  focus -force $userName
  bind [$userPasswd component entry] <Return> { destroy .getUserNameWin }
  tkwait window $getUserNameWin
}
proc CreateSensorCheckButton { winName sensorName userList } {
  global cbList
  set userList [lindex $userList 0]
  # tcl is picky with window names so prepend a "win" to the sensorname
  # and sub any .'s out.
  regsub -all {\.} $sensorName {_} sensor
  set cframe [frame $winName.win$sensor -background black -borderwidth 1]
  checkbutton $cframe.cb$sensor -text "$sensorName" -variable sensorSelectArray($sensorName)\
    -background lightblue -width 12
  lappend cbList $cframe.cb$sensor
  pack $cframe.cb$sensor -side top -fill x
  # make each win name unique in case a user is logged in more than once
  set i 0
  foreach user $userList {
    label $cframe.user${i}${user} -text "$user" -foreground darkred -background white
    pack $cframe.user${i}${user} -side top -fill x 
    incr i
  }
  pack $cframe -side left -padx 10 -pady 10 -anchor n
}
#
# SensorList: Rcvd a list of sensors from the server. Select which ones we 
#             want to monitor.
#
proc SensorList { sensorList } {
  global MONITORFLAG sensorSelectArray VERSION selectAllButton
  set sensorSelectWindow [toplevel .sensorSelectWindow -background white]
  wm title $sensorSelectWindow "$VERSION"
  set welcomeFrame [frame $sensorSelectWindow.welcomeFrame -borderwidth 1 -background black]
  set welcomeLabel [label $welcomeFrame.welcomeLabel -background lightblue\
   -foreground navy -text\
  "Sguil - A tcl/tk interface for network security monitoring\n\
   \n\
   Copyright (C) 2002-2004 Robert (Bamm) Visscher <bamm@satx.rr.com>\n\
   \n\
   This program is distributed under the terms of version 1.0 of the\n\
   Q Public License.  See LICENSE.QPL for further details.\n\
   \n\
   This program is distributed in the hope that it will be useful,\n\
   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."]
  pack $welcomeLabel -ipadx 5 -ipady 5
  pack $welcomeFrame -side top -padx 5 -pady 10
  if { $sensorList != "0none0" } {
    # Now a frame to contain the checkbutton frames
    set checkButtonFrame [frame $sensorSelectWindow.checkButtonFrame -borderwidth 1 -background black]
    pack $checkButtonFrame -side top -padx 5 -pady 10
    set winLabel [label $checkButtonFrame.label -text "Select Sensor(s) to Monitor"\
     -foreground navy]
    pack $winLabel -side top -fill both -expand true
    # We create a new frame for every 5 sensors to keep the look clean.
    set i 0
    set frameNumber 0
    set currentFrame [frame $checkButtonFrame.subFrame$frameNumber]
    foreach sensorNameUsers $sensorList {
      set sensorName [lindex $sensorNameUsers 0]
      if { $i < 5 } {
        CreateSensorCheckButton $currentFrame $sensorName [lrange $sensorNameUsers 1 end]
        incr i
      } else {
        pack $currentFrame -side top -fill x
        incr frameNumber
        set currentFrame [frame $checkButtonFrame.subFrame$frameNumber]
        CreateSensorCheckButton $currentFrame $sensorName [lrange $sensorNameUsers 1 end]
        set i 1
      }
  
    }
    pack $currentFrame -side top -fill x
  } else {
    label $sensorSelectWindow.noSensorLabel -background white -text\
    "There are No sensors currently in the DB to monitor.\n\
     Press <Start SGUIL> to launch the GUI anyway."
    pack $sensorSelectWindow.noSensorLabel -side top
  }
  set actionButtonFrame [frame $sensorSelectWindow.actionButtonFrame -background white]
    set selectAllButton [button $actionButtonFrame.selectAllButton -text "Select All"\
     -command "SelectAllSensors"]
    set monitorButton [button $actionButtonFrame.monitorButton -text "Start SGUIL"\
     -command "MonitorSensors $sensorSelectWindow"]
    set exitButton [button $actionButtonFrame.exitButton -text "Exit" -command "CleanExit"]
    pack $selectAllButton $monitorButton $exitButton -side left -padx 10 -pady 10
  pack $actionButtonFrame -side top
  # Don't move on until we select the sensors
  tkwait window $sensorSelectWindow
  set MONITORFLAG 1
}
proc MonitorSensors { winName } {
  global sensorSelectArray socketID DEBUG monitorList
  set monitorList ""
  foreach sensorName [array names sensorSelectArray] {
    if {$sensorSelectArray($sensorName)} { lappend monitorList $sensorName }
  }
  if { [info exists monitorList] } {
    if {$DEBUG} { puts "Sending Server: MonitorSensors $monitorList"}
    SendToSguild "MonitorSensors $monitorList"
  } else {
    InfoMessage "You did not select any sensors to monitor and will NOT recieve any events."
  }
  destroy $winName
}
proc SelectAllSensors {} {
    global cbList selectAllButton 
    # Change the SelectAllButton to a Unselect all Button
    $selectAllButton configure -text "UnSelect All" -command "UnSelectAllSensors"
    foreach cb $cbList {
	$cb select
    }
}
proc UnSelectAllSensors {} {
    global cbList selectAllButton
    # Change the SelectAllButton to a Unselect all Button
    $selectAllButton configure -text "Select All" -command "SelectAllSensors"
    foreach cb $cbList {
	$cb deselect
    }
}
#
# CheckLineFormat - Parses CONF_FILE lines to make sure they are formatted
#                   correctly (set varName value). Returns 1 if good.
#
proc CheckLineFormat { line } {
  
  set RETURN 1
  # Right now we just check the length and for "set".
  if { [llength $line] != 3 || [lindex $line 0] != "set" } { set RETURN 0 }
  return $RETURN
}
proc GetEventHistory {} {
  global ACTIVE_EVENT currentSelectedPane SSN_QUERY SANCP_QUERY socketID 
  if {!$ACTIVE_EVENT} { return }
  if {$SSN_QUERY || $SANCP_QUERY } {InfoMessage "History is available for event data only."; return}
  set winName $currentSelectedPane.eventIDFrame.list
  set index [$winName curselection]
  if { [$currentSelectedPane.statusFrame.list get $index] == "RT" } {
    InfoMessage "New (RT) events do not have a history."
    return
  }
  set eventID [$winName get $index]
  set sid [lindex [split $eventID .] 0]
  set cid [lindex [split $eventID .] 1]
  set historyWinName .eventHistoryWin_${sid}_${cid}
  if [winfo exists $historyWinName] {
    wm withdraw $historyWinName
    wm deiconify $historyWinName
    return
  }
  CreateHistoryWin $historyWinName
  SendToSguild "EventHistoryRequest $historyWinName $sid $cid"
}
proc CreateHistoryWin {winName } {
  toplevel $winName
  wm title $winName "Event History"
  wm geometry $winName +[winfo rootx .]+[winfo pointery .]
  set listsFrame [frame $winName.listsFrame -background black -borderwidth 1]
  set eidFrame [frame $listsFrame.eidFrame]
    label $eidFrame.label -text "Event ID" -background black -foreground white -anchor w
    listbox $eidFrame.list -width 10 -height 5 -relief flat -background white
    pack $eidFrame.label -side top -fill x -anchor e
    pack $eidFrame.list -side top -fill both -expand true
  set userFrame [frame $listsFrame.userFrame]
    label $userFrame.label -text "Username" -background black -foreground white -anchor w
    listbox $userFrame.list -width 15 -height 5 -relief flat -background white
    pack $userFrame.label -side top -fill x -anchor e
    pack $userFrame.list -side top -fill both -expand true
  set dateFrame [frame $listsFrame.dateFrame]
    label $dateFrame.label -text "Date/Time" -background black -foreground white -anchor w
    listbox $dateFrame.list -width 17 -height 5 -relief flat -background white
    pack $dateFrame.label -side top -fill x -anchor e
    pack $dateFrame.list -side top -fill both -expand true
  set statusFrame [frame $listsFrame.statusFrame]
    label $statusFrame.label -text "ST" -background black -foreground white -anchor w
    listbox $statusFrame.list -width 3 -height 5 -relief flat -background white
    pack $statusFrame.label -side top -fill x -anchor e
    pack $statusFrame.list -side top -fill both -expand true
  set descFrame [frame $listsFrame.descFrame]
    label $descFrame.label -text "Description" -background black -foreground white -anchor w
    listbox $descFrame.list -width 26 -height 5 -relief flat -background white
    pack $descFrame.label -side top -fill x -anchor e
    pack $descFrame.list -side top -fill both -expand true
  set commentFrame [frame $listsFrame.commentFrame]
    label $commentFrame.label -text "Comment" -background black -foreground white -anchor w
    listbox $commentFrame.list -width 50 -height 5 -relief flat -background white
    pack $commentFrame.label -side top -fill x -anchor e
    pack $commentFrame.list -side top -fill both -expand true
  pack $eidFrame $userFrame $dateFrame $statusFrame $descFrame\
   -side left -fill y
  pack $commentFrame\
   -side left -fill both -expand true

  button $winName.close -text "Close" -command "destroy $winName"
  pack $listsFrame -side top -fill both -expand true
  pack $winName.close -side top

}
proc InsertHistoryResults { winName results } {
  if { $results == "done" } { return }
  if { ![winfo exists $winName] } { CreateHistoryWin $winName }
  $winName.listsFrame.eidFrame.list insert end "[lindex $results 0].[lindex $results 1]"
  $winName.listsFrame.userFrame.list insert end [lindex $results 2]
  $winName.listsFrame.dateFrame.list insert end [lindex $results 3]
  $winName.listsFrame.statusFrame.list insert end [lindex $results 4]
  $winName.listsFrame.descFrame.list insert end [lindex $results 5]
  set comment [lindex $results 6]
  if { $comment == ""} { set comment none }
  $winName.listsFrame.commentFrame.list insert end $comment
}

proc Working {} {
  global BUSY
  . configure -cursor watch
  set BUSY 1
}
proc Idle {} {
  global BUSY
  . configure -cursor left_ptr
  set BUSY 0
}
################################ END PROCS ##################################

################################ MAIN #######################################
# Get Options
set state flag
foreach arg $argv {
  switch -- $state {
    flag {
      switch -glob -- $arg {
        -c { set state conf }
        default { DisplayUsage $argv0 }
      }
    }
    conf { set CONF_FILE $arg; set state flag }
    default { DisplayUsage $argv0 }
  }
}

if { ![info exists CONF_FILE] } {
  # No conf file specified check the defaults
  if { [file exists $env(HOME)/sguil.conf] } {
    set CONF_FILE $env(HOME)/sguil.conf
  } elseif { [file exists ./sguil.conf] } {
    set CONF_FILE ./sguil.conf
  } elseif { [file exists /etc/sguil] &&\
             [file isdirectory /etc/sguil] &&\
             [file exists /etc/sguil/sguil.conf] &&\
             [file readable /etc/sguil/sguil.conf] } {
    set CONF_FILE /etc/sguil/sguil.conf
  } else {
    puts "Couldn't determine where the sguil config file is"
    puts "Looked for $env(HOME)/sguil.conf and ./sguil.conf."
    DisplayUsage $argv0
  }
}
set i 0
if { [info exists CONF_FILE] } {
  # Parse the config file. Currently the only option is to 
  # create a variable using 'set varName value' 
  for_file line $CONF_FILE {
    incr i
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      if { [CheckLineFormat $line] } {
        if { [catch {eval $line} evalError] } {
          puts "Error at line $i in $CONF_FILE: $line"
          ErrorMessage "Error at line $i in $CONF_FILE: $line"
          CleanExit
        }
      } else {
        puts "Error at line $i in $CONF_FILE: $line"
        ErrorMessage "Error at line $i in $CONF_FILE: $line"
        CleanExit
      }
    }
  }
} else {
  DisplayUsage $argv0
}

# Load user fonts
if { [file exists $FONTFILE] } {
  for_file fontLine $FONTFILE {
    eval font create [lindex $fontLine 0] [lrange $fontLine 1 end]
  }
} else {
  font create ourStandardFont -family Helvetica -size 10 -weight bold
  font create ourFixedFont -family fixed -size 12
}
option add *Font ourStandardFont

# Source required sguillibs
source $SGUILLIB/dkffont.tcl
source $SGUILLIB/email17.tcl
source $SGUILLIB/report.tcl
source $SGUILLIB/qrylib.tcl
source $SGUILLIB/stdquery.tcl
source $SGUILLIB/qrybuild.tcl
source $SGUILLIB/sellib.tcl
source $SGUILLIB/guilib.tcl
source $SGUILLIB/extdata.tcl
source $SGUILLIB/sancp.tcl
source $SGUILLIB/sound.tcl

if { $WHOIS_PATH == "SimpleWhois" } {
  source $SGUILLIB/whois.tcl
}

############################# GUI ############################################

wm withdraw .

option add *textBackground white
option add *selectBackground $SELECTBACKGROUND
option add *selectForeground $SELECTFOREGROUND

set topFrame [frame .topFrame]
  set fileMenu [menubutton $topFrame.fileMenu -text File -underline 0 -menu $topFrame.fileMenu.menu]
  set queryMenu [menubutton $topFrame.queryMenu -text Query -underline 0 -menu $topFrame.queryMenu.menu]
  set reportMenu [menubutton $topFrame.reportMenu -text Reports -underline 0 -menu $topFrame.reportMenu.menu]
  set soundFrame [frame $topFrame.soundFrame]
    set soundLabel [label $soundFrame.label -text "  Sound:"]
    set soundStatus [label $soundFrame.status -text "Off" -foreground red] 
    pack $soundLabel $soundStatus -side left
  set serverNameFrame [frame $topFrame.serverNameFrame]
    set serverNameLabel [label $serverNameFrame.label -text "  ServerName:"]
    set serverNameText [label $serverNameFrame.snText -text "NA" -foreground red]
    pack $serverNameLabel $serverNameText -side left
  set userNameFrame [frame $topFrame.userNameFrame]
    set userNameLabel [label $userNameFrame.label -text "  UserName:"]
    set userNameText [label $userNameFrame.unText -text "Not Logged In" -foreground red] 
    pack $userNameLabel $userNameText -side left
  set userIDFrame [frame $topFrame.userIDFrame]
    set userIDLabel [label $userIDFrame.label -text "  UserID:"]
    set userIDText [label $userIDFrame.uidText -text "*" -foreground red] 
    pack $userIDLabel $userIDText -side left
  pack $fileMenu $queryMenu $reportMenu $soundFrame\
   $serverNameFrame $userNameFrame $userIDFrame -side left
  if {$GMTCLOCK } {
    set gmtClock [label $topFrame.gmtClock -text "YYYY-MM-DD HH:MM:SS GMT" -relief groove]
    pack $gmtClock -side right -anchor e -padx 5
    UpdateClock
  }
  set fileList [menu $fileMenu.menu -tearoff 0]
    $fileList add command -label "Display Incident Categories" -command DisplayIncidentCats  
    $fileList add command -label "Sleep (Ctrl-s)" -command "GoToSleep"
    $fileList add command -label "Change Sensor(s)" -command "ChangeSensors"
    $fileList add cascade -label "Change Font" -menu $fileList.font
    set fontMenu [menu $fileList.font -tearoff 0]
      $fontMenu add command -label "Standard" -command {ChangeFont ourStandardFont}
      $fontMenu add command -label "Fixed" -command {ChangeFont ourFixedFont}
    $fileList add command -label "About SGUIL" -command "AboutBox"
    $fileList add command -label "Exit" -command CleanExit
  set queryList [menu $queryMenu.menu -tearoff 0]
    $queryList add command -label "Query Event Table" -command "QueryRequest event empty"
    $queryList add command -label "Query Sessions Table" -command "QueryRequest sessions empty"
    $queryList add command -label "Query Sancp Table" -command "QueryRequest sancp empty"
    $queryList add command -label "Standard Queries" -command "StdQuery"
    $queryList add command -label "Query Builder" -command "InvokeQryBuild empty empty"
    $queryList add cascade -label "Query by Category" -menu $queryList.category
    set categoryMenu [menu $queryList.category -tearoff 0]
      $categoryMenu add command -label "Cat I: Unauthorized Root Access"\
	      -command "QueryRequest event category 11"
      $categoryMenu add command -label "Cat II: Unauthorized User Access"\
	      -command "QueryRequest event category 12"
      $categoryMenu add command -label "Cat III: Attempted Unauthorized Access"\
	      -command "QueryRequest event category 13"
      $categoryMenu add command -label "Cat IV: Successful Denial of Service Attack"\
	      -command "QueryRequest event category 14"
      $categoryMenu add command -label "Cat V: Poor Security Practice or Policy Violation"\
	      -command "QueryRequest event category 15"
      $categoryMenu add command -label "Cat VI: Reconnaissance/Probes/Scans"\
	      -command "QueryRequest event category 16"
      $categoryMenu add command -label "Cat VII: Virus Infection"\
	      -command "QueryRequest event category 17"
    $queryList add command -label "Show DataBase Tables" -command "ShowDBTables"
  set reportList [menu $reportMenu.menu -tearoff 0]
    $reportList add cascade -label "Export Events to a Text File (Detail)" -menu $reportList.textDetail
      set textDetailMenu [menu $reportList.textDetail -tearoff 0]
      $textDetailMenu add command -label "Normal" -command {TextReport 1 0}
      $textDetailMenu add command -label "Sanitized" -command {TextReport 1 1}
    $reportList add cascade -label "Export Events to a Text File (Summary)" -menu $reportList.textSummary
      set textSummaryMenu [menu $reportList.textSummary -tearoff 0]
      $textSummaryMenu add command -label "Normal" -command {TextReport 0 0}
      $textSummaryMenu add command -label "Sanitized" -command {TextReport 0 1}
    $reportList add cascade -label "Send Event Detail via email" -menu $reportList.detail
      set detailMenu [menu $reportList.detail -tearoff 0]
      $detailMenu add command -label "Normal" -command {EmailEvents 1 0}
      $detailMenu add command -label "Sanitized" -command {EmailEvents 1 1}
    $reportList add cascade -label "Send Event Summary via email" -menu $reportList.summary
      set summaryMenu [menu $reportList.summary -tearoff 0]
      $summaryMenu add command -label "Normal" -command {EmailEvents 0 0}
      $summaryMenu add command -label "Sanitized" -command {EmailEvents 0 1}
    $reportList add command -label "Sensor Reports" -command "PHBReport"
    $reportList add command -label "Import Nessus Report" -command "NessusLoad"
  #$menuList add command -label "License" -command "DisplayLicense"




pack $topFrame -side top -fill x -padx 0 -pady 0
wm title . "$VERSION - $SERVERHOST"

set eventPane [panedwindow .eventPane -width 1000 -height 700]
  $eventPane add eventLists -margin 0
  $eventPane add eventData -margin 0
pack $eventPane -fill both -expand true -padx 0 -pady 0

set eventTabs [tabnotebook [$eventPane childsite 0].eventTabs\
 -angle 0 -bevelamount 4 -tabpos n -tabbackground darkgrey]
pack $eventTabs -side left -expand true -fill both -padx 0 -pady 0

$eventTabs add -label "RealTime Events"
$eventTabs add -label "Escalated Events"
set escalateFrame [frame [$eventTabs childsite end].escalateFrame]
CreateEventLists $escalateFrame
$eventTabs select 0

set realtimeEventPanes [panedwindow [$eventTabs childsite 0].realtimeEventPanes]
set i 0
while { $i < $RTPANES } {
  $realtimeEventPanes add RealTimePane$i -margin 5
  set realtimePane$i [frame [$realtimeEventPanes childsite $i].realtimePane$i\
   -background black -borderwidth 1]
  eval set currentPane \$realtimePane$i
  set rtPaneArray($i) $currentPane
  set SCROLL_HOME($currentPane) 1
  set statusFrame [frame $currentPane.statusFrame]
    set statusLabel [label $statusFrame.statusLabel -text "ST" -background black -foreground white -anchor w -pady 0]
    set statusList [listbox $statusFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $statusLabel -side top -fill x
    pack $statusList -side bottom -fill y -expand true
    BindSelectionToAllLists $statusList
    bind $statusList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchStatusMenu %W %Y
    }
  set priorityFrame [frame $currentPane.priorityFrame]
    set priorityLabel [label $priorityFrame.priorityLabel -text "PR" -background black -foreground white -anchor w]
    set priorityList [listbox $priorityFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
  set countFrame [frame $currentPane.countFrame]
    set countLabel [label $countFrame.countLabel -text "CNT" -background black -foreground white -anchor w -pady 0]
    set countList [listbox $countFrame.list -width 5 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $countLabel -side top -fill x
    pack $countList -side bottom -fill y -expand true
    BindSelectionToAllLists $countList
    bind $countList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchCorrelateMenu %W %Y
    }
    # Middle click on count gives all correlated events
    bind $countList <Button-2> { DisplayCorrelatedEvents %W }
  set sensorFrame [frame $currentPane.sensorFrame]
    set sensorLabel [label $sensorFrame.sensorLabel -text "Sensor" -background black -foreground white -anchor w -pady 0]
    set sensorList [listbox $sensorFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $sensorLabel -side top -fill x
    pack $sensorList -side bottom -fill y -expand true
    BindSelectionToAllLists $sensorList
  set eventIDFrame [frame $currentPane.eventIDFrame]
    set eventIDLabel [label $eventIDFrame.eventIDLabel -text "sid.cid" -background black -foreground white -anchor w -pady 0]
    set eventIDList [listbox $eventIDFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $eventIDLabel -side top -fill x
    pack $eventIDList -side bottom -fill y -expand true
    BindSelectionToAllLists $eventIDList
    bind $eventIDList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchXscriptMenu %W %Y
    }
    bind $eventIDList <Button-2> { GetXscript xscript 0 }
  set dateTimeFrame [frame $currentPane.dateTimeFrame]
    set dateTimeLabel [label $dateTimeFrame.dateTimeLabel -text "Date/Time" -background black -foreground white -anchor w -pady 0]
    set dateTimeList [listbox $dateTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $dateTimeLabel -side top -fill x
    pack $dateTimeList -side bottom -fill y -expand true
    BindSelectionToAllLists $dateTimeList
  set srcIPFrame [frame $currentPane.srcIPFrame]
    set srcIPLabel [label $srcIPFrame.srcIPLabel -text "Src IP" -background black -foreground white -anchor w -pady 0]
    set srcIPList [listbox $srcIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $srcIPLabel -side top -fill x
    pack $srcIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcIPList
    bind $srcIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set srcPortFrame [frame $currentPane.srcPortFrame]
    set srcPortLabel [label $srcPortFrame.srcPortLabel -text "SPort" -background black -foreground white -anchor w -pady 0]
    set srcPortList [listbox $srcPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $srcPortLabel -side top -fill x
    pack $srcPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcPortList
    bind $srcPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set dstIPFrame [frame $currentPane.dstIPFrame]
    set dstIPLabel [label $dstIPFrame.dstIPLabel -text "Dst IP" -background black -foreground white -anchor w -pady 0]
    set dstIPList [listbox $dstIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $dstIPLabel -side top -fill x
    pack $dstIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstIPList
    bind $dstIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set dstPortFrame [frame $currentPane.dstPortFrame]
    set dstPortLabel [label $dstPortFrame.dstPortLabel -text "DPort" -background black -foreground white -anchor w -pady 0]
    set dstPortList [listbox $dstPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $dstPortLabel -side top -fill x
    pack $dstPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstPortList
    bind $dstPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set protoFrame [frame $currentPane.protoFrame]
    set protoLabel [label $protoFrame.protoLabel -text "Pr" -background black -foreground white -anchor w -pady 0]
    set protoList [listbox $protoFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $protoLabel -side top -fill x
    pack $protoList -side bottom -fill y -expand true
    BindSelectionToAllLists $protoList
  set msgFrame [frame $currentPane.msgFrame]
    set msgLabel [label $msgFrame.msgLabel -text "Event Message" -background black -foreground white -anchor w -pady 0]
    set msgList [listbox $msgFrame.list -width 50 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $msgLabel -side top -fill x
    pack $msgList -side bottom -fill both -expand true
    BindSelectionToAllLists $msgList
    bind $msgList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchSigQueryMenu %W %Y
    }
  set scroll [scrollbar $currentPane.scroll -command "MultiScrollBar \"$statusList $countList $sensorList $eventIDList\
   $dateTimeList $srcIPList $srcPortList $dstIPList $dstPortList $protoList $msgList\""  -width 10]
  pack $scroll -side right -fill y
  # When scrollbar is pressed we turn of autoscrolling until we can check its position.
  bind $scroll <Button-1> {
    set SCROLL_HOME([winfo parent %W]) 0
  }
  # When scrollbar is released we check its position. If its
  # at the bottom then we enable autoscrolling
  bind $scroll <ButtonRelease-1> {
    set scrollbarPosition [lindex [%W get] 1]
    if {$scrollbarPosition == 1.0} {set SCROLL_HOME([winfo parent %W]) 1}
  }
  
  pack $statusFrame $countFrame $sensorFrame $eventIDFrame $dateTimeFrame $srcIPFrame\
   $srcPortFrame $dstIPFrame $dstPortFrame $protoFrame -side left -fill y
  pack $msgFrame -side left -fill both -expand true
  pack $currentPane -fill both -expand true
  incr i
}
pack $realtimeEventPanes -fill both -expand true -padx 0 -pady 0

set detailPane [panedwindow [$eventPane childsite 1].detailPane -orient vertical]
$detailPane add ipdata -margin 0
$detailPane add packetData -margin 7
pack $detailPane -expand true -fill both -padx 0 -pady 0

set ipDataPane [panedwindow [$detailPane childsite 0].ipDataPane]
$ipDataPane add resolvers -margin 5
$ipDataPane add systeminfo -margin 5
pack $ipDataPane -expand true -fill both
set ipDataFrame [frame [$ipDataPane childsite 0].ipDataFrame]
  set dnsDataFrame [frame $ipDataFrame.dnsDataFrame]
    set srcDnsDataFrame [frame $dnsDataFrame.srcDnsDataFrame -borderwidth 1 -background black]
      set srcDnsDataLabelFrame [frame $srcDnsDataFrame.srcDnsDataLabelFrame]
        label $srcDnsDataLabelFrame.ipLabel -text "Src IP:" -anchor w -width 9 -background lightblue
        label $srcDnsDataLabelFrame.nameLabel -text "Src Name:" -anchor w -width 9 -background lightblue
        pack $srcDnsDataLabelFrame.ipLabel $srcDnsDataLabelFrame.nameLabel -side top -fill y
      set srcDnsDataEntryTextFrame [frame $srcDnsDataFrame.srcDnsDataTextFrame]
        text $srcDnsDataEntryTextFrame.ipText -height 1 -width 20 -background white
        text $srcDnsDataEntryTextFrame.nameText -height 1 -width 20 -background white
        pack $srcDnsDataEntryTextFrame.ipText $srcDnsDataEntryTextFrame.nameText -side top -fill x -expand true
      pack $srcDnsDataLabelFrame -side left -fill y
      pack $srcDnsDataEntryTextFrame -side right -fill x -expand true
    set dstDnsDataFrame [frame $dnsDataFrame.dstDnsDataFrame -borderwidth 1 -background black]
      set dstDnsDataLabelFrame [frame $dstDnsDataFrame.dstDnsDataLabelFrame]
        label $dstDnsDataLabelFrame.ipLabel -text "Dst IP:" -anchor w -width 9 -background lightblue
        label $dstDnsDataLabelFrame.nameLabel -text "Dst Name:" -anchor w -width 9 -background lightblue
        pack $dstDnsDataLabelFrame.ipLabel $dstDnsDataLabelFrame.nameLabel -side top -fill y
      set dstDnsDataEntryTextFrame [frame $dstDnsDataFrame.dstDnsDataTextFrame]
        text $dstDnsDataEntryTextFrame.ipText -height 1 -width 20 -background white
        text $dstDnsDataEntryTextFrame.nameText -height 1 -width 20 -background white
        pack $dstDnsDataEntryTextFrame.ipText $dstDnsDataEntryTextFrame.nameText -side top -fill x -expand true
      pack $dstDnsDataLabelFrame -side left
      pack $dstDnsDataEntryTextFrame -side left -fill x -expand true
    pack $srcDnsDataFrame $dstDnsDataFrame -side top -fill x -expand true
  set whoisDataFrame [frame $ipDataFrame.whoisDataFrame]
    set whoisDataButtonsFrame [frame $whoisDataFrame.whoisDataButtonsFrame]
      set dnsButton [checkbutton $whoisDataButtonsFrame.dnsButton -text "Reverse DNS" -variable REVERSE_DNS\
       -command ResolveHosts -foreground navy -anchor w]
      set whoisLabel [label $whoisDataButtonsFrame.whoisLabel -text "Whois Query:" -foreground navy]
      set whoisNoneButton [radiobutton $whoisDataButtonsFrame.whoisNoneButton -variable WHOISLIST -value none\
       -text "None" -command ClearWhoisData]
      set whoisSrcButton [radiobutton $whoisDataButtonsFrame.whoisSrcButton -variable WHOISLIST -value srcIPFrame\
       -text "Src IP" -command GetWhoisData]
      set whoisDstButton [radiobutton $whoisDataButtonsFrame.whoisDstButton -variable WHOISLIST -value dstIPFrame\
       -text "Dst IP" -command GetWhoisData]
      pack $dnsButton -side left -anchor e
      pack $whoisDstButton $whoisSrcButton $whoisNoneButton $whoisLabel -side right -anchor w
    set whoisDataTextFrame [frame $whoisDataFrame.whoisDataTextFrame]
      set whoisText [text $whoisDataTextFrame.whoisText -width 20 -height 8\
       -yscrollcommand "$whoisDataTextFrame.whoisScroll set" -background white]
      set whoisScroll [scrollbar $whoisDataTextFrame.whoisScroll -command "$whoisText yview" -width 10]
      pack $whoisScroll -side right -fill y
      pack $whoisText -side left -fill both -expand true
    pack $whoisDataButtonsFrame -side top -fill x
    pack $whoisDataTextFrame -side bottom -fill both -expand true
  pack $dnsDataFrame -side top -fill x
  pack $whoisDataFrame -side bottom -fill both -expand true
pack $ipDataFrame -fill both -expand true -padx 0 -pady 0
$whoisNoneButton invoke

set messageTabs [tabnotebook [$ipDataPane childsite 1].messageTabs\
 -angle 0 -bevelamount 4 -tabpos n -tabbackground darkgrey]
pack $messageTabs -side left -expand true -fill both -padx 0 -pady 0
$messageTabs add -label "System Messages"\
 -command "$messageTabs pageconfigure 0 -foreground black"
$messageTabs add -label "User Messages"\
 -command "$messageTabs pageconfigure 1 -foreground black"
set systemInfoFrame [frame [$messageTabs childsite 0].systemInfoFrame]
set systemInfoText [scrolledtext $systemInfoFrame.systemInfoText -vscrollmode static -hscrollmode dynamic\
 -wrap word -visibleitems 20x4 -sbwidth 10]
pack $systemInfoText -side top -fill both -expand true
pack $systemInfoFrame -fill both -expand true
set userMsgsFrame [frame [$messageTabs childsite 1].userMsgsFrame]
  set userMsgText [scrolledtext $userMsgsFrame.userMsgText -vscrollmode static -hscrollmode dynamic\
   -wrap word -visibleitems 20x3 -sbwidth 10]
  set userMsgEntry [entryfield $userMsgsFrame.userMsgEntry -textvariable USERMSG\
   -labeltext "MSG: " -labelpos w -width 20]
  pack $userMsgText -side top -fill both -expand true
  pack $userMsgEntry -side top -fill x
  bind [$userMsgEntry component entry] <Return> { SendUserMsg }
pack $userMsgsFrame -side top -fill both -expand true
$messageTabs select 0
bind [$userMsgText component vertsb] <ButtonRelease-1> {
  set scrollbarPosition [lindex [%W get] 1]
  if {$scrollbarPosition == 1.0} {set USER_MSG_SCROLL 1} else { set USER_MSG_SCROLL 0 }
}
set USER_MSG_SCROLL 1


set detailDataFrame [frame [$detailPane childsite 1].packetDataFrame]
    #
    # Portscan Detail
    #
    set portscanDataFrame [frame $detailDataFrame.portscanFrame]
      set psOptionsFrame [frame $portscanDataFrame.psOptionsFrame]
        set displayPSButton [checkbutton $psOptionsFrame.displayPSButton -variable PSINFO\
         -command DisplayPortscanData -text "Display Portscan Data"]
        set psMaxRows [entryfield $psOptionsFrame.psMaxRows -labeltext "Max Rows"\
         -labelpos e -width 5 -textvariable MAX_PS_ROWS -state disabled]
        bind [$psMaxRows component entry] <Return> { DisplayPortscanData }
        if { [info exists MAX_PS_ROWS] && $MAX_PS_ROWS == "" } { set MAX_PS_ROWS 200 }
        pack $displayPSButton $psMaxRows -side left -padx 10
      set portscanLabelListFrame [frame $portscanDataFrame.portscanLabelListFrame]
        set psSensorFrame [frame $portscanLabelListFrame.psSensorFrame]
          set psSensorLabel [label $psSensorFrame.label -text Sensor -background black -foreground white]
          set psSensorList [listbox $psSensorFrame.list -width 10 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psSensorLabel -side top -fill x
          pack $psSensorList -side bottom -fill both -expand true
	  BindSelectionToAllPSLists $psSensorList
        set psDateTimeFrame [frame $portscanLabelListFrame.psDateTimeFrame]
          set psDateTimeLabel [label $psDateTimeFrame.label -text TimeStamp -background black\
           -foreground white]
          set psDateTimeList [listbox $psDateTimeFrame.list -width 18 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDateTimeLabel -side top -fill x
          pack $psDateTimeList -side bottom -fill both -expand true
           BindSelectionToAllPSLists $psDateTimeList
        set psSrcIPFrame [frame $portscanLabelListFrame.psSrcIPFrame]
          set psSrcIPLabel [label $psSrcIPFrame.label -text SrcIP -background black -foreground white]
          set psSrcIPList [listbox $psSrcIPFrame.list -width 15 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psSrcIPLabel -side top -fill x
          pack $psSrcIPList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psSrcIPList
        set psSrcPortFrame [frame $portscanLabelListFrame.psSrcPortFrame]
          set psSrcPortLabel [label $psSrcPortFrame.label -text SrcPort -background black\
           -foreground white]
          set psSrcPortList [listbox $psSrcPortFrame.list -width 6 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psSrcPortLabel -side top -fill x
          pack $psSrcPortList -side bottom -fill both -expand true
	 BindSelectionToAllPSLists $srcPortList  
        set psDstIPFrame [frame $portscanLabelListFrame.psDstIPFrame]
          set psDstIPLabel [label $psDstIPFrame.label -text DstIP -background black -foreground white]
          set psDstIPList [listbox $psDstIPFrame.list -width 15 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDstIPLabel -side top -fill x
          pack $psDstIPList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psDstIPList
        set psDstPortFrame [frame $portscanLabelListFrame.psDstPortFrame]
          set psDstPortLabel [label $psDstPortFrame.label -text DstPort -background black\
           -foreground white]
          set psDstPortList [listbox $psDstPortFrame.list -width 6 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDstPortLabel -side top -fill x
          pack $psDstPortList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psDstPortList
        set psDataFrame [frame $portscanLabelListFrame.psDataFrame]
          set psDataLabel [label $psDataFrame.label -text "Scan Info" -background black\
           -foreground white]
          set psDataList [listbox $psDataFrame.list -width 15 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDataLabel -side top -fill x
          pack $psDataList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psDataList
        set psScroll [scrollbar $portscanLabelListFrame.scroll -command "MultiScrollBar \"$psSensorList\
         $psDateTimeList $psSrcIPList $psSrcPortList $psDstIPList $psDstPortList $psDataList\""\
         -width 10]
        pack $psScroll -side right -fill y
        pack $psSensorFrame $psDateTimeFrame $psSrcIPFrame $psSrcPortFrame $psDstIPFrame\
         $psDstPortFrame $psDataFrame -side left -fill both -expand true
      pack $psOptionsFrame -side top
      pack $portscanLabelListFrame -side bottom -fill both -expand true

    #
    # Sancp Data
    #
    set sancpFrame [frame $detailDataFrame.sancpFrame]
      set sancpSelect [checkbutton $sancpFrame.cbutton \
       -text "Display Sancp Details" -variable SANCPINFO -command GetSancpData]
      pack $sancpSelect -side top -fill x
      set sancpFlagsFrame [frame $sancpFrame.sancpFlagsFrame]
      set sancpSrcFlagsFrame [frame $sancpFlagsFrame.srcFlagsFrame -background black -borderwidth 1]
        set srcSancpLabel [label $sancpSrcFlagsFrame.srcLabel\
         -text "Source\nFlags\nSummary" -width 8\
         -foreground white -background deepskyblue]
        set r2SrcSancpFrame [frame $sancpSrcFlagsFrame.r1]
          LabelText $r2SrcSancpFrame 1 "R\n2" 3
        set r1SrcSancpFrame [frame $sancpSrcFlagsFrame.r0]
          LabelText $r1SrcSancpFrame 1 "R\n1" 3
        set urgSrcSancpFrame [frame $sancpSrcFlagsFrame.urg]
          LabelText $urgSrcSancpFrame 1 "U\nR\nG" 3
        set ackSrcSancpFrame [frame $sancpSrcFlagsFrame.ack]
          LabelText $ackSrcSancpFrame 1 "A\nC\nK" 3
        set pshSrcSancpFrame [frame $sancpSrcFlagsFrame.psh]
          LabelText $pshSrcSancpFrame 1 "P\nS\nH" 3
        set rstSrcSancpFrame [frame $sancpSrcFlagsFrame.rst]
          LabelText $rstSrcSancpFrame 1 "R\nS\nT" 3
        set synSrcSancpFrame [frame $sancpSrcFlagsFrame.syn]
          LabelText $synSrcSancpFrame 1 "S\nY\nN" 3
        set finSrcSancpFrame [frame $sancpSrcFlagsFrame.fin]
          LabelText $finSrcSancpFrame 1 "F\nI\nN" 3
      pack $srcSancpLabel -side left -anchor w -fill y
      pack $r2SrcSancpFrame $r1SrcSancpFrame $urgSrcSancpFrame $ackSrcSancpFrame $pshSrcSancpFrame\
       $rstSrcSancpFrame $synSrcSancpFrame $finSrcSancpFrame -side left -anchor w -fill x -expand true
      set sancpDstFlagsFrame [frame $sancpFlagsFrame.dstFlagsFrame -background black -borderwidth 1]
        set dstSancpLabel [label $sancpDstFlagsFrame.srcLabel\
         -text "Dest\nFlags\nSummary" -width 8\
         -foreground white -background blue]
        set r2dstSancpFrame [frame $sancpDstFlagsFrame.r1]
          LabelText $r2dstSancpFrame 1 "R\n2" 3
        set r1dstSancpFrame [frame $sancpDstFlagsFrame.r0]
          LabelText $r1dstSancpFrame 1 "R\n1" 3
        set urgdstSancpFrame [frame $sancpDstFlagsFrame.urg]
          LabelText $urgdstSancpFrame 1 "U\nR\nG" 3
        set ackdstSancpFrame [frame $sancpDstFlagsFrame.ack]
          LabelText $ackdstSancpFrame 1 "A\nC\nK" 3
        set pshdstSancpFrame [frame $sancpDstFlagsFrame.psh]
          LabelText $pshdstSancpFrame 1 "P\nS\nH" 3
        set rstdstSancpFrame [frame $sancpDstFlagsFrame.rst]
          LabelText $rstdstSancpFrame 1 "R\nS\nT" 3
        set syndstSancpFrame [frame $sancpDstFlagsFrame.syn]
          LabelText $syndstSancpFrame 1 "S\nY\nN" 3
        set findstSancpFrame [frame $sancpDstFlagsFrame.fin]
          LabelText $findstSancpFrame 1 "F\nI\nN" 3
      pack $dstSancpLabel -side left -anchor w -fill y
      pack $r2dstSancpFrame $r1dstSancpFrame $urgdstSancpFrame $ackdstSancpFrame $pshdstSancpFrame\
       $rstdstSancpFrame $syndstSancpFrame $findstSancpFrame -side left -anchor w -fill x -expand true
      pack $sancpSrcFlagsFrame $sancpDstFlagsFrame -side left -padx 10 -fill x
      set sancpTxtInfo [label $sancpFrame.label\
       -foreground navy -background skyblue -justify left -wraplength 400\
       -padx 10  -borderwidth 5 -text\
       "NOTE: Sancp summarizes data across a session. If any packet within\
        a session contains one of the above flags, then it will be logged\
        as so. The above does NOT mean each flag was seen in ONE packet."]
      pack $sancpFlagsFrame $sancpTxtInfo -side top -pady 10
      
    #
    # Event/Packet Detail
    #
    set packetDataFrame [frame $detailDataFrame.packetDataFrame]
    set ruleButtonFrame [frame $packetDataFrame.ruleButtonFrame]
      set displayPacketButton [checkbutton $ruleButtonFrame.displayPacketButton\
       -text "Show Packet Data" -variable PACKETINFO -command GetPacketInfo]
      set displayRuleButton [checkbutton $ruleButtonFrame.displayRuleButton\
       -text "Show Rule" -variable SHOWRULE -command GetRuleInfo]
        set referenceButton [button $ruleButtonFrame.referenceButton\
         -text "www.snort.org" -command "GetReference" -state disabled]
        set icatButton [button $ruleButtonFrame.icatButton\
         -text "icat.nist.gov" -command "GetIcat" -state disabled]
      pack $displayPacketButton $displayRuleButton $referenceButton $icatButton -side left
    set ruleText [scrolledtext $packetDataFrame.ruleText -hscrollmode static -visibleitems 10x1\
     -sbwidth 10 -vscrollmode none -wrap none]
    set packetFrame [frame $packetDataFrame.packetFrame -background black -borderwidth 1]
    ################ IP HEADER #############################
    set ipHdrFrame [frame $packetFrame.ipHdrFrame -background black -borderwidth 1]
      set ipHdrLabel [label $ipHdrFrame.ipHdrLabel -text IP -width 8 -foreground white -background deepskyblue]
      set srcIPHdrFrame [frame $ipHdrFrame.srcIPHdrFrame]
        LabelText $srcIPHdrFrame 15 "Source IP"
      set dstIPHdrFrame [frame $ipHdrFrame.dstIPHdrFrame]
        LabelText $dstIPHdrFrame 15 "Dest IP"
      set verIPHdrFrame [frame $ipHdrFrame.verIPHdrFrame]
        LabelText $verIPHdrFrame 2 "Ver"
      set hdrLenIPHdrFrame [frame $ipHdrFrame.hdrLenIPHdrFrame]
        LabelText $hdrLenIPHdrFrame 3 "HL"
      set tosIPHdrFrame [frame $ipHdrFrame.tosIPHdrFrame]
        LabelText $tosIPHdrFrame 3 "TOS"
      set lenIPHdrFrame [frame $ipHdrFrame.lenIPHdrFrame]
        LabelText $lenIPHdrFrame 5 "len"
      set idIPHdrFrame [frame $ipHdrFrame.idIPHdrFrame]
        LabelText $idIPHdrFrame 5 "ID"
      set flagsIPHdrFrame [frame $ipHdrFrame.flagsIPHdrFrame]
        LabelText $flagsIPHdrFrame 4 "Flags"
      set offsetIPHdrFrame [frame $ipHdrFrame.offsetIPHdrFrame]
        LabelText $offsetIPHdrFrame 5 "Offset"
      set ttlIPHdrFrame [frame $ipHdrFrame.ttlIPHdrFrame]
        LabelText $ttlIPHdrFrame 4 "TTL"
      set chksumIPHdrFrame [frame $ipHdrFrame.chksumIPHdrFrame]
        LabelText $chksumIPHdrFrame 6 "ChkSum"
      pack $ipHdrLabel -side left -anchor w -fill y
      pack $srcIPHdrFrame $dstIPHdrFrame $verIPHdrFrame $hdrLenIPHdrFrame $tosIPHdrFrame $lenIPHdrFrame\
       $idIPHdrFrame $flagsIPHdrFrame $offsetIPHdrFrame $ttlIPHdrFrame $chksumIPHdrFrame\
       -side left -anchor w -fill x -expand true
    ##################### TCP HEADER ###########################
    set tcpHdrFrame [frame $packetFrame.tcpHdrFrame -background black -borderwidth 1]
      set tcpHdrLabel [label $tcpHdrFrame.tcpHdrLabel -text TCP -width 8 -foreground white -background blue]
      set sPortTcpHdrFrame [frame $tcpHdrFrame.sPortTcpHdrFrame]
        LabelText $sPortTcpHdrFrame 5 "Source\nPort" 3
      set dPortTcpHdrFrame [frame $tcpHdrFrame.dPortTcpHdrFrame]
        LabelText $dPortTcpHdrFrame 5 "Dest\nPort" 3
      set r1TcpHdrFrame [frame $tcpHdrFrame.r1TcpHdrFrame]
        LabelText $r1TcpHdrFrame 1 "R\n1" 3
      set r0TcpHdrFrame [frame $tcpHdrFrame.r0TcpHdrFrame]
        LabelText $r0TcpHdrFrame 1 "R\n0" 3
      set urgTcpHdrFrame [frame $tcpHdrFrame.urgTcpHdrFrame]
        LabelText $urgTcpHdrFrame 1 "U\nR\nG" 3
      set ackTcpHdrFrame [frame $tcpHdrFrame.ackTcpHdrFrame]
        LabelText $ackTcpHdrFrame 1 "A\nC\nK" 3
      set pshTcpHdrFrame [frame $tcpHdrFrame.pshTcpHdrFrame]
        LabelText $pshTcpHdrFrame 1 "P\nS\nH" 3
      set rstTcpHdrFrame [frame $tcpHdrFrame.rstTcpHdrFrame]
        LabelText $rstTcpHdrFrame 1 "R\nS\nT" 3
      set synTcpHdrFrame [frame $tcpHdrFrame.synTcpHdrFrame]
        LabelText $synTcpHdrFrame 1 "S\nY\nN" 3
      set finTcpHdrFrame [frame $tcpHdrFrame.finTcpHdrFrame]
        LabelText $finTcpHdrFrame 1 "F\nI\nN" 3
      set seqTcpHdrFrame [frame $tcpHdrFrame.seqTcpHdrFrame]
        LabelText $seqTcpHdrFrame 10 "Seq #" 3
      set acknoTcpHdrFrame [frame $tcpHdrFrame.acknoTcpHdrFrame]
        LabelText $acknoTcpHdrFrame 10 "Ack #" 3
      set tcpoffsetTcpHdrFrame [frame $tcpHdrFrame.tcpoffsetTcpHdrFrame]
        LabelText $tcpoffsetTcpHdrFrame 5 "Offset" 3
      set resTcpHdrFrame [frame $tcpHdrFrame.resTcpHdrFrame]
        LabelText $resTcpHdrFrame 3 "Res" 3
      set windowTcpHdrFrame [frame $tcpHdrFrame.windowTcpHdrFrame]
        LabelText $windowTcpHdrFrame 6 "Window" 3
      set urpTcpHdrFrame [frame $tcpHdrFrame.urpTcpHdrFrame]
        LabelText $urpTcpHdrFrame 3 "Urp" 3
      set tcpchksumTcpHdrFrame [frame $tcpHdrFrame.tcpchksumTcpHdrFrame]
        LabelText $tcpchksumTcpHdrFrame 6 "ChkSum" 3
      pack $tcpHdrLabel -side left -anchor w -fill y
      pack $sPortTcpHdrFrame $dPortTcpHdrFrame $r1TcpHdrFrame $r0TcpHdrFrame $urgTcpHdrFrame\
       $ackTcpHdrFrame $pshTcpHdrFrame $rstTcpHdrFrame $synTcpHdrFrame $finTcpHdrFrame\
       $seqTcpHdrFrame $acknoTcpHdrFrame $tcpoffsetTcpHdrFrame $resTcpHdrFrame $windowTcpHdrFrame\
       $urpTcpHdrFrame $tcpchksumTcpHdrFrame -side left -anchor w -fill x -expand true
    ##################### UDP HEADER ###########################
    set udpHdrFrame [frame $packetFrame.udpHdrFrame -background black -borderwidth 1]
      set udpHdrLabel [label $udpHdrFrame.udpHdrLabel -text UDP -width 8 -foreground white -background blue]
      set sPortUdpHdrFrame [frame $udpHdrFrame.sPortUdpHdrFrame]
        LabelText $sPortUdpHdrFrame 5 "Source\nPort"
      set dPortUdpHdrFrame [frame $udpHdrFrame.dPortUdpHdrFrame]
       LabelText $dPortUdpHdrFrame 5 "Dest\nPort"
      set udplenUdpHdrFrame [frame $udpHdrFrame.udplenUdpHdrFrame]
        LabelText $udplenUdpHdrFrame 6 "Length"
      set udpchksumUdpHdrFrame [frame $udpHdrFrame.udpchksumUdpHdrFrame]
       LabelText $udpchksumUdpHdrFrame 6 "ChkSum"
      pack $udpHdrLabel -side left -anchor w -fill y
      pack $sPortUdpHdrFrame $dPortUdpHdrFrame $udplenUdpHdrFrame $udpchksumUdpHdrFrame\
       -side left -anchor w -fill x -expand true
    ##################### ICMP HEADER ###########################
    set icmpHdrFrame [frame $packetFrame.icmpHdrFrame -background black -borderwidth 1]
      set icmpHdrLabel [label $icmpHdrFrame.icmpHdrLabel -text ICMP -width 8 -foreground white -background blue]
      set typeIcmpHdrFrame [frame $icmpHdrFrame.typeIcmpHdrFrame]
        LabelText $typeIcmpHdrFrame 23 "Type"
      set codeIcmpHdrFrame [frame $icmpHdrFrame.codeIcmpHdrFrame]
        LabelText $codeIcmpHdrFrame 4 "Code"
     set chksumIcmpHdrFrame [frame $icmpHdrFrame.chksumIcmpHdrFrame]
        LabelText $chksumIcmpHdrFrame 6 "ChkSum"
      set idIcmpHdrFrame [frame $icmpHdrFrame.idIcmpHdrFrame]
        LabelText $idIcmpHdrFrame 6 "ID"
      set seqIcmpHdrFrame [frame $icmpHdrFrame.seqIcmpHdrFrame]
        LabelText $seqIcmpHdrFrame 10 "Seq #"
      pack $icmpHdrLabel -side left -anchor w -fill y
      pack $typeIcmpHdrFrame $codeIcmpHdrFrame $chksumIcmpHdrFrame $idIcmpHdrFrame $seqIcmpHdrFrame\
       -side left -anchor w -fill x -expand true
    ##################### ICMP DATA DECODE ###########################
    set icmpDecodeFrame [frame $packetFrame.icmpDecodeFrame -background black -borderwidth 1]
      set icmpDecodeLabel [label $icmpDecodeFrame.icmpDecodeLabel -text "ICMP\nDECODE" -width 8\
        -foreground white -background mediumblue]
      set protoIcmpDecodeFrame [frame $icmpDecodeFrame.protoIcmpDecodeFrame]
        LabelText $protoIcmpDecodeFrame  5 "Proto"
      set sipIcmpDecodeFrame [frame $icmpDecodeFrame.sipIcmpDecodeFrame]
        LabelText $sipIcmpDecodeFrame 15 "Orig Src IP"
      set sportIcmpDecodeFrame [frame $icmpDecodeFrame.sportIcmpDecodeFrame]
        LabelText $sportIcmpDecodeFrame 8 "Src Port"
      set dipIcmpDecodeFrame [frame $icmpDecodeFrame.dipIcmpDecodeFrame]
        LabelText $dipIcmpDecodeFrame 15 "Orig Dst IP"
      set dportIcmpDecodeFrame [frame $icmpDecodeFrame.dportIcmpDecodeFrame]
        LabelText $dportIcmpDecodeFrame 8 "Dst Port"
      set gipIcmpDecodeFrame [frame $icmpDecodeFrame.gipIcmpDecodeFrame]
	LabelText $gipIcmpDecodeFrame 15 "Gateway IP"
      pack $icmpDecodeLabel -side left -anchor w -fill y
      pack $protoIcmpDecodeFrame $sipIcmpDecodeFrame $sportIcmpDecodeFrame $dipIcmpDecodeFrame\
        $dportIcmpDecodeFrame $gipIcmpDecodeFrame -side left -anchor w -fill both -expand true
   ##################### DATA ###########################
    set dataFrame [frame $packetFrame.dataFrame -background black -borderwidth 1]
      set dataFrameLabel [label $dataFrame.dataFrameLabel -text DATA -width 8 -foreground white -background navy]
      set dataTextFrame [frame $dataFrame.dataTextFrame]
        set dataText [text $dataTextFrame.dataText -height 10 -width 16\
         -yscrollcommand "$dataFrame.dataScroll set"\
	    -background white -font ourFixedFont]
	set dataHex [text $dataTextFrame.dataHex -height 10 -width 47\
 	 -yscrollcommand "$dataFrame.dataScroll set"\
	 -background white -font ourFixedFont]
        set dataScroll [scrollbar $dataFrame.dataScroll -command "MultiScrollBar \"$dataHex $dataText\"" -width 10]
	pack $dataScroll -side right -fill y
	pack $dataHex -side left -fill both -expand true
        pack $dataText -side left -fill both -expand true
	BindSelectionToAllDataBoxes $dataHex
	BindSelectionToAllDataBoxes $dataText
     pack $dataFrameLabel -side left -anchor w -fill y
     pack $dataTextFrame -side left -anchor w -fill both -expand true
    set dataSearchFrame [frame $packetFrame.dataSearchFrame -bd 0]
	  set dataSearchText [entryfield $dataSearchFrame.dataSearchText -width 20 -background white]
	  set dataSearchButton [button $dataSearchFrame.dataSearchButton -state disabled -text "Search Packet Payload"\
	    -command "SearchData"]
	  set dataSearchType [radiobox $dataSearchFrame.dataSearchType -orient horizontal -labelpos e -borderwidth 0]
	    $dataSearchType add $dataHex -text "Hex" 
	    $dataSearchType add $dataText -text "Text"
	    $dataSearchType select $dataText
	  set dataSearchCaseCheck [checkbutton $dataSearchFrame.dataSearchCaseCheck -variable dataSearchCase -text "NoCase"]
  	  
	  pack $dataSearchText $dataSearchButton $dataSearchType $dataSearchCaseCheck -side left -fill x
     set dataFrameMenu [menu $dataFrame.dataFrameMenu -tearoff 0]
       $dataFrameMenu add command -label "Show/Hide Search Frame"\
	      -command "ShowHideSearch"
     bind [$dataSearchText component entry] <Return> {
       SearchData
     }
     foreach childWin [winfo children $dataTextFrame] {
	bind $childWin <ButtonPress-3> {
	    tk_popup $dataFrameMenu %X [expr %Y +6]
	}
     }
     bind $dataSearchFrame <ButtonPress-3> {
	    tk_popup $dataFrameMenu %X [expr %Y +6]
	}
     foreach childWin [winfo children $dataSearchFrame] {
	bind $childWin <ButtonPress-3> {
	    tk_popup $dataFrameMenu %X [expr %Y +6]
	}
     }
     if { $SEARCHFRAME == 1 } {
	pack $dataSearchFrame -side bottom -anchor s -fill x -expand false
     }
    pack $ipHdrFrame $tcpHdrFrame -fill x -side top
    pack $dataFrame -fill both -expand true -side top
    set DISPLAYEDHDR $tcpHdrFrame
     pack $ruleButtonFrame $ruleText -side top -fill x
  pack $packetFrame -side bottom -fill both -expand true
pack $packetDataFrame -fill both -expand true
set DISPLAYEDDETAIL $packetDataFrame
pack $detailDataFrame -fill both -expand true
$ipDataPane fraction 60 40
$eventPane fraction 55 45
$detailPane fraction 40 60

# Xscript Menu
set eventIDMenut [ menu .eventIDMenut -background blue -foreground white -activeforeground blue\
 -activebackground white -tearoff 0 ]
$eventIDMenut add command -label "Event History" -command "GetEventHistory"
$eventIDMenut add command -label "Transcript" -command "GetXscript xscript 0"
$eventIDMenut add command -label "Transcript (force new)" -command "GetXscript xscript 1"
$eventIDMenut add command -label "Ethereal" -command "GetXscript ethereal 0"
$eventIDMenut add command -label "Ethereal (force new)" -command "GetXscript ethereal 1"

# IPQuery Menu
set ipQueryMenu [ menu .ipQueryMenu -background blue -foreground white -activeforeground blue\
 -activebackground white -tearoff 0 ]
.ipQueryMenu add cascade -label "Query Event Table" -menu $ipQueryMenu.eventMenu
.ipQueryMenu add cascade -label "Query Sessions Table" -menu $ipQueryMenu.sessionsMenu
.ipQueryMenu add cascade -label "Query Sancp Table" -menu $ipQueryMenu.sancpMenu
.ipQueryMenu add cascade -label "Dshield IP Lookup" -menu $ipQueryMenu.dshieldIPMenu
.ipQueryMenu add cascade -label "Nessus Report Lookup" -menu $ipQueryMenu.nessusMenu
menu $ipQueryMenu.eventMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
menu $ipQueryMenu.sessionsMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
menu $ipQueryMenu.sancpMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
menu $ipQueryMenu.dshieldIPMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
menu $ipQueryMenu.nessusMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
$ipQueryMenu.eventMenu add command -label "Query SrcIP" -command "QueryRequest event srcip 1"
$ipQueryMenu.eventMenu add command -label "Query DstIP" -command "QueryRequest event dstip 1"
$ipQueryMenu.eventMenu add command -label "Query Src To Dst" -command "QueryRequest event src2dst 1"
$ipQueryMenu.eventMenu add command -label "Query RT SrcIP" -command "QueryRequest event srcip 0"
$ipQueryMenu.eventMenu add command -label "Query RT DstIP" -command "QueryRequest event dstip 0"
$ipQueryMenu.eventMenu add command -label "Query RT Src To Dst" -command "QueryRequest event src2dst 0"
$ipQueryMenu.sessionsMenu add command -label "Query SrcIP" -command "QueryRequest sessions srcip 0"
$ipQueryMenu.sessionsMenu add command -label "Query SrcIP/1 hour" -command "QueryRequest sessions srcip 1"
$ipQueryMenu.sessionsMenu add command -label "Query DstIP" -command "QueryRequest sessions dstip 0"
$ipQueryMenu.sessionsMenu add command -label "Query DstIP/1 hour" -command "QueryRequest sessions dstip 1"
$ipQueryMenu.sessionsMenu add command -label "Query Src To Dst" -command "QueryRequest sessions src2dst 0"
$ipQueryMenu.sessionsMenu add command -label "Query Src To Dst/1 hour" -command "QueryRequest sessions src2dst 1"
$ipQueryMenu.sancpMenu add command -label "Query SrcIP" -command "QueryRequest sancp srcip 0"
$ipQueryMenu.sancpMenu add command -label "Query SrcIP/1 Hour" -command "QueryRequest sancp srcip 1"
$ipQueryMenu.sancpMenu add command -label "Query DstIP" -command "QueryRequest sancp dstip 0"
$ipQueryMenu.sancpMenu add command -label "Query DstIP/1 Hour" -command "QueryRequest sancp dstip 1"
$ipQueryMenu.sancpMenu add command -label "Query Src To Dst" -command "QueryRequest sancp src2dst 0"
$ipQueryMenu.sancpMenu add command -label "Query Src To Dst/1 Hour" -command "QueryRequest sancp src2dst 1"
$ipQueryMenu.dshieldIPMenu add command -label "SrcIP" -command "GetDshieldIP srcip"
$ipQueryMenu.dshieldIPMenu add command -label "DstIP" -command "GetDshieldIP dstip"
$ipQueryMenu.nessusMenu add command -label "SrcIP" -command "NessusReport srcip"
$ipQueryMenu.nessusMenu add command -label "DstIP" -command "NessusReport dstip"

# Port Query Menu
set portQueryMenu [ menu .portQueryMenu -background blue -foreground white -activeforeground blue\
-activebackground white -tearoff 0 ]
.portQueryMenu add cascade -label "Dshield Port Lookup" -menu $portQueryMenu.dshieldPortMenu
.portQueryMenu add cascade -label "Query Event Table" -menu $portQueryMenu.eventPortMenu

menu $portQueryMenu.dshieldPortMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
  -activebackground white
menu $portQueryMenu.eventPortMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white

$portQueryMenu.dshieldPortMenu add command -label "SrcPort" -command "GetDshieldPort srcport"
$portQueryMenu.dshieldPortMenu add command -label "DstPort" -command "GetDshieldPort dstport"
$portQueryMenu.eventPortMenu add command -label "SrcPort" -command "QueryRequest event srcport"
$portQueryMenu.eventPortMenu add command -label "DstPort" -command "QueryRequest event dstport"


# Sig Query Menu
set sigQueryMenu [ menu .sigQueryMenu -background blue -foreground white -activeforeground blue\
 -activebackground white -tearoff 0 ]
$sigQueryMenu add command -label "Query Event" -command "QueryRequest event signature"

# Correlate Events Menu
set correlateMenu [ menu .correlateMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$correlateMenu add command -label "View Correlated Events"\
 -command "DisplayCorrelatedEvents \$currentSelectedPane.countFrame.list"

# Query Incident Categories Menu
set statusMenu [ menu .statusMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$statusMenu add command -label "Expire Event (F8)" -command "ValidateEvent 1"
$statusMenu add cascade -label "Query" -menu $statusMenu.incidentMenu
set incidentMenu [menu $statusMenu.incidentMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$incidentMenu add command -label "Cat I: Unauthorized Root Access"\
  -command "QueryRequest event category 11"
$incidentMenu add command -label "Cat II: Unauthorized User Access"\
  -command "QueryRequest event category 12"
$incidentMenu add command -label "Cat III: Attempted Unauthorized Access"\
  -command "QueryRequest event category 13"
$incidentMenu add command -label "Cat IV: Successful Denial of Service Attack"\
  -command "QueryRequest event category 14"
$incidentMenu add command -label "Cat V: Poor Security Practice or Policy Violation"\
  -command "QueryRequest event category 15"
$incidentMenu add command -label "Cat VI: Reconnaissance/Probes/Scans"\
  -command "QueryRequest event category 16"
$incidentMenu add command -label "Cat VII: Virus Infection"\
  -command "QueryRequest event category 17"
$statusMenu add cascade -label "Update Event Status" -menu $statusMenu.validateMenu
set validateMenu [menu $statusMenu.validateMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$validateMenu add command -label "Escalate (F9)" -command "ValidateEvent 2"
$validateMenu add command -label "Cat I: Unauthorized Root Access (F1)"\
  -command "ValidateEvent 11"
$validateMenu add command -label "Cat II: Unauthorized User Access (F2)"\
  -command "ValidateEvent 12"
$validateMenu add command -label "Cat III: Attempted Unauthorized Access (F3)"\
  -command "ValidateEvent 13"
$validateMenu add command -label "Cat IV: Successful Denial of Service Attack (F4)"\
  -command "ValidateEvent 14"
$validateMenu add command -label "Cat V: Poor Security Practice or Policy Violation (F5)"\
  -command "ValidateEvent 15"
$validateMenu add command -label "Cat VI: Reconnaissance/Probes/Scans (F6)"\
  -command "ValidateEvent 16"
$validateMenu add command -label "Cat VII: Virus Infection(F7)"\
  -command "ValidateEvent 17"


################### GENERAL KEY BINDINGS ########################

# F8 deletes the highlighted event
bind . <F8> {
  ValidateEvent 1
}
bind . <Shift-Key-F8> {
  ValidateEvent 1 1
}
# F1 deletes the highlighted event and marks the event as 11 (CatI)
bind . <F1> {
  ValidateEvent 11
}
bind . <Shift-Key-F1> {
  ValidateEvent 11 1
}
# F2 deletes the highlighted event and marks the event as 12 (CatII)
bind . <F2> {
  ValidateEvent 12
}
bind . <Shift-Key-F2> {
  ValidateEvent 12 1
}
# F3 deletes the highlighted event and marks the event as 13 (CatIII)
bind . <F3> {
  ValidateEvent 13
}
bind . <Shift-Key-F3> {
  ValidateEvent 13 1
}
# F4 deletes the highlighted event and marks the event as 14 (CatIV)
bind . <F4> {
  ValidateEvent 14
}
bind . <Shift-Key-F4> {
  ValidateEvent 14 1
}
# F5 deletes the highlighted event and marks the event as 15 (CatV)
bind . <F5> {
  ValidateEvent 15
}
bind . <Shift-Key-F5> {
  ValidateEvent 15 1
}
# F6 deletes the highlighted event and marks the event as 16 (CatVI)
bind . <F6> {
  ValidateEvent 16
}
bind . <Shift-Key-F6> {
  ValidateEvent 16 1
}
# F7 deletes the highlighted event and marks the event as 17 (CatVII)
bind . <F7> {
  ValidateEvent 17
}
bind . <Shift-Key-F7> {
  ValidateEvent 17 1
}
# F9 Escalates the event
bind . <F9> {
  ValidateEvent 2
}
bind . <Shift-Key-F9> {
  ValidateEvent 2 1
}
# Ctl-s initiates Sleep function.
bind . <Control-Key-s> {
  GoToSleep
}
# Ctl-q launches Std query window
bind . <Control-Key-q> {
  GetStdQuery
}
# Ctl-f shows/hides the packet search frame
bind . <Control-Key-f> {
  ShowHideSearch
}
# Ctl right/left arrow selects next/prev tab
bind . <Control-Key-Right> {
  $eventTabs next
}
bind . <Control-Key-Left> {
  $eventTabs prev
}
# Space selects the active event.  Used when navigating using ctrl-arrow
# Globally grabbing the space bar is bad :)  Bammkkkk
bind . <Control-Key-space> {
    if {!$SSN_QUERY && !$SANCP_QUERY} { 
      set activeIndex [$currentSelectedPane.eventIDFrame.list index active]
      CtrlSelect $currentSelectedPane.sensorFrame.list $activeIndex
    }
}
# ctrl-up moves active event without changing selection
bind . <Control-Key-Up> {
    set activeIndex [$currentSelectedPane.sensorFrame.list index active]
    $currentSelectedPane.sensorFrame.list activate [expr $activeIndex-1]
    foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
          $childWin.list itemconfigure $activeIndex -foreground black
	    $childWin.list itemconfigure [expr $activeIndex - 1] -foreground red
	    $childWin.list see [expr $activeIndex-1]
	}
    }
}
bind . <Control-Key-Down> {
    set activeIndex [$currentSelectedPane.sensorFrame.list index active]
    $currentSelectedPane.sensorFrame.list activate [expr $activeIndex+1]
    foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
          $childWin.list itemconfigure $activeIndex -foreground black
	    $childWin.list itemconfigure [expr $activeIndex + 1] -foreground red
	    $childWin.list see [expr $activeIndex+1]
	}
    }
}
# Up arrow moves selected event up one.
bind . <Key-Up> {
  if {$ACTIVE_EVENT} {
      set selectedIndex [$currentSelectedPane.sensorFrame.list index active]
    
    set listSize [$currentSelectedPane.sensorFrame.list size]
    if { $selectedIndex != 0 && $selectedIndex < $listSize  } {
      SingleSelect $currentSelectedPane.sensorFrame.list [expr $selectedIndex - 1]
      foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
	    $childWin.list itemconfigure $selectedIndex -foreground black
	    $childWin.list see [expr $selectedIndex - 1]
          set SCROLL_HOME($currentSelectedPane) 0
	}        
      }
    }
  }
}

# Down arrow moves selected event down one.
bind . <Key-Down> {
  if {$ACTIVE_EVENT} {
    set selectedIndex [$currentSelectedPane.sensorFrame.list index active]
    set listSize [$currentSelectedPane.sensorFrame.list size]
    if { $selectedIndex < [expr $listSize -1]  } {
      SingleSelect $currentSelectedPane.sensorFrame.list [expr $selectedIndex + 1]
      foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
          $childWin.list see [expr $selectedIndex + 1]
	  $childWin.list itemconfigure $selectedIndex -foreground black
          set SCROLL_HOME($currentSelectedPane) 0
        }
      }
    }
  }
}

# Esc unselects all options
bind . <Key-Escape> {
  UnSelectPacketOptions
  UnSelectHostLookups
}

# Should be depreciated
#bind . <MouseWheel> {
#    if { $currentSelectedPane != 0 } {
#       puts "DEBUG #### %W"
#	WheelScroll %D $currentSelectedPane "MouseWheel"
#    }
#}
# Toggle SOUND when off/on is clicked
bind $soundStatus <Button-1> {
  if {$SOUND} {
    # Sound is on. turn it off
    TurnSoundOff %W
  } else {
    # Sound is off. Turn it on if we can.
    TurnSoundOn %W
  }
}

#########################################################################

#################### Connect To The Server ##############################

set CONNECTED 0
# Get login and sguild host info
GetUserName

while { $USERNAME == "" } {
  ErrorMessage "ERROR: You must supply a username."
  GetUserName
}

while {$CONNECTED == 0} {
  if [catch { ConnectToSguild } socketID] {
    ErrorMessage $socketID
    GetUserName
  } else {
    set CONNECTED 1
    break
  } 
} 
  SendToSguild "ValidateUser $USERNAME"
  set saltNonce [gets $socketID]
  set tmpSalt [lindex $saltNonce 0]
  set tmpNonce [lindex $saltNonce 1]
  set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
  set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
  puts $socketID $finalCheck
  set USERID [lindex [gets $socketID] 1]
  while { $USERID == "INVALID" } {
    set PASSWD ""
    ErrorMessage "Invalid USERNAME and/or PASSWORD"
    GetUserName 
    SendToSguild "ValidateUser $USERNAME"
    set saltNonce [gets $socketID]
    set tmpSalt [lindex $saltNonce 0]
    set tmpNonce [lindex $saltNonce 1]
    set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
    set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
    puts $socketID $finalCheck
    set USERID [lindex [gets $socketID] 1]
  } 
  wm title . "$VERSION - Connected To $SERVERHOST"
  fileevent $socketID readable [list ServerCommandRcvd $socketID]
  SendToSguild "SendDBInfo"
  SendToSguild "SendSensorList"
  tkwait variable MONITORFLAG
  wm deiconify .
  update
  SendToSguild "SendEscalatedEvents"
  SendToSguild "SendGlobalQryList"
  SendToSguild "SendReportQryList"
  UpdateUserName $USERNAME $USERID
  HeartBeat
  
