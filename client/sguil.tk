#!/bin/sh
# Run wish from users PATH \
exec wish "$0" "$@"

####################################################################
# Snort GUI for Lamerz [sguil] - A tcl/tk interface to snort       #
####################################################################

# Copyright (C) 2002 Robert (Bamm) Visscher <bamm@satx.rr.com>
#
# This program is distributed under the terms of version 1.0 of the 
# Q Public License.  See LICENSE.QPL for further details.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

########################## GLOBALS ##################################

set VERSION "SGUIL-0.3.0"

# Load extended tcl
if [catch {package require Tclx} tclxVersion] {
  puts "ERROR: The tclx extension does NOT appear to be installed on this sysem."
  puts "Extended tcl (tclx) is available as a port/package for most linux and BSD systems."
  exit
}
# Load sha1 from tcllib
if [catch {package require sha1} sha1Version] {
  puts "ERROR: The sha1 package does NOT appear to be installed on this sysem."
  puts "The sha1 package is part of the tcllib extension. A port/package is available for most linux and BSD systems."
  exit
}

set ACTIVE_EVENT 0
set MULTI_SELECT 0
set QUERY_NUMBER 0
set SSN_QUERY_NUMBER 0
set SSN_QUERY 0
set SLEEP 0
set SOUND 0
set FONTFILE "$env(HOME)/.sguilrc"
set USER_QRY_FILE "$env(HOME)/.sgqry"
set MotionHighIndex -1
set MotionStart -1
set MotionLowIndex -1
set MOVEMENT_DIR ""
set LASTINDEXSELECTED 1
set MONITORFLAG 0
set BUSY 0
set REPORTNUM 0
set currentSelectedPane 0 
set COUNTER 0
######################## END GLOBALS ################################

########################## PROCS ####################################

proc ServerCommandRcvd { socketID } {
  global DEBUG EMAIL_RESULTS CONNECTED GLOBAL_QRY_LIST

  if { [eof $socketID] || [catch {gets $socketID data} errorCheck] } {
    #Close the socket and exit
    catch {close $socketID} tmpError
    if { [info exists errorCheck] } {
      ErrorMessage "Lost connection to sguild.\nERROR: $errorCheck\nTrying to reconnect."
    } else {
      ErrorMessage "Connection to sguild terminated. Trying to reconnect."
    }
    set CONNECTED 0
    ReconnectToSguild
  } else {
    if {$DEBUG} {puts "Server Command Recieved: $data"}
    # store $data in $origData because ctoken changes the var it is working on.
    set origData $data
    set serverCmd [ctoken data " "]
    set data1 [string trimleft $data]
    # data1 has indices 1 on etc etc
    set index1 [ctoken data " "]
    set data2 [string trimleft $data]
   
    switch -exact $serverCmd {
      InsertEvent { $serverCmd $data1 }
      InsertSystemInfoMsg { $serverCmd $index1 $data2 }
      InsertRuleData { $serverCmd $data1 }
      DeleteEventID { $serverCmd $data1 }
      DeleteEventIDList { $serverCmd $data1 }
      InsertTcpHdr { $serverCmd $data1 }
      InsertIPHdr { $serverCmd $data1 }
      InsertUdpHdr { $serverCmd $data1 }
      # due to the funky ranges in InsertIcmpHeader, ctoken will not work.
      # since it is Icmp Header data, it should be predictable and not
      # subject to user input, so lrange is fine
      InsertIcmpHdr { $serverCmd [lrange $origData 1 5] [lrange $origData 6 end]}
      InsertPayloadData { $serverCmd $data1 }
      InsertQueryResults { $serverCmd $index1 $data2 }
      InfoMessage { $serverCmd $data1 }
      PSDataResults { InsertPSData $data1 }
      InsertEscalatedEvent { $serverCmd $data1 }
      SensorList { $serverCmd $data1 }
      TableNameList { $serverCmd $data1 }
      TableColumns { $serverCmd $index1 $data2 }
      InsertHistoryResults { $serverCmd $index1 $data2 }
      InsertEmailIPHdr { set EMAIL_RESULTS $data1 }
      UserMessage { $serverCmd $index1 $data2 }
      PONG { if {$DEBUG} {puts "Comm test successful"  } }
      GlobalQryList { set GLOBAL_QRY_LIST $data1 }
      ReportResponse { $serverCmd $index1 $data2 }
      default { puts "Unrecognized command from $socketID: $origData" }
    }
  } 
}
proc ConnectToSguild {} {
  global SERVERHOST SERVERPORT OPENSSL VERSION TLS_PATH DEBUG CONNECTED

  if [catch {socket $SERVERHOST $SERVERPORT} socketID ] {
    return -code error "Unable to connect to $SERVERHOST on port $SERVERPORT"
  } else {
    set CONNECTED 1
    fconfigure $socketID -buffering line
    # Version checking
    if {$OPENSSL} {
      set tmpVERSION "$VERSION OPENSSL ENABLED"
    } else {
      set tmpVERSION "$VERSION OPENSSL DISABLED"
    }     
    if [catch {gets $socketID} serverVersion] {
      puts "ERROR: $serverVersion"
      return -code error "$serverVersion"
    }
    if { $serverVersion != $tmpVERSION } {
      return -code error "Mismatched versions.\nSERVER: ($serverVersion)\nCLIENT: ($tmpVERSION)"
    }
    puts $socketID "$tmpVERSION"
    if {$OPENSSL} {
      if { [info exists TLS_PATH] } { load $TLS_PATH }
      package require tls
      tls::import $socketID
    }
    after 1000
    if {$DEBUG} {puts "Sending PING"}
    puts $socketID "PING"
    set INIT [gets $socketID]
    if {$DEBUG} {puts "Init successful"}
    return $socketID
  }
}
proc ReconnectToSguild {} {
  global CONNECTED USERNAME PASSWD socketID monitorList
  if [catch {ConnectToSguild} socketID] {
    ErrorMessage "${socketID}. Will try again in 10 secs."
    set CONNECTED 0
    after 10000 ReconnectToSguild
  } else {
    set CONNECTED 1
    InfoMessage "Reconnected to sguild. Reauthenticating client."
    SendToSguild "ValidateUser $USERNAME"
    set saltNonce [gets $socketID]
    set tmpSalt [lindex $saltNonce 0]
    set tmpNonce [lindex $saltNonce 1]
    set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
    set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
    puts $socketID $finalCheck
    set USERID [lindex [gets $socketID] 1]
    while { $USERID == "INVALID" } {
      set PASSWD ""
      ErrorMessage "Invalid USERNAME and/or PASSWORD"
      GetUserName 
      SendToSguild "ValidateUser $USERNAME"
      set saltNonce [gets $socketID]
      set tmpSalt [lindex $saltNonce 0]
      set tmpNonce [lindex $saltNonce 1]
      set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
      set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
      puts $socketID $finalCheck
      set USERID [lindex [gets $socketID] 1]
    } 
    set CONNECTED 1
    ClearAllEventLists
    fileevent $socketID readable [list ServerCommandRcvd $socketID]
    SendToSguild "MonitorSensors $monitorList"
    SendToSguild "SendEscalatedEvents"
    SendToSguild "SendGlobalQryList"
  }
}
proc SendToSguild { data } {
  global socketID CONNECTED
  if {!$CONNECTED} {
     ErrorMessage "Not connected to sguild. Unable to process this request."
  } else {
    if [catch {puts $socketID $data} errorCheck] {
      catch {close $socketID} tmpError
      if { [info exists errorCheck] } {
        ErrorMessage "Lost connection to sguild.\nERROR: $errorCheck\nTrying to reconnect."
      } else {
        ErrorMessage "Connection to sguild terminated. Trying to reconnect."
      }
      set CONNECTED 0
      ReconnectToSguild
    }
  }
}
proc UpdateClock {} {
  global gmtClock
  $gmtClock configure -text "[GetCurrentTimeStamp] GMT"
  after 1000 UpdateClock
}
proc AboutBox {} {
    global VERSION
    set aboutWin .aboutWin
    if [winfo exists $aboutWin] {
	wm withdraw $aboutWin
	wm deiconify $aboutWin
	return
    }
    toplevel $aboutWin
    wm title $aboutWin "Snort GUI for Lamerz \[sguil\]"
    set welcomeFrame [frame $aboutWin.welcomeFrame -borderwidth 1 -background black]
    set welcomeLabel [label $welcomeFrame.welcomeLabel -background lightblue\
	    -foreground navy -text "\
	    Snort GUI for Lamerz \[sguil\] Version: $VERSION\n\
	    \n\
	    Copyright (C) 2002 Robert (Bamm) Visscher <bamm@satx.rr.com>\n\
	    \n\
	    This program is distributed under the terms of version 1.0 of the\n\
	    Q Public License.  See LICENSE.QPL for further details.\n\
	    \n\
	    This program is distributed in the hope that it will be useful,\n\
	    but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\
	    "]
    pack $welcomeLabel -ipadx 5 -ipady 5
    pack $welcomeFrame -side top -padx 5 -pady 10
    set actionButtonFrame [frame $aboutWin.actionButtonFrame -background white]
    set okButton [button $actionButtonFrame.okButton -text "Ok"\
	    -command "destroy $aboutWin"]
    pack $okButton -side top
    pack $actionButtonFrame -side bottom
}
proc TableNameList { tmpList } {
  global tableList
  set tableList $tmpList
}
proc TableColumns { tableName tmpColumnList } {
  global tableColumnArray
  set tableColumnArray($tableName) $tmpColumnList
}
proc ShowDBTables {} {
  global tableList tableColumnArray currentTableList tableListFrame
  set tableWin .tableWin
  if [winfo exists $tableWin] {
    wm withdraw $tableWin
    wm deiconify $tableWin
    return
  }
  toplevel $tableWin
  wm title $tableWin "Table Descriptions"
  set tableSelMenu [optionmenu $tableWin.tableSelMenu\
    -labeltext "Table Name:" -command "DisplayTableColumns $tableWin.tableSelMenu"] 
  foreach tableName $tableList {
    $tableSelMenu insert end $tableName
    set tableListFrame($tableName) [frame $tableWin.${tableName}Frame\
     -background black -borderwidth 1]
    CreateTableListBox $tableListFrame($tableName) $tableColumnArray($tableName)
  }
  set currentTableList $tableName
  button $tableWin.close -text "Close" -command "destroy $tableWin"
  pack $tableSelMenu $tableListFrame($tableName) $tableWin.close -side top
  $tableSelMenu sort ascending
  $tableSelMenu select event
  $tableSelMenu configure -cyclicon true
  DisplayTableColumns $tableWin.tableSelMenu
}
proc DisplayTableColumns { winName } {
  global currentTableList tableListFrame
  set tableName [$winName get]
  pack forget $tableListFrame($currentTableList)
  pack $tableListFrame($tableName) -after $winName -fill both -expand true
  set currentTableList $tableName
}
proc CreateTableListBox { winName columnList } {
  set nameFrame [frame  $winName.nameFrame]
    set nameLabel [label $nameFrame.nameLabel -text "Column Name" -background black -foreground white]
    set nameList [listbox $nameFrame.nameList -width 15 -height 10\
     -yscrollcommand "$winName.scroll set" -exportselection false -borderwidth 0]
    pack $nameLabel -fill x -side top
    pack $nameList -side top -fill both -expand true
  set typeFrame [frame  $winName.typeFrame]
    set typeLabel [label $typeFrame.typeLabel -text "Type" -background black -foreground white]
    set typeList [listbox $typeFrame.typeList -width 10 -height 10\
     -yscrollcommand "$winName.scroll set" -exportselection false -borderwidth 0]
    pack $typeLabel -fill x -side top
    pack $typeList -side top -fill both -expand true
  set lengthFrame [frame $winName.lenghtFrame]
    set lengthLabel [label $lengthFrame.lengthLabel -text "Length" -background black -foreground white]
    set lengthList [listbox $lengthFrame.lengthList -width 10 -height 10\
     -yscrollcommand "$winName.scroll set" -exportselection false -borderwidth 0]
    pack $lengthLabel -fill x -side top
    pack $lengthList -side top -fill both -expand true
  scrollbar $winName.scroll -command "MultiScrollBar \"$nameList $typeList $lengthList\""\
   -width 10
  pack $nameFrame $typeFrame $lengthFrame -side left -expand true -fill both
  pack $winName.scroll -side right -fill y
   
  set BCOLOR white
  foreach column $columnList {
    $nameList insert end [lindex $column 0]
    $typeList insert end [lindex $column 1]
    $lengthList insert end [lindex $column 2]
    if { $BCOLOR == "white" } { set BCOLOR lightblue } else { set BCOLOR white }
    $nameList itemconfigure end -background $BCOLOR
    $typeList itemconfigure end -background $BCOLOR
    $lengthList itemconfigure end -background $BCOLOR
  }
}
proc SendUserMsg {} {
  global USERMSG userMsgEntry

  SendToSguild "[list UserMessage $USERMSG]"
  [$userMsgEntry component entry] delete 0 end
}

proc UserMessage { user userMsg } {
  global userMsgText messageTabs MESSAGE_TAB USER_MSG_SCROLL

  set userMsg [lindex $userMsg 0]

  if { [$messageTabs view] != 1 } {
    # BOING!
    #bell
    $messageTabs pageconfigure 1 -foreground red 
  } else {
    $messageTabs pageconfigure 1 -foreground
  }
  [$userMsgText component text] insert end "\n\[[lindex [GetCurrentTimeStamp] 1]\] <$user> $userMsg"
  if { $USER_MSG_SCROLL } { [$userMsgText component text] see end }
}
proc DisplayIncidentCats {} {
  set categoryTl [toplevel .categoryTl]
  wm title .categoryTl "Incident Categories"
  wm geometry .categoryTl +[winfo pointerx .]+[winfo pointery .]
  set categoryText [scrolledtext $categoryTl.categoryText -vscrollmode dynamic -hscrollmode dynamic\
   -wrap word -visibleitems 60x8 -labelpos n -labeltext "Incident Category Definitions"]
  set categoryButton [button $categoryTl.close -text "Ok" -command "destroy $categoryTl"]
  pack $categoryText -side top -fill both -expand true
  pack $categoryButton -side bottom
  $categoryText component text insert end "Category I\tUnauthorized Root/Admin Access\n"
  $categoryText component text insert end "Category II\tUnauthorized User Access\n"
  $categoryText component text insert end "Category III\tAttempted Unauthorized Access\n"
  $categoryText component text insert end "Category IV\tSuccessful Denial of Service Attack\n"
  $categoryText component text insert end "Category V\tPoor Security Practice or Policy Violation\n"
  $categoryText component text insert end "Category VI\tReconnaissance/Probes/Scans\n"
  $categoryText component text insert end "Category VII\tVirus Infection\n"
}
proc GetComment {} {
  global COMMENT_FLAG
  set COMMENT_FLAG 0
  if { [winfo exists .comment] } {
    destroy .comment
  }
  toplevel .comment
  wm title .comment "Add Comment To Event History"
  wm geometry .comment +[expr [winfo rootx .] + 50]+[winfo pointery .]
  entryfield .comment.e -labeltext "Add a short comment for the event:" -labelpos n -width 80
  buttonbox .comment.bb
    .comment.bb add ok -text "Okay" -command "set COMMENT_FLAG 1"
    .comment.bb add cancel -text "Cancel" -command "set COMMENT_FLAG 0"
  pack .comment.e .comment.bb -side top
  bind [.comment.e component entry] <Return> { set COMMENT_FLAG 1 }
  tkwait variable COMMENT_FLAG
  if {$COMMENT_FLAG} {
    set comment [[.comment.e component entry] get]
  } else {
    set comment ""
  } 
  destroy .comment
  return $comment
}
proc ValidateEvent { status {c_flag {0}} } {
  global ACTIVE_EVENT currentSelectedPane eventArray correlateArray socketID DEBUG
  global MULTI_SELECT CONNECTED

  if {!$CONNECTED} {
    ErrorMessage "Not Connected to sguild. Cannot validate events at this time."
    return
  }
  set eventComment none
  if {$ACTIVE_EVENT} {
     if { $status == 2 || $c_flag } {
       set eventComment [GetComment]
       if { $eventComment == "" } { InfoMessage "No comment, aborting."; return }
     }
     foreach selectedIndex\
      [lsort -integer -decreasing [$currentSelectedPane.eventIDFrame.list curselection]] {
       # Get the eventID to be deleted
       set eventID [$currentSelectedPane.eventIDFrame.list get $selectedIndex]
	lappend deleteEventIDList $eventID
       # Remove the selected line from the console
       DeleteLine $currentSelectedPane $selectedIndex
       if { [info exists correlateArray($eventID)] } {
         foreach event $correlateArray($eventID) {
           if { [info exists eventArray($event)] } { unset eventArray($event) }
           lappend deleteEventIDList $event
         }
         unset correlateArray($eventID)
       } 
     }
     update idletasks
     if {$DEBUG} {
       puts "Sending Server: DeleteEventIDList ${eventComment}::${status}::${deleteEventIDList}"
     }
     SendToSguild "DeleteEventIDList ${status}::${eventComment}::${deleteEventIDList}"
     if { [llength [$currentSelectedPane.eventIDFrame.list curselection]] > 1} {
	 # puts "unslecting multiple events"
	 UnHighLightListLine $currentSelectedPane
     } 
     set MULTI_SELECT 0
     SelectNextEvent $currentSelectedPane $selectedIndex
  }
}
#
# SimpleQueryCmd: Makes a seperate cnx to sguild for the purpose of running
#                 a single query to the db. These queries are preformated
#                 see below. I am sure this is going to come back and bite
#                 me in the ass.    Bammkkkk
#
# <cmd> must be in the format of "<request> sid cid" where <request> is one 
# of the below.
#
# <request>
#  Data returned from DB.
# 
# GetIPData
#  INET_NTOA(src_ip), INET_NTOA(dst_ip), ip_ver, ip_hlen, ip_tos, ip_len, ip_id, 
#  ip_flags, ip_off, ip_ttl, ip_csum
#
# GetTcpData
#  tcp_seq, tcp_ack, tcp_off, tcp_res, tcp_flags, tcp_win, tcp_csum, tcp_urp, src_port, dst_port
#  
# GetIcmpData
#  icmp_type, icmp_code, icmp_csum, icmp_id, icmp_seq, data_payload
#
# GetPayloadData
#  data_payload 
# 
# GetUdpData
#  udp_len, udp_csum, src_port, dst_port
#
proc SimpleQueryCmd { host port cmd} {
    global EMAIL_RESULTS
    global DEBUG
    if [catch { ConnectToSguild } tmpSocketID] {
       ErrorMessage $tmpSocketID
    } else {
       set CONNECTED 1
       puts $tmpSocketID $cmd
       if {[lindex $cmd 0] != "GetPSData"} {
          # Index 0 is the returned cmd, index 1 is the data.
          set data [lrange [gets $tmpSocketID] 1 end]
	    
       } else {
         set psrow ""
         set i 0
         set data ""
         while { [lindex $psrow 0] != "DONE" } {
	    set psrow [lrange [gets $tmpSocketID] 1 end]
	    lappend data $psrow
	 }
       }
       close $tmpSocketID
       return $data
    }
}
proc OptimizeTables {} {
    global socketID DEBUG RETURN_FLAG
    global CONNECTED
    if {!$CONNECTED} {
      ErrorMessage "Not connected to sguild. Unable to send optimize request."
      return
    }
    set RETURN_FLAG 0
    set optimizeTables .optimizeTables
    if { [winfo exists $optimizeTables] } {
	wm withdraw $optimizeTables
	wm deiconify $optimizeTables
	return
    }
    toplevel $optimizeTables
    wm geometry $optimizeTables +200+200
    wm title $optimizeTables "Optimize Database Tables"
    set checkBox1 [checkbox $optimizeTables.checkBox1]
    set tables1 [list data icmphdr sensor status tcphdr udphdr]
    foreach t [lsort $tables1] {
	$checkBox1 add $t -text [string totitle $t]
	
    }
    set checkBox2 [checkbox $optimizeTables.checkBox2]
    set tables2 [list event portscan sessions]
    foreach t [lsort $tables2] {
	$checkBox2 add $t -text [string totitle $t]
    }
    set buttonBox [buttonbox $optimizeTables.buttonBox]
    $buttonBox add Run -text "Run" -command "set RETURN_FLAG 1"
    $buttonBox add Cancel -text "Cancel" -command "set RETURN_FLAG 0"
    pack $checkBox1 $checkBox2 $buttonBox -side top -fill x -padx 10 -expand 0
    tkwait variable RETURN_FLAG
    if { $RETURN_FLAG } {
	set tableList1 [$checkBox1 get]
	set tableList2 [$checkBox2 get]
	if { [llength $tableList1] == 0 && [llength $tableList2] == 0 } {
	    destroy $optimizeTables
	    return
	} else {
	    set tableList [concat $tableList1 $tableList2]
	    # puts $tableList
	    # puts [llength $tableList]
	    set optimizeQuery "OPTIMIZE TABLE [lindex $tableList 0]"
	    if { [llength $tableList] > 1 } {
		for { set i 1 } { $i < [llength $tableList] } {incr i 1} {
		    # puts [lindex $tableList $i]
		    set optimizeQuery "$optimizeQuery, [lindex $tableList $i]"
		    puts $optimizeQuery
		}
	    }
	  set answer [tk_messageBox -title confirm -type okcancel -icon warning -message "WARNING: Optimization can cause tables to corrupt.  If you don't know how to fix corruption, DO NOT PROCEED."]
	    if { $answer == "ok" } {
		if {$DEBUG} { puts "Send Server: ExecDB $optimizeQuery" }
		SendToSguild "ExecDB $optimizeQuery"
	    }
	   
	}
	destroy $optimizeTables
	return
    }
}
	    
    
proc DeleteRequest { deletetype } {
    global socketID DEBUG RETURN_FLAG
    global CONNECTED
    if {!$CONNECTED} {
      ErrorMessage "Not Connected to sguild. Unable to delete events."
      return
    }
    set RETURN_FLAG 0
    set deleteRequest .deleteRequest
    if { [winfo exists $deleteRequest] } {
	wm withdraw $deleteRequest
	wm deiconify $deleteRequest
	return
    }
    toplevel $deleteRequest
    wm geometry $deleteRequest +200+200
    if { $deletetype == "sessions" } {
	wm title $deleteRequest "Purge Session Data"
	set deleteDate [entryfield $deleteRequest.deleteDate -labeltext "Date:" ]
	$deleteDate insert end [lindex [GetCurrentTimeStamp "1 month ago"] 0]
	set buttonBox [buttonbox $deleteRequest.buttonBox]
	$buttonBox add Run -text "Run" -command "set RETURN_FLAG 1"
	$buttonBox add cancel -text "Cancel" -command "set RETURN_FLAG 0"
	pack $deleteDate $buttonBox -side top -fill x -padx 10 -expand 0
	tkwait variable RETURN_FLAG
	if { $RETURN_FLAG } {
	    set deleteQuery "DELETE from sessions WHERE sessions.start_time <= '[$deleteDate get]'"
	    if {$DEBUG} { puts "Sending Server: ExecDB $deleteQuery" }
	    SendToSguild "ExecDB $deleteQuery"
	}
	destroy $deleteRequest
	return
    }
}


proc LaunchXscriptMenu { winName yRoot} {
  global ACTIVE_EVENT eventIDMenut MULTI_SELECT
  if {!$ACTIVE_EVENT || $MULTI_SELECT == 1} { return }
  set selectedIndex { $winName curselection }
  if { $selectedIndex == "" } { set ACTIVE_EVENT 0; return }
  tk_popup $eventIDMenut [winfo rootx $winName] [expr $yRoot + 6]
}
proc LaunchIPQueryMenu { winName yRoot } {
  global ACTIVE_EVENT ipQueryMenu MULTI_SELECT
  if {!$ACTIVE_EVENT || $MULTI_SELECT == 1} { return }
  set selectedIndex { $winName curselection }
  if { $selectedIndex == "" } { set ACTIVE_EVENT 0; return }
  tk_popup $ipQueryMenu [winfo rootx $winName] [expr $yRoot + 6]
}
proc LaunchPortQueryMenu { winName yRoot } {
  global ACTIVE_EVENT portQueryMenu MULTI_SELECT
  if {!$ACTIVE_EVENT || $MULTI_SELECT == 1} { return }
  set selectedIndex { $winName curselection }
  if { $selectedIndex == "" } { set ACTIVE_EVENT 0; return }
  tk_popup $portQueryMenu [winfo rootx $winName] [expr $yRoot + 6]
}
proc LaunchSigQueryMenu { winName yRoot } {
  global ACTIVE_EVENT sigQueryMenu MULTI_SELECT
    if {!$ACTIVE_EVENT || $MULTI_SELECT == 1} { return }
  set selectedIndex { $winName curselection }
  if { $selectedIndex == "" } { set ACTIVE_EVENT 0; return }
  tk_popup $sigQueryMenu [winfo rootx $winName] [expr $yRoot + 6]
}
proc LaunchCorrelateMenu { winName yRoot } {
  global ACTIVE_EVENT correlateMenu MULTI_SELECT
  if {!$ACTIVE_EVENT || $MULTI_SELECT == 1} { return }
  set selectedIndex { $winName curselection }
  if { $selectedIndex == "" } { set ACTIVE_EVENT 0; return }
  tk_popup $correlateMenu [winfo rootx $winName] [expr $yRoot +6]
}
proc LaunchStatusMenu { winName yRoot } {
  global ACTIVE_EVENT statusMenu
  if {!$ACTIVE_EVENT} { return }
  set selectedIndex { $winName curselection }
  if { $selectedIndex == "" } { set ACTIVE_EVENT 0; return }
  tk_popup $statusMenu [winfo rootx $winName] [expr $yRoot +6]
}
proc ClearPacketData {} {
  global srcIPHdrFrame dstIPHdrFrame verIPHdrFrame hdrLenIPHdrFrame
  global tosIPHdrFrame lenIPHdrFrame idIPHdrFrame flagsIPHdrFrame
  global offsetIPHdrFrame ttlIPHdrFrame chksumIPHdrFrame
  global r1TcpHdrFrame r0TcpHdrFrame urgTcpHdrFrame ackTcpHdrFrame
  global pshTcpHdrFrame rstTcpHdrFrame synTcpHdrFrame finTcpHdrFrame
  global windowTcpHdrFrame urpTcpHdrFrame tcpchksumTcpHdrFrame
  global sPortTcpHdrFrame dPortTcpHdrFrame seqTcpHdrFrame
  global acknoTcpHdrFrame tcpoffsetTcpHdrFrame resTcpHdrFrame
  global sPortUdpHdrFrame dPortUdpHdrFrame udplenUdpHdrFrame udpchksumUdpHdrFrame
  global typeIcmpHdrFrame codeIcmpHdrFrame chksumIcmpHdrFrame
  global idIcmpHdrFrame seqIcmpHdrFrame sipIcmpDecodeFrame
  global dipIcmpDecodeFrame sportIcmpDecodeFrame dportIcmpDecodeFrame protoIcmpDecodeFrame gipIcmpDecodeFrame
  global dataText

  $srcIPHdrFrame.text delete 0.0 end
  $dstIPHdrFrame.text delete 0.0 end
  $verIPHdrFrame.text delete 0.0 end
  $hdrLenIPHdrFrame.text delete 0.0 end
  $tosIPHdrFrame.text delete 0.0 end
  $lenIPHdrFrame.text delete 0.0 end
  $idIPHdrFrame.text delete 0.0 end
  $flagsIPHdrFrame.text delete 0.0 end
  $offsetIPHdrFrame.text delete 0.0 end
  $ttlIPHdrFrame.text delete 0.0 end
  $chksumIPHdrFrame.text delete 0.0 end

  $r1TcpHdrFrame.text delete 0.0 end
  $r0TcpHdrFrame.text delete 0.0 end
  $urgTcpHdrFrame.text delete 0.0 end
  $ackTcpHdrFrame.text delete 0.0 end
  $pshTcpHdrFrame.text delete 0.0 end
  $rstTcpHdrFrame.text delete 0.0 end
  $synTcpHdrFrame.text delete 0.0 end
  $finTcpHdrFrame.text delete 0.0 end
  $windowTcpHdrFrame.text delete 0.0 end
  $urpTcpHdrFrame.text delete 0.0 end
  $tcpchksumTcpHdrFrame.text delete 0.0 end
  $sPortTcpHdrFrame.text delete 0.0 end
  $dPortTcpHdrFrame.text delete 0.0 end
  $seqTcpHdrFrame.text delete 0.0 end
  $acknoTcpHdrFrame.text delete 0.0 end
  $tcpoffsetTcpHdrFrame.text delete 0.0 end
  $resTcpHdrFrame.text delete 0.0 end

  $sPortUdpHdrFrame.text delete 0.0 end
  $dPortUdpHdrFrame.text delete 0.0 end
  $udplenUdpHdrFrame.text delete 0.0 end
  $udpchksumUdpHdrFrame.text delete 0.0 end

  $typeIcmpHdrFrame.text delete 0.0 end
  $codeIcmpHdrFrame.text delete 0.0 end
  $chksumIcmpHdrFrame.text delete 0.0 end
  $idIcmpHdrFrame.text delete 0.0 end
  $seqIcmpHdrFrame.text delete 0.0 end
  $sipIcmpDecodeFrame.text delete 0.0 end
  $dipIcmpDecodeFrame.text delete 0.0 end
  $gipIcmpDecodeFrame.text delete 0.0 end
  $sportIcmpDecodeFrame.text delete 0.0 end
  $dportIcmpDecodeFrame.text delete 0.0 end
  $protoIcmpDecodeFrame.text delete 0.0 end
  $dataText delete 0.0 end
}
proc InsertIPHdr { data } {
  global srcIPHdrFrame dstIPHdrFrame verIPHdrFrame hdrLenIPHdrFrame
  global tosIPHdrFrame lenIPHdrFrame idIPHdrFrame flagsIPHdrFrame
  global offsetIPHdrFrame ttlIPHdrFrame chksumIPHdrFrame
  
  $srcIPHdrFrame.text insert 0.0 [lindex $data 0]
  $dstIPHdrFrame.text insert 0.0 [lindex $data 1]
  $verIPHdrFrame.text insert 0.0 [lindex $data 2]
  $hdrLenIPHdrFrame.text insert 0.0 [lindex $data 3]
  $tosIPHdrFrame.text insert 0.0 [lindex $data 4]
  $lenIPHdrFrame.text insert 0.0 [lindex $data 5]
  $idIPHdrFrame.text insert 0.0 [lindex $data 6]
  $flagsIPHdrFrame.text insert 0.0 [lindex $data 7]
  $offsetIPHdrFrame.text insert 0.0 [lindex $data 8]
  $ttlIPHdrFrame.text insert 0.0 [lindex $data 9]
  $chksumIPHdrFrame.text insert 0.0 [lindex $data 10]
}
proc InsertTcpHdr { data } {
  global r1TcpHdrFrame r0TcpHdrFrame urgTcpHdrFrame ackTcpHdrFrame
  global pshTcpHdrFrame rstTcpHdrFrame synTcpHdrFrame finTcpHdrFrame
  global windowTcpHdrFrame urpTcpHdrFrame tcpchksumTcpHdrFrame
  global sPortTcpHdrFrame dPortTcpHdrFrame seqTcpHdrFrame
  global acknoTcpHdrFrame tcpoffsetTcpHdrFrame resTcpHdrFrame

  $sPortTcpHdrFrame.text insert 0.0 [lindex $data 8]
  $dPortTcpHdrFrame.text insert 0.0 [lindex $data 9]
  $seqTcpHdrFrame.text insert 0.0 [lindex $data 0]
  $acknoTcpHdrFrame.text insert 0.0 [lindex $data 1]
  $tcpoffsetTcpHdrFrame.text insert 0.0 [lindex $data 2]
  $resTcpHdrFrame.text insert 0.0 [lindex $data 3]
  # TCP Flags
  set ipFlags [lindex $data 4]
  set r1Flag "."
  set r0Flag "."
  set urgFlag "."
  set ackFlag "."
  set pshFlag "."
  set rstFlag "."
  set synFlag "."
  set finFlag "."
  if { $ipFlags != "" } {
    if { 128 & $ipFlags } {
      set r1Flag "X"
      set ipFlags [expr $ipFlags - 128]
    }
    if { 64 & $ipFlags } {
      set r0Flag "X"
      set ipFlags [expr $ipFlags - 64]
    }
    if { 32 & $ipFlags } {
      set urgFlag "X"
      set ipFlags [expr $ipFlags - 32]
    }
    if { 16 & $ipFlags } {
      set ackFlag "X"
      set ipFlags [expr $ipFlags - 16]
    }
    if { 8 & $ipFlags } {
      set pshFlag "X"
      set ipFlags [expr $ipFlags - 8]
    }
    if { 4 & $ipFlags } {
      set rstFlag "X"
      set ipFlags [expr $ipFlags - 4]
    }
    if { 2 & $ipFlags } {
      set synFlag "X"
      set ipFlags [expr $ipFlags - 2]
    }
    if { 1 & $ipFlags } {
      set finFlag "X"
    }
  }
  $r1TcpHdrFrame.text insert 0.0 $r1Flag
  $r0TcpHdrFrame.text insert 0.0 $r0Flag
  $urgTcpHdrFrame.text insert 0.0 $urgFlag
  $ackTcpHdrFrame.text insert 0.0 $ackFlag
  $pshTcpHdrFrame.text insert 0.0 $pshFlag
  $rstTcpHdrFrame.text insert 0.0 $rstFlag
  $synTcpHdrFrame.text insert 0.0 $synFlag
  $finTcpHdrFrame.text insert 0.0 $finFlag

  $windowTcpHdrFrame.text insert 0.0 [lindex $data 5]
  $urpTcpHdrFrame.text insert 0.0 [lindex $data 6]
  $tcpchksumTcpHdrFrame.text insert 0.0 [lindex $data 7]
  
}
proc InsertUdpHdr { data } {
  global sPortUdpHdrFrame dPortUdpHdrFrame udplenUdpHdrFrame udpchksumUdpHdrFrame
  $sPortUdpHdrFrame.text insert 0.0 [lindex $data 2]
  $dPortUdpHdrFrame.text insert 0.0 [lindex $data 3]
  $udplenUdpHdrFrame.text insert 0.0 [lindex $data 0]
  $udpchksumUdpHdrFrame.text insert 0.0 [lindex $data 1]
}
proc InsertIcmpHdr { data pldata } {
  global typeIcmpHdrFrame codeIcmpHdrFrame chksumIcmpHdrFrame
  global idIcmpHdrFrame seqIcmpHdrFrame
  global icmpDecodeFrame icmpHdrFrame
  $typeIcmpHdrFrame.text insert 0.0 [lindex $data 0]
  $codeIcmpHdrFrame.text insert 0.0 [lindex $data 1]
  $chksumIcmpHdrFrame.text insert 0.0 [lindex $data 2]
  $idIcmpHdrFrame.text insert 0.0 [lindex $data 3]
  $seqIcmpHdrFrame.text insert 0.0 [lindex $data 4]
  
  # If the ICMP packet is a dest unreachable, redirect or a time exceeded,
  # check to see if it is network, host, port unreachable or admin prohibited or filtered
  # then show some other stuff

  if {[lindex $data 0] == "3" || [lindex $data 0] == "11" || [lindex $data 0] == "5"} {
	if {[lindex $data 1] == "0" || [lindex $data 1] == "4" || [lindex $data 1] == "9" || [lindex $data 1] == "13" || [lindex $data 1] == "1" || [lindex $data 1] == "3" || [lindex $data 1] == "2" } {
	    global protoIcmpDecodeFrame sipIcmpDecodeFrame sportIcmpDecodeFrame dipIcmpDecodeFrame dportIcmpDecodeFrame gipIcmpDecodeFrame
	    
	    #  There may be 32-bits of NULL padding at the start of the payload
	    # or a 32-bit gateway address on a redirect
	    set offset 0
	    # puts [string range $pldata 0 7]
	    if {[string range $pldata 0 7] == "00000000" || [lindex $data 0] == "5"} {
		set offset 8
		if {[lindex $data 0] == "5"} {
		    set giphex1 [string range $pldata 0 1]
		    set giphex2 [string range $pldata 2 3]
		    set giphex3 [string range $pldata 4 5]
		    set giphex4 [string range $pldata 6 7]
		    $gipIcmpDecodeFrame.text insert 0.0 [format "%i" 0x$giphex1].[format "%i" 0x$giphex2].[format "%i" 0x$giphex3].[format "%i" 0x$giphex4]
		}
	    }
	    # puts [string range $pldata [expr $offset+24] [expr $offset+25]]
	    
	    # Build the protocol
	    set protohex [string range $pldata [expr $offset+18] [expr $offset+19]]
	    $protoIcmpDecodeFrame.text insert 0.0 [format "%i" 0x$protohex]

	    # Build the src address
	    set srchex1 [string range $pldata [expr $offset+24] [expr $offset+25]]
	    set srchex2 [string range $pldata [expr $offset+26] [expr $offset+27]]
	    set srchex3 [string range $pldata [expr $offset+28] [expr $offset+29]]
	    set srchex4 [string range $pldata [expr $offset+30] [expr $offset+31]]
	    $sipIcmpDecodeFrame.text insert 0.0 [format "%i" 0x$srchex1].[format "%i" 0x$srchex2].[format "%i" 0x$srchex3].[format "%i" 0x$srchex4]
	    
	    # Build the dst address
	    set dsthex1 [string range $pldata [expr $offset+32] [expr $offset+33]]
	    set dsthex2 [string range $pldata [expr $offset+34] [expr $offset+35]]
	    set dsthex3 [string range $pldata [expr $offset+36] [expr $offset+37]]
	    set dsthex4 [string range $pldata [expr $offset+38] [expr $offset+39]]
	    $dipIcmpDecodeFrame.text insert 0.0 [format "%i" 0x$dsthex1].[format "%i" 0x$dsthex2].[format "%i" 0x$dsthex3].[format "%i" 0x$dsthex4]
	    
	    # Find and build the src port
	    set hdroffset [expr [string index $pldata [expr ($offset+1)]] * 8 + $offset]
	    puts "header offset = $hdroffset"
	    puts "header lenght = [string index $pldata [expr ($offset+1)]]"
	    puts "offset = $offset"
	    puts "looking for length at [expr ($offset+1)]"
	    puts "pldata is $pldata"
	    set sporthex [string range $pldata $hdroffset [expr $hdroffset+3]]
	    $sportIcmpDecodeFrame.text insert 0.0 [format "%i" 0x$sporthex]
	    
	    # Dest Port
	    set dporthex [string range $pldata [expr $hdroffset+4] [expr $hdroffset+7]]
	    $dportIcmpDecodeFrame.text insert 0.0 [format "%i" 0x$dporthex]
	    
	    pack $icmpDecodeFrame -after $icmpHdrFrame -fill x
	} else {
            pack forget $icmpDecodeFrame
        }
    } else {
        pack forget $icmpDecodeFrame
    }
	    
}
proc InsertPayloadData { data } {
  global dataText
  if {[lindex $data 0] == ""} { 
    $dataText insert 0.0 "None."
  } else {
    set payload [lindex $data 0]
    set dataLength [string length $payload]
    set asciiStr ""
    set counter 2
    for {set i 1} {$i < $dataLength} {incr i 2} {
      set currentByte [string range $payload [expr $i - 1] $i]
      lappend hexStr $currentByte
      set intValue [format "%i" 0x$currentByte]
      if { $intValue < 32 || $intValue > 126 } {
        # Non printable char
        set currentChar "."
      } else {
        set currentChar [format "%c" $intValue]
      }
      set asciiStr "$asciiStr$currentChar"
      if { $counter == 32 } {
        $dataText insert end "$hexStr $asciiStr\n"
        set hexStr ""
        set asciiStr ""
        set counter 2
      } else {
        incr counter 2
      }
    }
    $dataText insert end "[format "%-47s %s\n" $hexStr $asciiStr]"
  }
  Idle
}

#
# GetCurrentTimeStamp: Returns date/time in YYYYY-MM-DD HH:MM:SS.
#
proc GetCurrentTimeStamp { {clockOption {today} } } {
  set timestamp [clock format [clock scan "$clockOption"] -gmt true -f "%Y-%m-%d %T"]
  return $timestamp
}

# System msgs are pretty bland right now. Would like to add some color tagging.
# By using the syslog facility a whole multitude of sensor status info could
# be scripted and then logged here.
proc InsertSystemInfoMsg { sensorName msg } {
  global systemInfoText messageTabs
  if { [$messageTabs view] != 0 } {
    $messageTabs pageconfigure 0 -foreground red 
  } else {
    $messageTabs pageconfigure 0 -foreground
  }
  set timestamp [GetCurrentTimeStamp]
  $systemInfoText insert end "\n\[$timestamp\] $sensorName: $msg"
  $systemInfoText component text see end
}

#
# GetPaneNameByPriority: Returns the correct RT pane based on priority.
#
proc GetPaneNameByPriority { priority } {
  global rtPaneArray RTPANES RTPANE_PRIORITY
  set paneName $rtPaneArray(0)
  if { $RTPANES > 1 } {
    set x 0
    while { $x < $RTPANES } {
      if { [lsearch -exact $RTPANE_PRIORITY($x) $priority] >= 0 } {
        eval set paneName \$rtPaneArray($x)
        break
      }
      incr x
    }
  }
  return $paneName
}
#
# GetColorByPriority: Returns color based on priority.
#
proc GetColorByPriority { priority } {
  global RTCOLORS RTCOLOR_PRIORITY RTCOLOR_NAME
  set rtColor red
  set x 0
  while { $x < $RTCOLORS } {
    if { [lsearch -exact $RTCOLOR_PRIORITY($x) $priority] >= 0 } {
      eval set rtColor $RTCOLOR_NAME($x)
      break
    }
    incr x
  }
  
  return $rtColor
}

#
# DeleteEventID: Called when server sends the DeleteEventID cmd
#                This is ugly right now. 
#
proc DeleteEventID { eventID } {
  global eventArray correlateArray rtPaneArray escalateFrame
  if { [info exists eventArray($eventID)] } { unset eventArray($eventID) }
  if { [info exists correlateArray($eventID)] } {
    foreach event $correlateArray($eventID) {
      if { [info exists eventArray($event)] } { unset eventArray($event) }
    }
  }
  foreach arrayName [array names rtPaneArray] {
    set eventIDList [$rtPaneArray($arrayName).eventIDFrame.list get 0 end]
    set eventIDIndex [lsearch -exact $eventIDList $eventID]
    if { $eventIDIndex >= 0 } { DeleteLine $rtPaneArray($arrayName) $eventIDIndex }
  }
  set escalatedIDList [$escalateFrame.eventIDFrame.list get 0 end]
  set escalatedIDIndex [lsearch -exact $escalatedIDList $eventID]
  if { $escalatedIDIndex >= 0 } { DeleteLine $escalateFrame $escalatedIDIndex }
}
proc DeleteLine { paneName index } {
  
  foreach childWin [winfo children $paneName] {
    if { [winfo name $childWin] != "scroll" } {
      $childWin.list delete $index
    }
  }
}
proc DeleteEventIDList { eventIDList } {
  foreach eventID $eventIDList {
    DeleteEventID $eventID
  }
}

#
# InsertEvent: Parses eventData, locates the correct windowPane calls DisplayEvent
#
proc InsertEvent { eventData } {
  global DEBUG rtPaneArray eventArray SLEEP SOUND
  if {$SLEEP} { WakeUp }
  set priority [lindex $eventData 1]
  set insertPane [GetPaneNameByPriority $priority]
  set eventID [join [lrange $eventData 5 6] .]
  set status RT
  set count 1
  set sensor [lindex $eventData 3]
  set dateTime [lindex $eventData 4]
  set message [lindex $eventData 7]
  set srcIP [lindex $eventData 8]
  set dstIP [lindex $eventData 9]
  set proto [lindex $eventData 10]
  set srcPort [lindex $eventData 11]
  set dstPort [lindex $eventData 12]
  set statusColor [GetColorByPriority $priority]
  # Add event to eventArray
  set eventArray($eventID) $eventData
  # Check to see if we can correlate this event with another based on srcIP and
  # the signature matched.
  if {![CorrelateEvent $insertPane $eventID $srcIP $message]} {
    DisplayEvent $insertPane $status $priority $count $sensor $dateTime $eventID $message\
     $srcIP $dstIP $proto $srcPort $dstPort $statusColor
    if {$SOUND} { Speak "Alert received from $sensor. $message" }
  }
}
proc CorrelateEvent { paneName eventID srcIP message } {
  global correlateArray ALTCOLORS
  
  set RETURN 0
  set srcIPList [$paneName.srcIPFrame.list get 0 end]
  set messageList [$paneName.msgFrame.list get 0 end]
  # Loop thru the srcIPs for a match
  set srcIPMatchIndex [lsearch -exact $srcIPList $srcIP]
  while {$srcIPMatchIndex >= 0} {
    if {[lindex $messageList $srcIPMatchIndex] == $message} {
      set RETURN 1
      set correlateID [$paneName.eventIDFrame.list get $srcIPMatchIndex]
      lappend correlateArray($correlateID) $eventID
      set eventCount [$paneName.countFrame.list get $srcIPMatchIndex]
      incr eventCount

      # Update the list
      $paneName.countFrame.list delete $srcIPMatchIndex
      $paneName.countFrame.list insert $srcIPMatchIndex $eventCount
      if {$ALTCOLORS} {
        set rowColor [lindex [$paneName.dstIPFrame.list itemconfigure $srcIPMatchIndex -background] 4]
        $paneName.countFrame.list itemconfigure $srcIPMatchIndex -background $rowColor
      }
      # if the list index was selected, re-select it
      if { [$paneName.eventIDFrame.list selection includes $srcIPMatchIndex] } { 
	    $paneName.countFrame.list selection set $srcIPMatchIndex
      }
      break
    }
    set srcIPList [lreplace $srcIPList $srcIPMatchIndex $srcIPMatchIndex FILLER]
    set srcIPMatchIndex [lsearch -exact $srcIPList $srcIP]
  }
  ScrollHome $paneName
  return $RETURN
}

proc GetStatusNameByNumber { status } {
  switch -exact $status {
    1  { set statusName NA }
    2  { set statusName ES }
    11 { set statusName C1 }
    12 { set statusName C2 }
    13 { set statusName C3 }
    14 { set statusName C4 }
    15 { set statusName C5 }
    16 { set statusName C6 }
    17 { set statusName C7 }
    default { set statusName UN }
  }
}
proc InsertQueryResults { paneName results } {
  set queryType [lindex [split [winfo name $paneName] _] 0]
  if { $queryType == "query" } {
    InsertEventQueryResults $paneName $results
  } else {
    InsertSessionQueryResults $paneName $results
  }
}
proc InsertEventQueryResults { paneName results } {
  global CATEGORY_COLOR
  set status [lindex $results 0]
  if { $status == "done" } { $paneName configure -cursor left_ptr; return }
  if { $status == "0" } {
    set status RT
    set statusColor [GetColorByPriority [lindex $results 1]]
  } else {
    set status [GetStatusNameByNumber $status]
    set statusColor $CATEGORY_COLOR($status)
  }
  set sensor [lindex $results 2]
  set dateTime [lindex $results 3]
  set eventID [join [lrange $results 4 5] .]
  set message [lindex $results 6] 
  set srcIP [lindex $results 7]
  set dstIP [lindex $results 8]
  set protocol [lindex $results 9]
  set srcPort [lindex $results 10]
  set dstPort [lindex $results 11]
  DisplayEvent $paneName $status [lindex $results 1] 1 $sensor $dateTime $eventID $message\
   $srcIP $dstIP $protocol $srcPort $dstPort $statusColor
}
proc InsertEscalatedEvent { data } {
  global CATEGORY_COLOR escalateFrame
  set status ES
  set statusColor $CATEGORY_COLOR($status)
  set sensor [lindex $data 3]
  set dateTime [lindex $data 4]
  set eventID [join [lrange $data 5 6] .]
  set message [lindex $data 7] 
  set srcIP [lindex $data 8]
  set dstIP [lindex $data 9]
  set protocol [lindex $data 10]
  set srcPort [lindex $data 11]
  set dstPort [lindex $data 12]
  DisplayEvent $escalateFrame $status [lindex $data 1] 1 $sensor $dateTime $eventID $message\
   $srcIP $dstIP $protocol $srcPort $dstPort $statusColor
}
proc InsertSessionQueryResults { paneName results } {
  global ALTCOLORS COLOR1 COLOR2 COLOR3
 
  if { $results == "done" } { $paneName configure -cursor left_ptr; return }

  if {$ALTCOLORS} {
    if { [$paneName.sensorFrame.list size] == 0 } {
      set backgroundColor $COLOR1
    } else {
      set lastBackgroundColor [lindex [$paneName.sensorFrame.list itemconfigure end -background] 4]
      if {$lastBackgroundColor == "$COLOR1"} {
        set backgroundColor "$COLOR2"
      } elseif { $lastBackgroundColor == "$COLOR2" } {
        set backgroundColor "$COLOR3"
      } else {
        set backgroundColor "$COLOR1"
      }
    }
  }

  set i 0
  foreach childWin [winfo children $paneName] {
    if { [winfo name $childWin] != "scroll" } {
      $childWin.list insert end [lindex $results $i]
      if {$ALTCOLORS} {
        # Waste resources for alternating colors this can be a hog when insert 500+ events
        $childWin.list itemconfigure end -background "$backgroundColor"
      }
      incr i
    }
  }
}

#
# DisplayEvent: inserts events into the GUI
#
proc DisplayEvent { paneName status priority count sensor dateTime eventID message srcIP\
 dstIP proto srcPort dstPort statusColor } {
  
  global ALTCOLORS COLOR1 COLOR2 COLOR3

  if {$ALTCOLORS} {
    if { [$paneName.countFrame.list size] == 0 } {
      set backgroundColor $COLOR1
    } else {
      set lastBackgroundColor [lindex [$paneName.countFrame.list itemconfigure end -background] 4]
      if {$lastBackgroundColor == "$COLOR1"} {
        set backgroundColor "$COLOR2"
      } elseif { $lastBackgroundColor == "$COLOR2" } {
        set backgroundColor "$COLOR3"
      } else {
        set backgroundColor "$COLOR1"
      }
    }
  }
  foreach childWin [winfo children $paneName] {
    set winName [winfo name $childWin]
    switch -exact  $winName {
      statusFrame   {
                      $childWin.list insert end $status
                      $childWin.list itemconfigure end -background $statusColor -selectforeground $statusColor
                     }
      priorityFrame { $childWin.list insert end $priority }
      countFrame    { $childWin.list insert end $count}
      sensorFrame   { $childWin.list insert end $sensor}
      eventIDFrame  { $childWin.list insert end $eventID}
      dateTimeFrame { $childWin.list insert end $dateTime}
      srcIPFrame    { $childWin.list insert end $srcIP}
      srcPortFrame  { $childWin.list insert end $srcPort}
      dstIPFrame    { $childWin.list insert end $dstIP}
      dstPortFrame  { $childWin.list insert end $dstPort}
      protoFrame    { $childWin.list insert end $proto}
      msgFrame      { $childWin.list insert end $message}
      default { set nadda nothing }
    }
    if {$ALTCOLORS && $winName != "statusFrame" && $winName != "scroll"} {
      # Waste resources for alternating colors this can be a hog when insert 500+ events
      $childWin.list itemconfigure end -background "$backgroundColor"
    }
  }
  ScrollHome $paneName
  
}

proc UnSelectHostLookups {} {
  global whoisNoneButton dnsButton
  $whoisNoneButton invoke
  $dnsButton deselect
  ClearDNSText
}
#
# UnSelectAllOptions:  Used when ESC is hit or on a multiple selection to turn off packet details, etc
#
proc UnSelectPacketOptions { } {
  global displayPacketButton displayRuleButton referenceButton displayPSButton
  $displayPacketButton deselect
  ClearPacketData
  $displayRuleButton deselect
  ClearRuleText
  $referenceButton configure -state disabled
  ClearPSLists
  $displayPSButton deselect
}
#
# ScrollHome: If ScrollHome var is set, move the scrollbar to the bottom of the list
#
proc ScrollHome { paneName } {
  global SCROLL_HOME
  if {$SCROLL_HOME($paneName)} {
    foreach childWin [winfo children $paneName] {
      if { [winfo name $childWin] != "scroll" } {
        $childWin.list see end
      }
    }
  }
}

#
# BindSelectionToAllLists: Grabs button-1 events and make sure that a list is
#                          selected across all lists.
#
proc BindSelectionToAllLists { listName } {
    foreach buttonEvent { "Shift-Button-1" } {
	bind $listName <$buttonEvent> { ShiftSelect %W [%W nearest %y]; break }
    }
    foreach buttonEvent { "Control-Button-1" } {
	bind $listName <$buttonEvent> { CtrlSelect %W [%W nearest %y]; break }
    }
    foreach buttonEvent { "Button-1" } {
        bind $listName <$buttonEvent> { SingleSelect %W [%W nearest %y]; break }
    }
    foreach buttonEvent { "B1-Motion" "Control-B1-Motion" } {
	bind $listName <$buttonEvent> { MotionSelect %W [%W nearest %y]; break }
    }
    foreach buttonEvent { "ButtonRelease-1" } {
	bind $listName <$buttonEvent> { ReSetMotion }
    }
    foreach buttonEvent { "MouseWheel" "Button-5" "Button-4" } {
	bind $listName <$buttonEvent> { WheelScroll %D %W "Button"; break }
    }
}    
proc BindSelectionToAllPSLists { listName } {

    foreach buttonEvent { "MouseWheel" "Button-5" "Button-4" } {
	    bind $listName <$buttonEvent> { WheelScroll %D %W "Button"; break }
	}
}
#
# WheelScroll: Scroll all of the lists together on a mousey-wheely-scrolly
#
proc WheelScroll { delta winName source } {
    global SCROLL_HOME
    if { $source == "Button" } {
	set parentWin [winfo parent [winfo parent $winName]]
    } else {
	set parentWin $winName
    }
    set SCROLL_HOME($parentWin) 0
    # first we have to support Windows and X
    # Windows will trigger on MouseWheel events and delta will be high (at least more than 10)
    # if it is a negative number, then we are looking a a MouseWheel event
    # XWindows (in most cases generate Button-4 or -5 events and delta will be 4 or 5
    
    # X-Windows wheel motion
    if { $delta == 4 || $delta == 5 } {
	if { $delta == 4 } { set move -3 }
	if { $delta == 5 } { set move 3 }
    } else {
	# MouseWheel Motion (usually Windows generated)
	if { $delta > 0 } { set move -3 }
	if { $delta < 0 } { set move 3}
	if { $delta == 0 } { break } 
    }
    foreach childWin [winfo children $parentWin] {
	if { [winfo name $childWin] != "scroll" } {
	    $childWin.list yview scroll $move units
	}
    }
    # check scrollbar position, if at the bottom, toggle SCROLL_HOME
    set scrollbarPosition [lindex [$parentWin.scroll get] 1]
    if {$scrollbarPosition == 1.0} {set SCROLL_HOME($parentWin) 1}
}

#
# ReSetMotion: Reset Motion Vars on a button release
#
proc ReSetMotion {} {
    global MotionStart MotionLoxIndex MotionHighIndex MOVEMENT_DIR
    set MotionStart -1
    set MotionHighIndex -1
    set MotionLowIndex -1
    set MOVEMENT_DIR ""
}
#
# ShiftSelect: Enable MultiSelection using shift-click
#
proc ShiftSelect { winName index } {
    global MULTI_SELECT currentSelectedPane LASTINDEXSELECTED MOVEMENT_DIR BUSY
    # If we are busy then abort.
    if {$BUSY} { bell; return }
    # check to see if we are in a new pane and if so, error.
    if { [info exists currentSelectedPane] && [winfo parent [winfo parent $winName]] != $currentSelectedPane } {
	ErrorMessage "You may only shift-select from within the same event pane."
	return
    }
    # check to see if anything is currently selected, if no this is basically a single select
    if { [llength [$winName curselection]] < 1 } {
	SingleSelect $winName $index
	return
    }
    set MULTI_SELECT 1
    UnSelectPacketOptions
    UnSelectHostLookups
    # Check to see if the current index is higher or lower that the LASTSELECTEDINDEX
    if { $index > $LASTINDEXSELECTED } {
	set MOVEMENT_DIR "shift"
	foreach childWin [winfo children $currentSelectedPane] {
	      if { [winfo name $childWin] != "scroll" } {
		  $childWin.list select clear 0 end
	      }
	  }
	  HighLightListLine $currentSelectedPane $index $LASTINDEXSELECTED 
	  return
      } else {
	  set MOVEMENT_DIR "shift"
	  foreach childWin [winfo children $currentSelectedPane] {
	      if { [winfo name $childWin] != "scroll" } {
		  $childWin.list select clear 0 end
	      }
	  }
	  HighLightListLine $currentSelectedPane $index $LASTINDEXSELECTED 
	  return
      }
}
    
    
#
# MotionSelect: Enable selection of multiple rows using button-1 motion
#
proc MotionSelect { winName index } {
  global currentSelectedPane MULTI_SELECT MotionHighIndex MotionLowIndex MotionStart MOVEMENT_DIR
  global BUSY

  # If we are busy then abort.
  if {$BUSY} { bell; return }

  # check to see if we are in a new pane and if so, error.
  if { [info exists currentSelectedPane] && [winfo parent [winfo parent $winName]] != $currentSelectedPane } {
    ErrorMessage "You may only control-select from within the same event pane."
    return
  }
  # Check to see if something is currently selected
  # If so, this is going to add to the selection and set MULTI_SELECT to 1
  # If this is the first selection, it is essentially the same as clicking w/o the ctrl
  # and Multi-select should stay at 0
  if { [llength [$winName curselection]] > 0 } {
    set MULTI_SELECT 1 
  } else {
    # If this is the first item selected then treat as a SingleSelect
    SingleSelect $winName $index
    return
  }
  #  Motion events will always select consecutive indicies.  The click or ctrl-click
  # at the start of the motion will be either the high or the low.  When motion begins
  # we will set $MotionIndexHigh and $MotionIndexLow to the index that motion started on
  # but won't select or deselect it.  That should already have been done by the click.
  if { $MotionHighIndex == -1 } {
      set MotionHighIndex $index
      set MotionLowIndex $index
      set MotionStart $index
      return
  }
  # If the current index is the same as MotionStart we either haven't moved and only the
  # index at MotionStart should be selected.  So lets do a singleselect.  I know that this breaks
  # a user adding to a selection made with a ctrl-click, but deal with it.
  if { $index == $MotionStart } {
      SingleSelect $winName $index
      set MotionHighIndex $index
      set MotionLowIndex $index
      return
  }
  # Check to see if the current index falls between our existing low and High indices
  # if it does, we turned around
  if { $index > $MotionLowIndex && $index < $MotionHighIndex && $index != $MotionStart} {
      # Were we going up and turned down?
      if { $MotionHighIndex == $MotionStart } {
	  #unselect everything between the current index and the old MotionLowIndex
	  foreach childWin [winfo children $currentSelectedPane] {
	      if { [winfo name $childWin] != "scroll" } {
		  $childWin.list select clear $MotionLowIndex [expr $index-1]
	      }
	  }
	  # Set the new low to the current index
	  set MotionLowIndex $index
	 
      }
      # Were we going down and turned up?
      if { $MotionLowIndex == $MotionStart } {
	  #unselect everything between the current index and the old MotionHighIndex
	  foreach childWin [winfo children $currentSelectedPane] {
	      if { [winfo name $childWin] != "scroll" } {
		  $childWin.list select clear [expr $index+1] $MotionHighIndex
	      }
	  }
	  # Set the new High to the current index
	  set MotionHighIndex $index
      }
  }
  # If MotionIndexHigh/Low are set then this is not the first event.  Check the index to see
  # which direction the motion is going
  set MULTI_SELECT 1
  UnSelectPacketOptions
  UnSelectHostLookups
  if { $index > $MotionHighIndex } {
      set MotionHighIndex $index
      set MOVEMENT_DIR down
  }
  if { $index < $MotionLowIndex } {
      set MotionLowIndex $index
      set MOVEMENT_DIR up
  }
  # Select everything between high and low
  if { $MOVEMENT_DIR == "down" } {
        HighLightListLine $currentSelectedPane $MotionHighIndex $MotionLowIndex
  } else {
        HighLightListLine $currentSelectedPane $MotionLowIndex $MotionHighIndex
  }
    
  return
}



#
# CtrlSelect:  Enables selection of multiple rows using ctrl-click
#
proc CtrlSelect { winName index } {
  global currentSelectedPane MULTI_SELECT LASTINDEXSELECTED BUSY

  # If we are busy then abort.
  if {$BUSY} { bell; return }

  # Check to see if we are in a new pane and if so, error.
  if { [info exists currentSelectedPane] && [winfo parent [winfo parent $winName]] != $currentSelectedPane } {
    ErrorMessage "You may only control-select from within the same event pane."
    return
  }
  # Check to see if something is currently selected
  # If so, this is going to add to the selection and set MULTI_SELECT to 1
  # If this is the first selection, it is essentially the same as clicking w/o the ctrl
  # and Multi-select should stay at 0
  if { [llength [$winName curselection]] > 0 } {
    set MULTI_SELECT 1 
  } else {
    # If this is the first item selected then treat as a SingleSelect
    SingleSelect $winName $index
    return
  }
  # If ctrl-clicking an already selected event we should unselect it
  if { [$winName selection includes $index] == 1 } {
        foreach childWin [winfo children $currentSelectedPane] {
	  if { [winfo name $childWin] != "scroll" } {
	      $childWin.list select clear $index
	  }
      }
      return

  }
  # save the index in $LASTINDEXSELECTED
  set LASTINDEXSELECTED $index
  SelectAllLists $winName $index
}

#
# SingleSelect:  Selects a single row
#
proc SingleSelect { winName index } {
  global currentSelectedPane ACTIVE_EVENT MULTI_SELECT LASTINDEXSELECTED BUSY

  # If we are busy then abort.
  if {$BUSY} { bell; return }

  # On a right click, we could be called in on event that has
  # already been highlighted. We check so that we don't have to
  # go and get the whois etc info
  if { !$MULTI_SELECT && $ACTIVE_EVENT} {
    if { [$winName selection includes $index] } { 
      return
    }
  }

  set MULTI_SELECT 0 
  # Unhighlight anything that is highlighted
  if {[info exists currentSelectedPane]} {
    UnHighLightListLine $currentSelectedPane
  }
  # Save index in $LASTINDEXSELECTED
  set LASTINDEXSELECTED $index
  # Run SelectAllLists
  SelectAllLists $winName $index
}

proc SelectNextEvent { paneName index } {
    global ACTIVE_EVENT
  set listSize [$paneName.eventIDFrame.list size]
  if { $listSize == 0 } { set ACTIVE_EVENT 0; return }
  if { $index < $listSize  } {
    SelectAllLists $paneName.eventIDFrame.list $index
  } elseif { $index > 0 } {
    SelectAllLists $paneName.eventIDFrame.list [expr $index - 1]
  }
}

#
# SelectAllLists: Highlight all lists and update event data info.
#
proc SelectAllLists { winName index } {
  global MULTI_SELECT currentSelectedPane ACTIVE_EVENT DISPLAYEDDETAIL portscanDataFrame packetDataFrame
  global SSN_QUERY

  set ACTIVE_EVENT 1
  set currentSelectedPane [winfo parent [winfo parent $winName]]
  if { $index < 0 } {
    set ACTIVE_EVENT 0
    return
  }
 
  HighLightListLine $currentSelectedPane $index $index


  # Check to see if we are working with a session query tab
  if {[lindex [ split [winfo name $currentSelectedPane] _] 0] == "ssnquery" } { 
    set SSN_QUERY 1 
  } else {
    set SSN_QUERY 0
  }

#
# We don't want any detail displayed if this is a multi-select
# So lets stick this below bit in a conditional
#
  if { !$MULTI_SELECT } {
    if {$SSN_QUERY} {
      UnSelectPacketOptions
    } else {
      #puts [regexp "^spp_portscan:" [$currentSelectedPane.msgFrame.list get $index]]
      if { [regexp "^spp_portscan:" [$currentSelectedPane.msgFrame.list get $index]] } {
        if { $DISPLAYEDDETAIL != $portscanDataFrame } {
          pack forget $packetDataFrame
          pack $portscanDataFrame -fill both -expand true
        }
        set DISPLAYEDDETAIL $portscanDataFrame
        DisplayPortscanData
      } else {
        if { $DISPLAYEDDETAIL != $packetDataFrame } {
          pack forget $portscanDataFrame
          pack $packetDataFrame -fill both -expand true
          set DISPLAYEDDETAIL $packetDataFrame
        }
        DisplayPacketHdr $currentSelectedPane $index
        GetRuleInfo
        GetPacketInfo
      }
    }
    ResolveHosts
    GetWhoisData
  } else {
      UnSelectPacketOptions
      UnSelectHostLookups
  }
      
  
}
#
# DisplayPacketHdr: Determines the correct hdr to display (tcp/udp/icmp).
#
proc DisplayPacketHdr { paneName index } {
  global DISPLAYEDHDR tcpHdrFrame udpHdrFrame icmpHdrFrame ipHdrFrame icmpDecodeFrame
  set proto [$paneName.protoFrame.list get $index]
  if {$proto == 1} {
    set newHdr $icmpHdrFrame
  } elseif {$proto == 17} {
    set newHdr $udpHdrFrame
  } else {
    set newHdr $tcpHdrFrame
  }
  # Hide the ICMP DECODE frame if it was displayed and we don't need it anymore.
  if { $DISPLAYEDHDR == $icmpHdrFrame && $newHdr != $icmpHdrFrame } {
    pack forget $icmpDecodeFrame
  }
  if { $DISPLAYEDHDR != $newHdr } {
    pack forget $DISPLAYEDHDR
    pack $newHdr -after $ipHdrFrame -fill x
    set DISPLAYEDHDR $newHdr
  }
}

#
# UnHighLightListLine: Unhighlight currently highlighted line.
#
proc UnHighLightListLine { paneName } {
  if { [winfo exists $paneName] } {
    foreach childWin [winfo children $paneName] {
      if { [winfo name $childWin] != "scroll" } {
        $childWin.list select clear 0 end
      }
    }
  }
}

#
# HighLightListLine: Highlight all the lists.
# paneName = current pane name
# index = current index
# lastindex = other index for multi-selects.  If this is a single select
# put the same value as index
proc HighLightListLine { paneName index lastindex } {
  global MOVEMENT_DIR
  set activeIndex [$paneName.sensorFrame.list index active]
  foreach childWin [winfo children $paneName] {
    if { [winfo name $childWin] != "scroll" } {
      #$childWin.list select clear 0 end
      #$childWin.list select anchor $index
      #$childWin.list select set anchor $index
      $childWin.list activate $index
	if { $index > $lastindex } {
	    $childWin.list select set $lastindex $index 
	} else {
	    $childWin.list select set $index $lastindex
	}
	
	if { $MOVEMENT_DIR == "down" } {
	    $childWin.list see [expr $index+1]
	} elseif { $MOVEMENT_DIR == "up" } {
	    $childWin.list see [expr $index-1]
	} elseif { $MOVEMENT_DIR == "shift" } {
	    # do nothing
	} else {
	    $childWin.list see $index
	}
      $childWin.list itemconfigure $activeIndex -foreground black
    }
  }
}
proc CleanExit {} {
  puts "Goodbye."
  exit
}
proc InfoMessage { message } {
    puts $message
    tk_messageBox -type ok -icon info -message "$message"
}
proc ErrorMessage { message } {
    puts $message
    tk_messageBox -type ok -icon warning -message "$message"
}
proc ClearPSLists {} {
  global portscanLabelListFrame
  foreach listName [winfo children $portscanLabelListFrame] {
    if { [winfo name $listName] != "scroll" } {
      $listName.list delete 0 end
    }
  }
}
proc DisplayPortscanData {} {
  global ACTIVE_EVENT PSINFO currentSelectedPane DEBUG socketID portscanDataFrame MULTI_SELECT
  global CONNECTED psMaxRows MAX_PS_ROWS
  ClearPSLists
  if {$ACTIVE_EVENT && $PSINFO && !$MULTI_SELECT} {
    if {!$CONNECTED} {
      ErrorMessage "Not connected to sguild. Cannot request portscan data."
      return 
    }
    $psMaxRows configure -state normal
    set selectedIndex [$currentSelectedPane.srcIPFrame.list curselection]
    set srcIP [$currentSelectedPane.srcIPFrame.list get $selectedIndex]
    set timestamp [lindex [$currentSelectedPane.dateTimeFrame.list get $selectedIndex] 0]
    SendToSguild "GetPSData $timestamp $srcIP $MAX_PS_ROWS"
    $portscanDataFrame configure -cursor watch
  } elseif { !$PSINFO } {
    $psMaxRows configure -state disabled
  }
    
}
proc InsertPSData { data } {
  global portscanDataFrame portscanLabelListFrame
  if { $data == "DONE" } { 
    $portscanDataFrame configure -cursor left_ptr
    return
  }
  set i 0
  foreach listName [winfo children $portscanLabelListFrame] {
    if { [winfo name $listName] != "scroll" } {
      $listName.list insert end [lindex $data $i]
      incr i
    }
  }
}
proc GetPacketInfo {} {
  global ACTIVE_EVENT PACKETINFO currentSelectedPane socketID DEBUG MULTI_SELECT SSN_QUERY
  global CONNECTED
  ClearPacketData
  if {$ACTIVE_EVENT && $PACKETINFO && !$MULTI_SELECT && !$SSN_QUERY} {
    if {!$CONNECTED} {
      ErrorMessage "Not connected to sguild. Cannot make a request for packet data."
      return
    }
    Working
    update
    set selectedIndex [$currentSelectedPane.eventIDFrame.list curselection]
    set eventID [$currentSelectedPane.eventIDFrame.list get $selectedIndex]
    set protocol [$currentSelectedPane.protoFrame.list get $selectedIndex]
    set sid [lindex [split $eventID .] 0]
    set cid [lindex [split $eventID .] 1]
    SendToSguild "GetIPData $sid $cid"
    if {$protocol == 17 } {
      SendToSguild "GetUdpData $sid $cid"
    } elseif { $protocol == 1 } {
      SendToSguild "GetIcmpData $sid $cid"
    } else {
      SendToSguild "GetTcpData $sid $cid"
    }
    SendToSguild "GetPayloadData $sid $cid"
  }
}
proc GetRuleInfo {} {
  global currentSelectedPane ACTIVE_EVENT SHOWRULE socketID DEBUG referenceButton MULTI_SELECT SSN_QUERY
  global CONNECTED eventArray
  ClearRuleText
  if {$ACTIVE_EVENT && $SHOWRULE && !$MULTI_SELECT && !$SSN_QUERY} {
    if {!$CONNECTED} {
      ErrorMessage "Not connected to sguild. Cannot make rule request."
      return
    }
    set selectedIndex [$currentSelectedPane.msgFrame.list curselection]
    puts "DEBUG :: $eventArray([$currentSelectedPane.eventIDFrame.list get $selectedIndex])"
    set message [$currentSelectedPane.msgFrame.list get $selectedIndex]
    set sensorName [$currentSelectedPane.sensorFrame.list get $selectedIndex]
    if {$DEBUG} {puts  "RuleRequest $sensorName $message"}
    SendToSguild "RuleRequest $sensorName $message"
  } else {
    $referenceButton configure -state disabled
  }
}
proc ClearRuleText {} {
  global ruleText
  $ruleText clear
}
proc InsertRuleData { ruleData } {
  global ruleText referenceButton
  $ruleText component text insert end $ruleData
  $referenceButton configure -state normal
}
proc GetDshieldIP { arg } {
  global DEBUG BROWSER_PATH currentSelectedPane ACTIVE_EVENT MULTI_SELECT
  if { $ACTIVE_EVENT && !$MULTI_SELECT} {
    set selectedIndex [$currentSelectedPane.srcIPFrame.list curselection]
    if { $arg == "srcip" } {
      set ipAddr [$currentSelectedPane.srcIPFrame.list get $selectedIndex]
    } else {
      set ipAddr [$currentSelectedPane.dstIPFrame.list get $selectedIndex]
    }
    if {[file exists $BROWSER_PATH] && [file executable $BROWSER_PATH]} {
	exec $BROWSER_PATH http://www.dshield.org/ipinfo.php?ip=$ipAddr &
    } else {
      tk_messageBox -type ok -icon warning -message\
       "$BROWSER_PATH does not exist or is not executable. Please update the BROWSER_PATH variable\
        to point your favorite browser."
      puts "Error: $BROWSER_PATH does not exist or is not executable."
    }
  }
}
proc GetDshieldPort { arg } {
  global DEBUG BROWSER_PATH currentSelectedPane ACTIVE_EVENT MULTI_SELECT
  if { $ACTIVE_EVENT && !$MULTI_SELECT} {
    set selectedIndex [$currentSelectedPane.srcPortFrame.list curselection]
    if { $arg == "srcport" } {
      set ipPort [$currentSelectedPane.srcPortFrame.list get $selectedIndex]
    } else {
      set ipPort [$currentSelectedPane.dstPortFrame.list get $selectedIndex]
    }
    if {[file exists $BROWSER_PATH] && [file executable $BROWSER_PATH]} {
	exec $BROWSER_PATH http://www.dshield.org/port_report.php?port=$ipPort &
    } else {
      tk_messageBox -type ok -icon warning -message\
       "$BROWSER_PATH does not exist or is not executable. Please update the BROWSER_PATH variable\
        to point your favorite browser."
      puts "Error: $BROWSER_PATH does not exist or is not executable."
    }
  }
}
proc GetReference {} {
  global DEBUG ruleText BROWSER_PATH
  
  set signature [$ruleText get 0.0 end]
  # parse the sig for the sid
  regexp {sid:\s*([0-9]+)\s*;} $signature match sid
  if {$sid > 1000000} {
    # Local Rule
    tk_messageBox -type ok -icon warning -message\
     "Sid $sid is a locally managed signature/rule."
    puts "Error: Sid $sid is a locally managed signature/rule."
  } elseif { $sid <= 100 } {
    tk_messageBox -type ok -icon warning -message\
     "Sid $sid is reserved for future use. Is there an error in the sig file?"
    puts "Error: Sid $sid is reserved for future use. Error?."
  } else {
    if {[file exists $BROWSER_PATH] && [file executable $BROWSER_PATH]} {
      exec $BROWSER_PATH http://www.snort.org/snort-db/sid.html?sid=$sid &
      if {$DEBUG} {puts "$BROWSER_PATH http://www.snort.org/snort-db/sid.html?sid=$sid launched."}
    } else {
      tk_messageBox -type ok -icon warning -message\
       "$BROWSER_PATH does not exist or is not executable. Please update the BROWSER_PATH variable\
        to point your favorite browser."
      puts "Error: $BROWSER_PATH does not exist or is not executable."
    }
  }
}
#
# DnsButtonActy: Called when the reverse DNS button is released
#
proc ResolveHosts {} {
  global REVERSE_DNS currentSelectedPane ACTIVE_EVENT MULTI_SELECT
  ClearDNSText
  if {$REVERSE_DNS && $ACTIVE_EVENT && !$MULTI_SELECT} {
    Working
    update
    set selectedIndex [$currentSelectedPane.srcIPFrame.list curselection]
    set srcIP [$currentSelectedPane.srcIPFrame.list get $selectedIndex]
    set dstIP [$currentSelectedPane.dstIPFrame.list get $selectedIndex]
    set srcName [GetHostbyAddr $srcIP]
    set dstName [GetHostbyAddr $dstIP]
    InsertDNSData $srcIP $srcName $dstIP $dstName
    Idle
  }
}
proc GetWhoisData {} {
  global ACTIVE_EVENT currentSelectedPane WHOISLIST whoisText WHOIS_PATH MULTI_SELECT
  ClearWhoisData
  if {$ACTIVE_EVENT && $WHOISLIST != "none" && !$MULTI_SELECT} {
    Working
    update
    set selectedIndex [$currentSelectedPane.$WHOISLIST.list curselection]
    set ip [$currentSelectedPane.$WHOISLIST.list get $selectedIndex]
    if { $WHOIS_PATH == "SimpleWhois" } {
      foreach line [SimpleWhois $ip] {
        $whoisText insert end "$line\n"
      }
    } else {
      $whoisText insert end "Attempting whois query on $ip\n"
      update
      set whoisCommandID [open "| $WHOIS_PATH $ip" r]
      while { [gets $whoisCommandID data] >= 0 } {
        $whoisText insert end "$data\n"
      }
      catch {close $whoisCommandID} closeError
      $whoisText insert end $closeError
    }
    Idle
  }
}
#
# GetHostbyAddr: uses extended tcl (wishx) to get an ips hostname
#                May move to a server func in the future
#
proc GetHostbyAddr { ip } {
  if [catch {host_info official_name $ip} hostname] {
    set hostname "Unknown"
  }
  return $hostname
}
#
# ClearDNSText: Clears the src/dst dns results
#
proc ClearDNSText {} {
  global srcDnsDataEntryTextFrame dstDnsDataEntryTextFrame
  foreach i "nameText ipText" {
    $srcDnsDataEntryTextFrame.$i delete 0.0 end
    $dstDnsDataEntryTextFrame.$i delete 0.0 end
  }
} 
proc InsertDNSData { srcIP srcName dstIP dstName} {
  global srcDnsDataEntryTextFrame dstDnsDataEntryTextFrame
  $srcDnsDataEntryTextFrame.ipText insert 0.0 $srcIP
  $srcDnsDataEntryTextFrame.nameText insert 0.0 $srcName
  $dstDnsDataEntryTextFrame.ipText insert 0.0 $dstIP
  $dstDnsDataEntryTextFrame.nameText insert 0.0 $dstName
}
proc ClearWhoisData {} {
  global whoisText
  $whoisText delete 0.0 end
}
proc MultiScrollBar { scroll_list args } {
  set len [llength $scroll_list]
  for { set i 0 } { $i < $len } {incr i} {
    set temp_list [lindex $scroll_list $i]
    eval $temp_list yview $args
  }
}
proc CreateXscriptWin { winName } {
  toplevel $winName
  menubutton $winName.menubutton -underline 0 -text File -menu $winName.menubutton.menu
  menu $winName.menubutton.menu -tearoff 0
  $winName.menubutton.menu add command -label "Save As" -command "SaveXscript $winName"
  $winName.menubutton.menu add command -label "Close Window" -command "destroy $winName"
  scrolledtext $winName.sText -vscrollmode dynamic -hscrollmode dynamic -wrap word\
   -visibleitems 85x30 -sbwidth 10
  $winName.sText tag configure srcTag -foreground blue
  $winName.sText tag configure dstTag -foreground red
  scrolledtext $winName.debug -vscrollmode dynamic -hscrollmode none -wrap word\
   -visibleitems 85x5 -sbwidth 10 -labeltext "Debug Messages" -textbackground lightblue
  pack $winName.menubutton -side top -anchor w
  pack $winName.sText $winName.debug -side top -fill both -expand true
}
proc InsertXscriptData { winName state data } {
  global XSCRIPTDATARCVD
  if { ! [winfo exist $winName] } {
    CreateXscriptWin $winName
  }
  #puts $XSCRIPTDATARCVD($winName)
  if {! $XSCRIPTDATARCVD($winName)} {
    $winName.sText clear
    $winName configure -cursor left_ptr
    set XSCRIPTDATARCVD($winName) 1
  }
  if { $state == "HDR" } {
    $winName.sText component text insert end "$data\n"
  } elseif { $state == "SRC" } {
    $winName.sText component text insert end "$state: $data\n" srcTag
  } elseif { $state == "DST" } { 
    $winName.sText component text insert end "$state: $data\n" dstTag
  } elseif { $state == "ERROR" } {
    puts "data: $data"
    if { $data != "" } {
      ErrorMessage "$data"
    }
  } else {
    $winName.debug component text insert end "$data\n"
    $winName.debug see end
  } 
}
proc XscriptServerCmdRcvd { socketID } {
    global DEBUG XSCRIPT_STATE SESSION_STATE socketWinName
  if { [eof $socketID] || [catch {gets $socketID data}] } {
    close $socketID
    if {$DEBUG} {puts "Socket $socketID closed."}
  } else {
    if {$DEBUG} {puts "Client Command: $data"}
    switch -exact -- $data {
      HDR { set SESSION_STATE($socketID) HDR }
      SRC { set SESSION_STATE($socketID) SRC }
      DST { set SESSION_STATE($socketID) DST }
      DEBUG { set SESSION_STATE($socketID) DEBUG }
      DONE { close $socketID; unset SESSION_STATE($socketID); unset socketWinName($socketID) }
      ERROR { set SESSION_STATE($socketID) ERROR }
      default { InsertXscriptData $socketWinName($socketID) $SESSION_STATE($socketID) $data }
    }
  }
}
proc GetXscript { type force } {
  global ACTIVE_EVENT SERVERHOST XSCRIPT_SERVER_PORT DEBUG currentSelectedPane XSCRIPTDATARCVD
  global socketWinName SESSION_STATE SSN_QUERY ETHEREAL_STORE_DIR
  global OPENSSL VERSION
  if {!$ACTIVE_EVENT} {return}
  set winName $currentSelectedPane.sensorFrame.list
  set eventIndex [$winName curselection]
  set winParents [winfo parent [winfo parent $winName]]
  if {$SSN_QUERY} {
    set cnxID [$winParents.xidFrame.list get $eventIndex]
    set timestamp [$winParents.startTimeFrame.list get $eventIndex]
    set proto 6
  } else {
    set proto [$winParents.protoFrame.list get $eventIndex]
    if { $type == "xscript" && $proto != "6" } {
      tk_messageBox -type ok -icon warning -message\
       "Transcripts can only be generated for TCP traffic at this time."
      return
    }
    set cnxID [lindex [split [$winParents.eventIDFrame.list get $eventIndex] .] 1]
    set timestamp [$winParents.dateTimeFrame.list get $eventIndex]
  }
  set sensor [$winParents.sensorFrame.list get $eventIndex]
  set srcIP [$winParents.srcIPFrame.list get $eventIndex]
  set srcPort [$winParents.srcPortFrame.list get $eventIndex]
  set dstIP [$winParents.dstIPFrame.list get $eventIndex]
  set dstPort [$winParents.dstPortFrame.list get $eventIndex]
  set xscriptWinName ".${sensor}_${cnxID}"
  if [catch {set socketID [socket $SERVERHOST $XSCRIPT_SERVER_PORT]}] {
    if {$DEBUG} {puts "Unable to connect to xscript server $SERVERHOST on port $XSCRIPT_SERVER_PORT."}
  } else {
    # Version check
    if {$OPENSSL} {
      set tmpVERSION "$VERSION OPENSSL ENABLED"
    } else {
      set tmpVERSION "$VERSION OPENSSL DISABLED"
    }     
    if [catch {gets $socketID} serverVersion] {
      puts "ERROR: $serverVersion"
      return -code error "$serverVersion"
    }
    if { $serverVersion != $tmpVERSION } {
      ErrorMessage "Mismatched versions with xscriptd.\nSERVER: ($serverVersion)\nCLIENT: ($tmpVERSION)"
      return
    }
    puts $socketID $tmpVERSION
    if {$OPENSSL} {
      tls::import $socketID
    }
    if { $type == "xscript"} {
      fconfigure $socketID -buffering line
      fileevent $socketID readable [list XscriptServerCmdRcvd $socketID]
      if {$DEBUG} {
        puts "Xscript Request sent: $sensor $xscriptWinName \{$timestamp\} $srcIP $srcPort $dstIP $dstPort $force"
      }
      #set xscriptWinName ".[join [split $eventID .] _]"
      set socketWinName($socketID) $xscriptWinName
      set SESSION_STATE($socketID) HDR
      CreateXscriptWin $xscriptWinName
      $xscriptWinName.debug component text insert 0.0\
       "Your request has been sent to the server.\nPlease be patient as this can take some time.\n"
      $xscriptWinName configure -cursor watch
      set XSCRIPTDATARCVD($xscriptWinName) 0
      puts $socketID "XscriptRequest $sensor $xscriptWinName \{$timestamp\} $srcIP $srcPort $dstIP $dstPort $force"
      
    } elseif { $type == "ethereal" } {
      if { $proto != "1" } {
        if { $srcPort > $dstPort } {
          set tmpFile "$ETHEREAL_STORE_DIR/${dstIP}_${dstPort}-${srcIP}_${srcPort}-${proto}.raw"
        } else {
          set tmpFile "$ETHEREAL_STORE_DIR/${srcIP}_${srcPort}-${dstIP}_${dstPort}-${proto}.raw"
        }
      } else {
        set tmpFile "$ETHEREAL_STORE_DIR/${srcIP}_${dstIP}-${proto}.raw"
      }
      set tmpFileID [open $tmpFile w]
      fconfigure $tmpFileID -translation binary
      fconfigure $socketID -translation binary
      fileevent $socketID readable [list CopyRawData $socketID $tmpFileID $tmpFile]
      if {$DEBUG} {
        puts "Ethereal Request sent: $sensor $xscriptWinName \{$timestamp\} $srcIP \{$srcPort\} $dstIP \{$dstPort\} $proto $force"
      }
      puts $socketID "EtherealRequest $sensor $xscriptWinName \{$timestamp\} $srcIP \{$srcPort\} $dstIP \{$dstPort\} $proto $force"
      flush $socketID
    }
  }
}
proc CopyDone { socketID tmpFileID tmpFile bytes {error {}} } {
  global DEBUG ETHEREAL_PATH
  close $tmpFileID
  close $socketID
  if {$DEBUG} {puts "Bytes Transfered: $bytes"}
  if { $bytes == 0 } { 
    ErrorMessage "No data available." 
    file delete $tmpFileID
  } else {
    eval exec $ETHEREAL_PATH -n -r $tmpFile &
    InfoMessage "Raw file is stored in $tmpFile. Please delete when finished"
  }
}
proc CopyRawData { socketID tmpFileID tmpFile } {
  catch {fcopy $socketID $tmpFileID -command [list CopyDone $socketID $tmpFileID $tmpFile]} dataError
}
proc SaveXscript { win } {
  set initialFile [string trimleft $win .]
  set saveFile [tk_getSaveFile -parent $win -initialfile $initialFile.txt]
  if { $saveFile == "" } {
    tk_messageBox -type ok -icon warning -parent $win -message\
     "No filename selected. Transcipt was NOT saved."
    return
  }
  if { [catch {$win.sText export $saveFile} saveError] } {
    tk_messageBox -type ok -icon warning -parent $win -message $saveError
  }
}
proc DisplayCorrelatedEvents { winName } {
  global ACTIVE_EVENT correlateArray eventTabs eventArray
  if {!$ACTIVE_EVENT} { return }
  set eventIndex [$winName curselection]
  set eventID [[winfo parent [winfo parent $winName]].eventIDFrame.list get $eventIndex]
  if { ![info exists correlateArray($eventID)] } {
    tk_messageBox -type ok -icon warning -message\
     "$eventID has no correlated events."
    return
  }
  $eventTabs add -label "$eventID"
  regsub {\.} $eventID {_} eventIDNice
  set currentTab [$eventTabs childsite end]
  set tabIndex [$eventTabs index end]
  set correlateFrame [frame $currentTab.$eventIDNice]
  $eventTabs select end
  CreateEventLists $correlateFrame
  set buttonFrame [frame $currentTab.buttonFrame]
  set closeButton [button $buttonFrame.close -text "Close"\
	  -pady 0 -borderwidth 2 -command "DeleteTab $eventTabs $currentTab"]
  set exportButton [button $buttonFrame.export -text "Export"\
	  -pady 0 -borderwidth 2 -command "ExportResults $correlateFrame event"]
  pack $closeButton $exportButton -side left -anchor w
  pack $buttonFrame -side top -anchor w
  pack $correlateFrame -side bottom
  
  eval DisplayEvent $correlateFrame RT [lindex $eventArray($eventID) 1] 1 [lrange $eventArray($eventID) 3 4] [join [lrange $eventArray($eventID) 5 6] . ] [lrange $eventArray($eventID) 7 12] [GetColorByPriority [lindex $eventArray($eventID) 1]]
  foreach event $correlateArray($eventID) {
    eval DisplayEvent $correlateFrame RT [lindex $eventArray($eventID) 1] 1 [lrange $eventArray($event) 3 4] [join [lrange $eventArray($event) 5 6] . ] [lrange $eventArray($event) 7 12] [GetColorByPriority [lindex $eventArray($event) 1]]
  }
}
proc DeleteTab { eventTabs tabName } {
  global ACTIVE_EVENT currentSelectedPane

  # If the currenttab had the selected index then we need to let things no that 
  # no event is active anymore
  if [regexp "^$tabName" $currentSelectedPane] { set ACTIVE_EVENT 0 }

  set tabIndex [lsearch -exact [$eventTabs childsite] $tabName]
  $eventTabs delete $tabIndex
  if {$tabIndex > 2} {
    $eventTabs prev
  } else {
    $eventTabs select 0
  }
}


proc CreateSessionLists { baseFrame } {
  global SCROLL_HOME
  set SCROLL_HOME($baseFrame) 0
  set sensorFrame [frame $baseFrame.sensorFrame]
    set sensorLabel [label $sensorFrame.sensorLabel -text "Sensor" -background black -foreground white -anchor w]
    set sensorList [listbox $sensorFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $sensorLabel -side top -fill x
    pack $sensorList -side bottom -fill both -expand true
    BindSelectionToAllLists $sensorList
    bind $sensorLabel <Double-Button-1> {
      SortListsBy %W sessions 
    }
  set xidFrame [frame $baseFrame.xidFrame]
    set xidLabel [label $xidFrame.label -text "Ssn ID" -background black -foreground white -anchor w]
    set xidList [listbox $xidFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $xidLabel -side top -fill x
    pack $xidList -side bottom -fill both -expand true
    BindSelectionToAllLists $xidList
    bind $xidLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $xidList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchXscriptMenu %W %Y
    }
    bind $xidList <Button-2> { GetXscript xscript 0 }
  set startTimeFrame [frame $baseFrame.startTimeFrame]
    set startTimeLabel [label $startTimeFrame.label -text "Start Time" -background black -foreground white -anchor w]
    set startTimeList [listbox $startTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $startTimeLabel -side top -fill x
    pack $startTimeList -side bottom -fill both -expand true
    BindSelectionToAllLists $startTimeList
    bind $startTimeLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set endTimeFrame [frame $baseFrame.endTimeFrame]
    set endTimeLabel [label $endTimeFrame.label -text "End Time" -background black -foreground white -anchor w]
    set endTimeList [listbox $endTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $endTimeLabel -side top -fill x
    pack $endTimeList -side bottom -fill both -expand true
    BindSelectionToAllLists $endTimeList
    bind $endTimeLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set srcIPFrame [frame $baseFrame.srcIPFrame]
    set srcIPLabel [label $srcIPFrame.srcIPLabel -text "Src IP" -background black -foreground white -anchor w]
    set srcIPList [listbox $srcIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcIPLabel -side top -fill x
    pack $srcIPList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcIPList
    bind $srcIPLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $srcIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set srcPortFrame [frame $baseFrame.srcPortFrame]
    set srcPortLabel [label $srcPortFrame.srcPortLabel -text "SPort" -background black -foreground white -anchor w]
    set srcPortList [listbox $srcPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcPortLabel -side top -fill x
    pack $srcPortList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcPortList
    bind $srcPortLabel <Double-Button-1> {
      SortListsBy %W sessions
      LaunchPortQueryMenu %W %Y
    }
  set dstIPFrame [frame $baseFrame.dstIPFrame]
    set dstIPLabel [label $dstIPFrame.dstIPLabel -text "Dst IP" -background black -foreground white -anchor w]
    set dstIPList [listbox $dstIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstIPLabel -side top -fill x
    pack $dstIPList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstIPList
    bind $dstIPLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
    bind $dstIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set dstPortFrame [frame $baseFrame.dstPortFrame]
    set dstPortLabel [label $dstPortFrame.dstPortLabel -text "DPort" -background black -foreground white -anchor w]
    set dstPortList [listbox $dstPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstPortLabel -side top -fill x
    pack $dstPortList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstPortList
    bind $dstPortLabel <Double-Button-1> {
      SortListsBy %W sessions
      LaunchPortQueryMenu %W %Y
    }
  set srcPcktsFrame [frame $baseFrame.srcPcktsFrame]
    set srcPcktsLabel [label $srcPcktsFrame.label -text "S Pckts" -background black -foreground white -anchor w]
    set srcPcktsList [listbox $srcPcktsFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcPcktsLabel -side top -fill x
    pack $srcPcktsList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcPcktsList
    bind $srcPcktsLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set srcBytesFrame [frame $baseFrame.srcBytesFrame]
    set srcBytesLabel [label $srcBytesFrame.label -text "S Bytes" -background black -foreground white -anchor w]
    set srcBytesList [listbox $srcBytesFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcBytesLabel -side top -fill x
    pack $srcBytesList -side bottom -fill both -expand true
    BindSelectionToAllLists $srcBytesList
    bind $srcBytesLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set dstPcktsFrame [frame $baseFrame.dstPcktsFrame]
    set dstPcktsLabel [label $dstPcktsFrame.label -text "D Pckts" -background black -foreground white -anchor w]
    set dstPcktsList [listbox $dstPcktsFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstPcktsLabel -side top -fill x
    pack $dstPcktsList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstPcktsList
    bind $dstPcktsLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set dstBytesFrame [frame $baseFrame.dstBytesFrame]
    set dstBytesLabel [label $dstBytesFrame.label -text "D Bytes" -background black -foreground white -anchor w]
    set dstBytesList [listbox $dstBytesFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstBytesLabel -side top -fill x
    pack $dstBytesList -side bottom -fill both -expand true
    BindSelectionToAllLists $dstBytesList
    bind $dstBytesLabel <Double-Button-1> {
      SortListsBy %W sessions
    }
  set scroll [scrollbar $baseFrame.scroll -command "MultiScrollBar \"$sensorList $xidList $startTimeList $endTimeList\
   $srcIPList $srcPortList $dstIPList $dstPortList $srcPcktsList $srcBytesList $dstPcktsList $dstBytesList\""  -width 10]
  pack $scroll -side right -fill y
  pack $sensorFrame $xidFrame $startTimeFrame $endTimeFrame $srcIPFrame $srcPortFrame $dstIPFrame $dstPortFrame\
   $srcPcktsFrame $srcBytesFrame $dstPcktsFrame $dstBytesFrame -side left -fill both -expand true
  pack $baseFrame -fill both -expand true
}
proc CreateEventLists { baseFrame } {
  global SCROLL_HOME
  set SCROLL_HOME($baseFrame) 0
  set statusFrame [frame $baseFrame.statusFrame]
    set statusLabel [label $statusFrame.statusLabel -text "ST" -background black -foreground white -anchor w]
    set statusList [listbox $statusFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $statusLabel -side top -fill x
    pack $statusList -side bottom -fill y -expand true
    BindSelectionToAllLists $statusList
    bind $statusLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $statusList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchStatusMenu %W %Y
    }
  set priorityFrame [frame $baseFrame.priorityFrame]
    set priorityLabel [label $priorityFrame.priorityLabel -text "PR" -background black -foreground white -anchor w]
    set priorityList [listbox $priorityFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
  set countFrame [frame $baseFrame.countFrame]
    set countLabel [label $countFrame.countLabel -text "CNT" -background black -foreground white -anchor w]
    set countList [listbox $countFrame.list -width 5 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $countLabel -side top -fill x
    pack $countList -side bottom -fill y -expand true
    BindSelectionToAllLists $countList
    bind $countLabel <Double-Button-1> {
      SortListsBy %W
    }
    # Middle click on count gives all correlated events
    bind $countList <Button-2> { DisplayCorrelatedEvents %W }
  set sensorFrame [frame $baseFrame.sensorFrame]
    set sensorLabel [label $sensorFrame.sensorLabel -text "Sensor" -background black -foreground white -anchor w]
    set sensorList [listbox $sensorFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $sensorLabel -side top -fill x
    pack $sensorList -side bottom -fill y -expand true
    BindSelectionToAllLists $sensorList
    bind $sensorLabel <Double-Button-1> {
      SortListsBy %W
    }
  set eventIDFrame [frame $baseFrame.eventIDFrame]
    set eventIDLabel [label $eventIDFrame.eventIDLabel -text "sid.cid" -background black -foreground white -anchor w]
    set eventIDList [listbox $eventIDFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $eventIDLabel -side top -fill x
    pack $eventIDList -side bottom -fill y -expand true
    BindSelectionToAllLists $eventIDList
    bind $eventIDLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $eventIDList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchXscriptMenu %W %Y
    }
    bind $eventIDList <Button-2> { GetXscript xscript 0 }
  set dateTimeFrame [frame $baseFrame.dateTimeFrame]
    set dateTimeLabel [label $dateTimeFrame.dateTimeLabel -text "Date/Time" -background black -foreground white -anchor w]
    set dateTimeList [listbox $dateTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dateTimeLabel -side top -fill x
    pack $dateTimeList -side bottom -fill y -expand true
    BindSelectionToAllLists $dateTimeList
    bind $dateTimeLabel <Double-Button-1> {
      SortListsBy %W
    }
  set srcIPFrame [frame $baseFrame.srcIPFrame]
    set srcIPLabel [label $srcIPFrame.srcIPLabel -text "Src IP" -background black -foreground white -anchor w]
    set srcIPList [listbox $srcIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcIPLabel -side top -fill x
    pack $srcIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcIPList
    bind $srcIPLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $srcIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set srcPortFrame [frame $baseFrame.srcPortFrame]
    set srcPortLabel [label $srcPortFrame.srcPortLabel -text "SPort" -background black -foreground white -anchor w]
    set srcPortList [listbox $srcPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $srcPortLabel -side top -fill x
    pack $srcPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcPortList
    bind $srcPortLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $srcPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set dstIPFrame [frame $baseFrame.dstIPFrame]
    set dstIPLabel [label $dstIPFrame.dstIPLabel -text "Dst IP" -background black -foreground white -anchor w]
    set dstIPList [listbox $dstIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstIPLabel -side top -fill x
    pack $dstIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstIPList
    bind $dstIPLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $dstIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set dstPortFrame [frame $baseFrame.dstPortFrame]
    set dstPortLabel [label $dstPortFrame.dstPortLabel -text "DPort" -background black -foreground white -anchor w]
    set dstPortList [listbox $dstPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $dstPortLabel -side top -fill x
    pack $dstPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstPortList
    bind $dstPortLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $dstPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set protoFrame [frame $baseFrame.protoFrame]
    set protoLabel [label $protoFrame.protoLabel -text "Pr" -background black -foreground white -anchor w]
    set protoList [listbox $protoFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $protoLabel -side top -fill x
    pack $protoList -side bottom -fill y -expand true
    BindSelectionToAllLists $protoList
    bind $protoLabel <Double-Button-1> {
      SortListsBy %W
    }
  set msgFrame [frame $baseFrame.msgFrame]
    set msgLabel [label $msgFrame.msgLabel -text "Event Message" -background black -foreground white -anchor w]
    set msgList [listbox $msgFrame.list -width 50 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$baseFrame.scroll set"]
    pack $msgLabel -side top -fill x
    pack $msgList -side bottom -fill both -expand true
    BindSelectionToAllLists $msgList
    bind $msgLabel <Double-Button-1> {
      SortListsBy %W
    }
    bind $msgList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchSigQueryMenu %W %Y
    }
  set scroll [scrollbar $baseFrame.scroll -command "MultiScrollBar \"$statusList $countList $sensorList $eventIDList\
   $dateTimeList $srcIPList $srcPortList $dstIPList $dstPortList $protoList $msgList\""  -width 10]
  pack $scroll -side right -fill y

  pack $statusFrame $countFrame $sensorFrame $eventIDFrame $dateTimeFrame $srcIPFrame\
   $srcPortFrame $dstIPFrame $dstPortFrame $protoFrame -side left -fill y
  pack $msgFrame -side left -fill both -expand true
  pack $baseFrame -fill both -expand true

}
proc ClearAllEventLists {} {
  global rtPaneArray escalateFrame
  foreach arrayName [array names rtPaneArray] {
    foreach childFrame "[winfo children $rtPaneArray($arrayName)] [winfo children $escalateFrame]" {
      if { [winfo name $childFrame] != "scroll" } {
        $childFrame.list delete 0 end
      }
    }
    #set eventIDList [$rtPaneArray($arrayName).eventIDFrame.list get 0 end]
  }
}
proc SortListsBy { clickedListWinName { listType {event} } } {
  # Two words. Ug. Ly. But it works.
  # We take all the data from each list and put it into its own list. Then
  # create an array whose name is listvalue.counter where listvalue is the 
  # corresponding value in the list we are sorting on. Finally we sort the 
  # array names and put the data back into the Tab. Makes sense right?  
  global ALTCOLORS COLOR1 COLOR2 COLOR3 CATEGORY_COLOR
  set sortByName [winfo name [winfo parent $clickedListWinName]]
  set tabName [winfo parent [winfo parent $clickedListWinName] ]
  set tabChildren [winfo children $tabName]
  foreach listFullWinName $tabChildren {
    set listWinName [winfo name $listFullWinName]
    if { $listWinName != "scroll" } {
      set $listWinName [$listFullWinName.list get 0 end]
      lappend winNameList $listWinName
      $listFullWinName.list delete 0 end
    }
    $listFullWinName configure -cursor watch
  }
  update
  set totalLines [eval llength $$sortByName]
  set itemCounter 0
  while { $itemCounter < $totalLines } {
    foreach winName $winNameList {
      lappend tmpArray([eval lindex $$sortByName $itemCounter].$itemCounter)\
       "[eval lindex $$winName $itemCounter]"
    }
    incr itemCounter
  }
  set backgroundColor $COLOR1
  foreach tmpData [lsort -dictionary [array names tmpArray]] {
    set listIndex 0
    foreach winListName $winNameList {
      $tabName.$winListName.list insert end [lindex $tmpArray($tmpData) $listIndex]
      if { $listType == "event" && $listIndex == "0" } {
        if { [lindex $tmpArray($tmpData) $listIndex] != "RT" } {
          $tabName.$winListName.list itemconfigure end\
           -background $CATEGORY_COLOR([lindex $tmpArray($tmpData) $listIndex])
        } else {
          $tabName.$winListName.list itemconfigure end\
           -background [GetColorByPriority [lindex $tmpArray($tmpData) 1]]
        }
      } else {
        $tabName.$winListName.list itemconfigure end -background "$backgroundColor"
      }
      incr listIndex
    }
    if {$ALTCOLORS} {
      if {$backgroundColor == "$COLOR1"} {
        set backgroundColor "$COLOR2"
      } elseif { $backgroundColor == "$COLOR2" } {
        set backgroundColor "$COLOR3"
      } else {
        set backgroundColor "$COLOR1"
      }
    }
  }
  foreach listFullWinName $tabChildren {
    $listFullWinName configure -cursor left_ptr
  }
  update
}
proc GoToSleep {} {
  global SLEEP
  set SLEEP 1
  wm iconify .
}
proc WakeUp {} {
  global SLEEP
  set SLEEP 0
  wm deiconify .
  bell
}
proc Speak { msg } {
      set soundFileID [open /dev/speech w]
      puts $soundFileID $msg
      close $soundFileID
}

proc DisplayUsage { cmdName } {
  puts "Usage: $cmdName -- -c <filename>"
  puts "  where <filename> is the PATH to the sguil config file"
  exit 1
}
proc ParseFontInfo { fontInfo } {
  set fontFamily [lindex $fontInfo 0]
  set fontSize [lindex $fontInfo 1]
  set fontWeight normal
  set fontSlant roman
  set fontUnderline 0
  set fontOverstrike 0
  if { [llength $fontInfo] == 3 } {
    set fontOptionsList [lindex $fontInfo 2]
    foreach fontOption $fontOptionsList {
      switch -exact $fontOption {
        italic		{ set fontSlant italic }
        bold		{ set fontWeight bold }
        underline 	{ set fontUnderline 1 }
        overstrike	{ set fontOverstrike 1 }
        default		{ puts "Unkonwn option: $fontOption" }
      }
    }
  }
  return "-family {$fontFamily} -size $fontSize -weight $fontWeight -underline $fontUnderline\
   -slant $fontSlant -overstrike $fontOverstrike"
}
proc GetCurrentFont { fontOptionsList } {
  set state flag
  foreach fontOption $fontOptionsList {
    switch -- $state {
      flag {
      	switch -exact -- $fontOption {
          -family 	{set state family}
          -size		{set state size}
	  -weight	{set state weight}
	  -slant	{set state slant}
	  -underline	{set state underline}
	  -overstrike	{set state overstrike}
          default	{set state unknown}
        }
      }
      family	{set family $fontOption; set state flag}
      size	{set size $fontOption; set state flag}
      weight	{lappend options $fontOption; set state flag}
      slant	{lappend options $fontOption; set state flag}
      underline { if {$fontOption} {lappend options underline}; set state flag}
      overstrike { if {$fontOption} {lappend options overstrike}; set state flag}
      unknown	{puts "Unknown flag"; set state flag}
      default	{puts "Unknown option"; set state flag}
    }
  }
  return "{$family} $size [list $options]"
}
proc ChangeFont  { fontType } {
  set newFont [dkf_chooseFont -parent . -title "Font Select" \
   -initialfont [GetCurrentFont [font configure $fontType]] ]
  GetCurrentFont [font configure $fontType]
  if { [llength $newFont] == 0 } { return }
  eval font configure $fontType [ParseFontInfo $newFont]
  SaveNewFonts
}
proc SaveNewFonts {} {
  global FONTFILE
  write_file $FONTFILE "ourStandardFont [font configure ourStandardFont]" "ourFixedFont [font configure ourFixedFont]"
}

proc CreateSensorCheckButton { winName sensorName } {
  # tcl is picky with window names so prepend a "win" to the sensorname
  # and sub any .'s out.
  regsub -all {\.} $sensorName {_} buttonName
  checkbutton $winName.win$buttonName -text "$sensorName" -variable sensorSelectArray($sensorName)
  pack $winName.win$buttonName -side left -padx 10 -pady 10
}

proc GetUserName {} {
  global USERNAME PASSWD VERSION
  set getUserNameWin [toplevel .getUserNameWin -background white]
  wm title $getUserNameWin "Snort GUI for Lamerz \[sguil\] - $VERSION"
  set welcomeFrame [frame $getUserNameWin.welcomeFrame -borderwidth 1 -background black]
  set welcomeLabel [label $welcomeFrame.welcomeLabel -background lightblue\
   -foreground navy -text \
   "Snort GUI for Lamerz \[sguil\]\n\
   \n\
   Copyright (C) 2002 Robert (Bamm) Visscher <bamm@satx.rr.com>\n\
   \n\
   This program is distributed under the terms of version 1.0 of the\n\
   Q Public License.  See LICENSE.QPL for further details.\n\
   \n\
   This program is distributed in the hope that it will be useful,\n\
   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."]
  pack $welcomeLabel -ipadx 5 -ipady 5
  pack $welcomeFrame -side top -padx 5 -pady 10
  set promptFrame [frame $getUserNameWin.promptFrame -background black -borderwidth 1]
    set userLabel [label $promptFrame.userLabel -text "Please Login" -foreground navy]
    set userName [entryfield $promptFrame.userName -validate alphanumeric\
      -labeltext "Username:"\
      -invalid {ErrorMessage "Please use alphanumeric characters only."}\
      -textvariable USERNAME]
    set userPasswd [entryfield $promptFrame.userPasswd\
      -labeltext "Password:" -textvariable PASSWD -show *]
    iwidgets::Labeledwidget::alignlabels $userName $userPasswd
    set userBB [buttonbox $promptFrame.userBB]
      $userBB add ok -text "Ok" -command "destroy $getUserNameWin"
      $userBB add exit -text "Exit" -command "CleanExit"
    pack $userLabel $userName $userPasswd $userBB -side top -fill both -expand true
  pack $promptFrame -side bottom -pady 5
  bind [$userPasswd component entry] <Return> { destroy .getUserNameWin }
  tkwait window $getUserNameWin
}
#
# SensorList: Rcvd a list of sensors from the server. Select which ones we 
#             want to monitor.
#
proc SensorList { sensorList } {
  global MONITORFLAG sensorSelectArray subFrameList VERSION
  set sensorSelectWindow [toplevel .sensorSelectWindow -background white]
  wm title $sensorSelectWindow "Snort GUI for Lamerz \[sguil\] - $VERSION"
  set welcomeFrame [frame $sensorSelectWindow.welcomeFrame -borderwidth 1 -background black]
  set welcomeLabel [label $welcomeFrame.welcomeLabel -background lightblue\
   -foreground navy -text\
  "Snort GUI for Lamerz \[sguil\]\n\
   \n\
   Copyright (C) 2002 Robert (Bamm) Visscher <bamm@satx.rr.com>\n\
   \n\
   This program is distributed under the terms of version 1.0 of the\n\
   Q Public License.  See LICENSE.QPL for further details.\n\
   \n\
   This program is distributed in the hope that it will be useful,\n\
   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."]
  pack $welcomeLabel -ipadx 5 -ipady 5
  pack $welcomeFrame -side top -padx 5 -pady 10
  if { $sensorList != "0none0" } {
    # Now a frame to contain the checkbutton frames
    set checkButtonFrame [frame $sensorSelectWindow.checkButtonFrame -borderwidth 1 -background black]
    pack $checkButtonFrame -side top -padx 5 -pady 10
    set winLabel [label $checkButtonFrame.label -text "Select Senor(s) to Monitor"\
     -foreground navy]
    pack $winLabel -side top -fill both -expand true
    # We create a new frame for every 5 sensors to keep the look clean.
    set i 0
    set frameNumber 0
    set currentFrame [frame $checkButtonFrame.subFrame$frameNumber]
    lappend subFrameList $currentFrame
    foreach sensorName $sensorList {
      if { $i < 5 } {
        CreateSensorCheckButton $currentFrame $sensorName
        incr i
      } else {
        pack $currentFrame -side top
        incr frameNumber
        set currentFrame [frame $checkButtonFrame.subFrame$frameNumber]
        lappend subFrameList $currentFrame
        CreateSensorCheckButton $currentFrame $sensorName
        set i 1
      }
  
    }
    pack $currentFrame -side top -fill x
  } else {
    label $sensorSelectWindow.noSensorLabel -background white -text\
    "There are No sensors currently in the DB to monitor.\n\
     Press <Start SGUIL> to launch the GUI anyway."
    pack $sensorSelectWindow.noSensorLabel -side top
  }
  set actionButtonFrame [frame $sensorSelectWindow.actionButtonFrame -background white]
    set selectAllButton [button $actionButtonFrame.selectAllButton -text "Select All"\
     -command "SelectAllSensors"]
    set monitorButton [button $actionButtonFrame.monitorButton -text "Start SGUIL"\
     -command "MonitorSensors $sensorSelectWindow"]
    set exitButton [button $actionButtonFrame.exitButton -text "Exit" -command "CleanExit"]
    pack $selectAllButton $monitorButton $exitButton -side left -padx 10 -pady 10
  pack $actionButtonFrame -side top
  # Don't move on until we select the sensors
  tkwait window $sensorSelectWindow
  set MONITORFLAG 1
}
proc MonitorSensors { winName } {
  global sensorSelectArray socketID DEBUG monitorList
  set monitorList ""
  foreach sensorName [array names sensorSelectArray] {
    if {$sensorSelectArray($sensorName)} { lappend monitorList $sensorName }
  }
  if { [info exists monitorList] } {
    if {$DEBUG} { puts "Sending Server: MonitorSensors $monitorList"}
    SendToSguild "MonitorSensors $monitorList"
  } else {
    InfoMessage "You did not select any sensors to monitor and will NOT recieve any events."
  }
  destroy $winName
}
proc SelectAllSensors {} {
  global subFrameList
  foreach subFrame $subFrameList {
    foreach checkButton [winfo children $subFrame] {
      $checkButton invoke
    }
  }
}
#
# CheckLineFormat - Parses CONF_FILE lines to make sure they are formatted
#                   correctly (set varName value). Returns 1 if good.
#
proc CheckLineFormat { line } {
  
  set RETURN 1
  # Right now we just check the length and for "set".
  if { [llength $line] != 3 || [lindex $line 0] != "set" } { set RETURN 0 }
  return $RETURN
}
proc GetEventHistory {} {
  global ACTIVE_EVENT currentSelectedPane SSN_QUERY socketID
  if {!$ACTIVE_EVENT} { return }
  if {$SSN_QUERY} {InfoMessage "History not available for sessions."; return}
  set winName $currentSelectedPane.eventIDFrame.list
  set index [$winName curselection]
  if { [$currentSelectedPane.statusFrame.list get $index] == "RT" } {
    InfoMessage "New (RT) events do not have a history."
    return
  }
  set eventID [$winName get $index]
  set sid [lindex [split $eventID .] 0]
  set cid [lindex [split $eventID .] 1]
  set historyWinName .eventHistoryWin_${sid}_${cid}
  if [winfo exists $historyWinName] {
    wm withdraw $historyWinName
    wm deiconify $historyWinName
    return
  }
  CreateHistoryWin $historyWinName
  SendToSguild "EventHistoryRequest $historyWinName $sid $cid"
}
proc CreateHistoryWin {winName } {
  toplevel $winName
  wm title $winName "Event History"
  wm geometry $winName +[winfo rootx .]+[winfo pointery .]
  set listsFrame [frame $winName.listsFrame -background black -borderwidth 1]
  set eidFrame [frame $listsFrame.eidFrame]
    label $eidFrame.label -text "Event ID" -background black -foreground white -anchor w
    listbox $eidFrame.list -width 10 -height 5 -relief flat -background white
    pack $eidFrame.label -side top -fill x -anchor e
    pack $eidFrame.list -side top -fill both -expand true
  set userFrame [frame $listsFrame.userFrame]
    label $userFrame.label -text "Username" -background black -foreground white -anchor w
    listbox $userFrame.list -width 15 -height 5 -relief flat -background white
    pack $userFrame.label -side top -fill x -anchor e
    pack $userFrame.list -side top -fill both -expand true
  set dateFrame [frame $listsFrame.dateFrame]
    label $dateFrame.label -text "Date/Time" -background black -foreground white -anchor w
    listbox $dateFrame.list -width 17 -height 5 -relief flat -background white
    pack $dateFrame.label -side top -fill x -anchor e
    pack $dateFrame.list -side top -fill both -expand true
  set statusFrame [frame $listsFrame.statusFrame]
    label $statusFrame.label -text "ST" -background black -foreground white -anchor w
    listbox $statusFrame.list -width 3 -height 5 -relief flat -background white
    pack $statusFrame.label -side top -fill x -anchor e
    pack $statusFrame.list -side top -fill both -expand true
  set descFrame [frame $listsFrame.descFrame]
    label $descFrame.label -text "Description" -background black -foreground white -anchor w
    listbox $descFrame.list -width 26 -height 5 -relief flat -background white
    pack $descFrame.label -side top -fill x -anchor e
    pack $descFrame.list -side top -fill both -expand true
  set commentFrame [frame $listsFrame.commentFrame]
    label $commentFrame.label -text "Comment" -background black -foreground white -anchor w
    listbox $commentFrame.list -width 50 -height 5 -relief flat -background white
    pack $commentFrame.label -side top -fill x -anchor e
    pack $commentFrame.list -side top -fill both -expand true
  pack $eidFrame $userFrame $dateFrame $statusFrame $descFrame\
   -side left -fill y
  pack $commentFrame\
   -side left -fill both -expand true

  button $winName.close -text "Close" -command "destroy $winName"
  pack $listsFrame -side top -fill both -expand true
  pack $winName.close -side top

}
proc InsertHistoryResults { winName results } {
  if { $results == "done" } { return }
  if { ![winfo exists $winName] } { CreateHistoryWin $winName }
  $winName.listsFrame.eidFrame.list insert end "[lindex $results 0].[lindex $results 1]"
  $winName.listsFrame.userFrame.list insert end [lindex $results 2]
  $winName.listsFrame.dateFrame.list insert end [lindex $results 3]
  $winName.listsFrame.statusFrame.list insert end [lindex $results 4]
  $winName.listsFrame.descFrame.list insert end [lindex $results 5]
  set comment [lindex $results 6]
  if { $comment == ""} { set comment none }
  $winName.listsFrame.commentFrame.list insert end $comment
}

proc Working {} {
  global BUSY
  . configure -cursor watch
  set BUSY 1
}
proc Idle {} {
  global BUSY
  . configure -cursor left_ptr
  set BUSY 0
}
################################ END PROCS ##################################

################################ MAIN #######################################
# Get Options
set state flag
foreach arg $argv {
  switch -- $state {
    flag {
      switch -glob -- $arg {
        -c { set state conf }
        default { DisplayUsage $argv0 }
      }
    }
    conf { set CONF_FILE $arg; set state flag }
    default { DisplayUsage $argv0 }
  }
}

set USER_QRY_FILE "$env(HOME)/.sgqry"
if { ![info exists CONF_FILE] } {
  # No conf file specified check the defaults
  if { [file exists $env(HOME)/sguil.conf] } {
    set CONF_FILE $env(HOME)/sguil.conf
  } elseif { [file exists ./sguil.conf] } {
    set CONF_FILE ./sguil.conf
  } else {
    puts "Couldn't determine where the sguil config file is"
    puts "Looked for $env(HOME)/sguil.conf and ./sguil.conf."
    DisplayUsage $argv0
  }
}
set i 0
if { [info exists CONF_FILE] } {
  # Parse the config file. Currently the only option is to 
  # create a variable using 'set varName value' 
  for_file line $CONF_FILE {
    incr i
    if { ![regexp ^# $line] && ![regexp ^$ $line] } {
      if { [CheckLineFormat $line] } {
        if { [catch {eval $line} evalError] } {
          puts "Error at line $i in $CONF_FILE: $line"
          ErrorMessage "Error at line $i in $CONF_FILE: $line"
          CleanExit
        }
      } else {
        puts "Error at line $i in $CONF_FILE: $line"
        ErrorMessage "Error at line $i in $CONF_FILE: $line"
        CleanExit
      }
    }
  }
} else {
  DisplayUsage $argv0
}

# Load user fonts
if { [file exists $FONTFILE] } {
  for_file fontLine $FONTFILE {
    eval font create [lindex $fontLine 0] [lrange $fontLine 1 end]
  }
} else {
  font create ourStandardFont -family Helvetica -size 10 -weight bold
  font create ourFixedFont -family fixed -size 12
}
option add *Font ourStandardFont

# Source required sguillibs
source $SGUILLIB/dkffont.tcl
source $SGUILLIB/email17.tcl
source $SGUILLIB/report.tcl
source $SGUILLIB/qrylib.tcl
source $SGUILLIB/stdquery.tcl
source $SGUILLIB/qrybuild.tcl
if { $WHOIS_PATH == "SimpleWhois" } {
  source $SGUILLIB/whois.tcl
}

############################# GUI ############################################

wm withdraw .

option add *textBackground white
option add *selectBackground $SELECTBACKGROUND
option add *selectForeground $SELECTFOREGROUND




# Font
#font create ourFont -family {new century schoolbook} -size 10 -weight normal\
 #-underline 0 -slant roman -overstrike 0


# Load iwidgets and namespaces
if [catch {package require Iwidgets} iwidgetsVersion] {
  puts "ERROR: Cannot fine the Iwidgets extension."
  puts "The iwidgets package is part of the incr tcl extension and is"
  puts "available as a port/package most systems."
  puts "See http://www.tcltk.com/iwidgets/ for more info."
  exit
}
namespace import -force iwidgets::panedwindow
namespace import -force iwidgets::tabnotebook
namespace import -force iwidgets::scrolledtext
namespace import -force iwidgets::optionmenu
namespace import -force iwidgets::buttonbox
namespace import -force iwidgets::entryfield
namespace import -force iwidgets::checkbox
namespace import -force iwidgets::messagedialog
namespace import -force iwidgets::scrolledlistbox
namespace import -force iwidgets::combobox
namespace import -force iwidgets::radiobox
namespace import -force iwidgets::dialogshell
proc LabelText { winFrame width labelText { height {1} } { bgColor {lightblue} } } {
  label $winFrame.label -text "$labelText" -foreground black -background $bgColor -anchor s -height $height
  text $winFrame.text  -width $width -background white -height 1
  pack $winFrame.label $winFrame.text -side top -anchor w -fill both -expand true
}

set topFrame [frame .topFrame]
  set fileMenu [menubutton $topFrame.fileMenu -text File -underline 0 -menu $topFrame.fileMenu.menu]
  set queryMenu [menubutton $topFrame.queryMenu -text Query -underline 0 -menu $topFrame.queryMenu.menu]
  set reportMenu [menubutton $topFrame.reportMenu -text Reports -underline 0 -menu $topFrame.reportMenu.menu]
  set databaseMenu [menubutton $topFrame.databaseMenu -text Database -underline 0 -menu $topFrame.databaseMenu.menu]
  set soundFrame [frame $topFrame.soundFrame]
    set soundLabel [label $soundFrame.label -text "    Sound:"]
    set soundStatus [label $soundFrame.status -text "Off" -foreground red] 
    pack $soundLabel $soundStatus -side left
  pack $fileMenu $queryMenu $reportMenu $databaseMenu $soundFrame -side left
  if {$GMTCLOCK } {
    set gmtClock [label $topFrame.gmtClock -text "YYYY-MM-DD HH:MM:SS GMT" -relief groove]
    pack $gmtClock -side right -anchor e -padx 5
    UpdateClock
  }
  set fileList [menu $fileMenu.menu -tearoff 0]
    $fileList add command -label "Display Incident Categories" -command DisplayIncidentCats  
    $fileList add command -label "Sleep (Ctrl-s)" -command "GoToSleep"
    $fileList add cascade -label "Change Font" -menu $fileList.font
    set fontMenu [menu $fileList.font -tearoff 0]
      $fontMenu add command -label "Standard" -command {ChangeFont ourStandardFont}
      $fontMenu add command -label "Fixed" -command {ChangeFont ourFixedFont}
    $fileList add command -label "About SGUIL" -command "AboutBox"
    $fileList add command -label "Exit" -command CleanExit
  set queryList [menu $queryMenu.menu -tearoff 0]
    $queryList add command -label "Query Event Table" -command "QueryRequest event empty"
    $queryList add command -label "Query Sessions Table" -command "QueryRequest sessions empty"
    $queryList add command -label "Standard Queries" -command "StdQuery"
    $queryList add command -label "Query Builder" -command "InvokeQryBuild empty empty"
    $queryList add cascade -label "Query by Category" -menu $queryList.category
    set categoryMenu [menu $queryList.category -tearoff 0]
      $categoryMenu add command -label "Cat I: Unauthorized Root Access"\
	      -command "QueryRequest event category 11"
      $categoryMenu add command -label "Cat II: Unauthorized User Access"\
	      -command "QueryRequest event category 12"
      $categoryMenu add command -label "Cat III: Attempted Unauthorized Access"\
	      -command "QueryRequest event category 13"
      $categoryMenu add command -label "Cat IV: Successful Denial of Service Attack"\
	      -command "QueryRequest event category 14"
      $categoryMenu add command -label "Cat V: Poor Security Practice or Policy Violation"\
	      -command "QueryRequest event category 15"
      $categoryMenu add command -label "Cat VI: Reconnaissance/Probes/Scans"\
	      -command "QueryRequest event category 16"
      $categoryMenu add command -label "Cat VII: Virus Infection"\
	      -command "QueryRequest event category 17"
    $queryList add command -label "Show DataBase Tables" -command "ShowDBTables"
  set reportList [menu $reportMenu.menu -tearoff 0]
    $reportList add cascade -label "Export Events to a Text File (Detail)" -menu $reportList.textDetail
      set textDetailMenu [menu $reportList.textDetail -tearoff 0]
      $textDetailMenu add command -label "Normal" -command {TextReport 1 0}
      $textDetailMenu add command -label "Sanitized" -command {TextReport 1 1}
    $reportList add cascade -label "Export Events to a Text File (Summary)" -menu $reportList.textSummary
      set textSummaryMenu [menu $reportList.textSummary -tearoff 0]
      $textSummaryMenu add command -label "Normal" -command {TextReport 0 0}
      $textSummaryMenu add command -label "Sanitized" -command {TextReport 0 1}
    $reportList add cascade -label "Send Event Detail via email" -menu $reportList.detail
      set detailMenu [menu $reportList.detail -tearoff 0]
      $detailMenu add command -label "Normal" -command {EmailEvents 1 0}
      $detailMenu add command -label "Sanitized" -command {EmailEvents 1 1}
    $reportList add cascade -label "Send Event Summary via email" -menu $reportList.summary
      set summaryMenu [menu $reportList.summary -tearoff 0]
      $summaryMenu add command -label "Normal" -command {EmailEvents 0 0}
      $summaryMenu add command -label "Sanitized" -command {EmailEvents 0 1}
  set databaseList [menu $databaseMenu.menu -tearoff 0]
    $databaseList add command -label "Purge Session Data" -command "DeleteRequest sessions"
    $databaseList add command -label "Optimize Tables" -command "OptimizeTables"
  #$menuList add command -label "License" -command "DisplayLicense"




pack $topFrame -side top -fill x -padx 0 -pady 0
wm title . "Snort GUI for Lamerz \[sguil\] - $VERSION"

set eventPane [panedwindow .eventPane -width 1000 -height 700]
  $eventPane add eventLists -margin 0
  $eventPane add eventData -margin 0
pack $eventPane -fill both -expand true -padx 0 -pady 0

set eventTabs [tabnotebook [$eventPane childsite 0].eventTabs\
 -angle 0 -bevelamount 4 -tabpos n -tabbackground darkgrey]
pack $eventTabs -side left -expand true -fill both -padx 0 -pady 0

$eventTabs add -label "RealTime Events"
$eventTabs add -label "Escalated Events"
set escalateFrame [frame [$eventTabs childsite end].escalateFrame]
CreateEventLists $escalateFrame
$eventTabs select 0

set realtimeEventPanes [panedwindow [$eventTabs childsite 0].realtimeEventPanes]
set i 0
while { $i < $RTPANES } {
  $realtimeEventPanes add RealTimePane$i -margin 5
  set realtimePane$i [frame [$realtimeEventPanes childsite $i].realtimePane$i\
   -background black -borderwidth 1]
  eval set currentPane \$realtimePane$i
  set rtPaneArray($i) $currentPane
  set SCROLL_HOME($currentPane) 1
  set statusFrame [frame $currentPane.statusFrame]
    set statusLabel [label $statusFrame.statusLabel -text "ST" -background black -foreground white -anchor w -pady 0]
    set statusList [listbox $statusFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $statusLabel -side top -fill x
    pack $statusList -side bottom -fill y -expand true
    BindSelectionToAllLists $statusList
    bind $statusList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchStatusMenu %W %Y
    }
  set priorityFrame [frame $currentPane.priorityFrame]
    set priorityLabel [label $priorityFrame.priorityLabel -text "PR" -background black -foreground white -anchor w]
    set priorityList [listbox $priorityFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
  set countFrame [frame $currentPane.countFrame]
    set countLabel [label $countFrame.countLabel -text "CNT" -background black -foreground white -anchor w -pady 0]
    set countList [listbox $countFrame.list -width 5 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $countLabel -side top -fill x
    pack $countList -side bottom -fill y -expand true
    BindSelectionToAllLists $countList
    bind $countList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchCorrelateMenu %W %Y
    }
    # Middle click on count gives all correlated events
    bind $countList <Button-2> { DisplayCorrelatedEvents %W }
  set sensorFrame [frame $currentPane.sensorFrame]
    set sensorLabel [label $sensorFrame.sensorLabel -text "Sensor" -background black -foreground white -anchor w -pady 0]
    set sensorList [listbox $sensorFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $sensorLabel -side top -fill x
    pack $sensorList -side bottom -fill y -expand true
    BindSelectionToAllLists $sensorList
  set eventIDFrame [frame $currentPane.eventIDFrame]
    set eventIDLabel [label $eventIDFrame.eventIDLabel -text "sid.cid" -background black -foreground white -anchor w -pady 0]
    set eventIDList [listbox $eventIDFrame.list -width 10 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $eventIDLabel -side top -fill x
    pack $eventIDList -side bottom -fill y -expand true
    BindSelectionToAllLists $eventIDList
    bind $eventIDList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchXscriptMenu %W %Y
    }
    bind $eventIDList <Button-2> { GetXscript xscript 0 }
  set dateTimeFrame [frame $currentPane.dateTimeFrame]
    set dateTimeLabel [label $dateTimeFrame.dateTimeLabel -text "Date/Time" -background black -foreground white -anchor w -pady 0]
    set dateTimeList [listbox $dateTimeFrame.list -width 18 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $dateTimeLabel -side top -fill x
    pack $dateTimeList -side bottom -fill y -expand true
    BindSelectionToAllLists $dateTimeList
  set srcIPFrame [frame $currentPane.srcIPFrame]
    set srcIPLabel [label $srcIPFrame.srcIPLabel -text "Src IP" -background black -foreground white -anchor w -pady 0]
    set srcIPList [listbox $srcIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $srcIPLabel -side top -fill x
    pack $srcIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcIPList
    bind $srcIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set srcPortFrame [frame $currentPane.srcPortFrame]
    set srcPortLabel [label $srcPortFrame.srcPortLabel -text "SPort" -background black -foreground white -anchor w -pady 0]
    set srcPortList [listbox $srcPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $srcPortLabel -side top -fill x
    pack $srcPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $srcPortList
    bind $srcPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set dstIPFrame [frame $currentPane.dstIPFrame]
    set dstIPLabel [label $dstIPFrame.dstIPLabel -text "Dst IP" -background black -foreground white -anchor w -pady 0]
    set dstIPList [listbox $dstIPFrame.list -width 15 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $dstIPLabel -side top -fill x
    pack $dstIPList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstIPList
    bind $dstIPList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchIPQueryMenu %W %Y
    }
  set dstPortFrame [frame $currentPane.dstPortFrame]
    set dstPortLabel [label $dstPortFrame.dstPortLabel -text "DPort" -background black -foreground white -anchor w -pady 0]
    set dstPortList [listbox $dstPortFrame.list -width 6 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $dstPortLabel -side top -fill x
    pack $dstPortList -side bottom -fill y -expand true
    BindSelectionToAllLists $dstPortList
    bind $dstPortList <ButtonPress-3> {
      #SingleSelect %W [%W nearest %y]
      LaunchPortQueryMenu %W %Y
    }
  set protoFrame [frame $currentPane.protoFrame]
    set protoLabel [label $protoFrame.protoLabel -text "Pr" -background black -foreground white -anchor w -pady 0]
    set protoList [listbox $protoFrame.list -width 3 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $protoLabel -side top -fill x
    pack $protoList -side bottom -fill y -expand true
    BindSelectionToAllLists $protoList
  set msgFrame [frame $currentPane.msgFrame]
    set msgLabel [label $msgFrame.msgLabel -text "Event Message" -background black -foreground white -anchor w -pady 0]
    set msgList [listbox $msgFrame.list -width 50 -height 5 -exportselection false\
     -borderwidth 0 -yscrollcommand "$currentPane.scroll set"]
    pack $msgLabel -side top -fill x
    pack $msgList -side bottom -fill both -expand true
    BindSelectionToAllLists $msgList
    bind $msgList <ButtonPress-3> {
      SingleSelect %W [%W nearest %y]
      LaunchSigQueryMenu %W %Y
    }
  set scroll [scrollbar $currentPane.scroll -command "MultiScrollBar \"$statusList $countList $sensorList $eventIDList\
   $dateTimeList $srcIPList $srcPortList $dstIPList $dstPortList $protoList $msgList\""  -width 10]
  pack $scroll -side right -fill y
  # When scrollbar is pressed we turn of autoscrolling until we can check its position.
  bind $scroll <Button-1> {
    set SCROLL_HOME([winfo parent %W]) 0
  }
  # When scrollbar is released we check its position. If its
  # at the bottom then we enable autoscrolling
  bind $scroll <ButtonRelease-1> {
    set scrollbarPosition [lindex [%W get] 1]
    if {$scrollbarPosition == 1.0} {set SCROLL_HOME([winfo parent %W]) 1}
  }
  
  pack $statusFrame $countFrame $sensorFrame $eventIDFrame $dateTimeFrame $srcIPFrame\
   $srcPortFrame $dstIPFrame $dstPortFrame $protoFrame -side left -fill y
  pack $msgFrame -side left -fill both -expand true
  pack $currentPane -fill both -expand true
  incr i
}
pack $realtimeEventPanes -fill both -expand true -padx 0 -pady 0

set detailPane [panedwindow [$eventPane childsite 1].detailPane -orient vertical]
$detailPane add ipdata -margin 0
$detailPane add packetData -margin 7
pack $detailPane -expand true -fill both -padx 0 -pady 0

set ipDataPane [panedwindow [$detailPane childsite 0].ipDataPane]
$ipDataPane add resolvers -margin 5
$ipDataPane add systeminfo -margin 5
pack $ipDataPane -expand true -fill both
set ipDataFrame [frame [$ipDataPane childsite 0].ipDataFrame]
  set dnsDataFrame [frame $ipDataFrame.dnsDataFrame]
    set srcDnsDataFrame [frame $dnsDataFrame.srcDnsDataFrame -borderwidth 1 -background black]
      set srcDnsDataLabelFrame [frame $srcDnsDataFrame.srcDnsDataLabelFrame]
        label $srcDnsDataLabelFrame.ipLabel -text "Src IP:" -anchor w -width 9 -background lightblue
        label $srcDnsDataLabelFrame.nameLabel -text "Src Name:" -anchor w -width 9 -background lightblue
        pack $srcDnsDataLabelFrame.ipLabel $srcDnsDataLabelFrame.nameLabel -side top -fill y
      set srcDnsDataEntryTextFrame [frame $srcDnsDataFrame.srcDnsDataTextFrame]
        text $srcDnsDataEntryTextFrame.ipText -height 1 -width 20 -background white
        text $srcDnsDataEntryTextFrame.nameText -height 1 -width 20 -background white
        pack $srcDnsDataEntryTextFrame.ipText $srcDnsDataEntryTextFrame.nameText -side top -fill x -expand true
      pack $srcDnsDataLabelFrame -side left -fill y
      pack $srcDnsDataEntryTextFrame -side right -fill x -expand true
    set dstDnsDataFrame [frame $dnsDataFrame.dstDnsDataFrame -borderwidth 1 -background black]
      set dstDnsDataLabelFrame [frame $dstDnsDataFrame.dstDnsDataLabelFrame]
        label $dstDnsDataLabelFrame.ipLabel -text "Dst IP:" -anchor w -width 9 -background lightblue
        label $dstDnsDataLabelFrame.nameLabel -text "Dst Name:" -anchor w -width 9 -background lightblue
        pack $dstDnsDataLabelFrame.ipLabel $dstDnsDataLabelFrame.nameLabel -side top -fill y
      set dstDnsDataEntryTextFrame [frame $dstDnsDataFrame.dstDnsDataTextFrame]
        text $dstDnsDataEntryTextFrame.ipText -height 1 -width 20 -background white
        text $dstDnsDataEntryTextFrame.nameText -height 1 -width 20 -background white
        pack $dstDnsDataEntryTextFrame.ipText $dstDnsDataEntryTextFrame.nameText -side top -fill x -expand true
      pack $dstDnsDataLabelFrame -side left
      pack $dstDnsDataEntryTextFrame -side left -fill x -expand true
    pack $srcDnsDataFrame $dstDnsDataFrame -side top -fill x -expand true
  set whoisDataFrame [frame $ipDataFrame.whoisDataFrame]
    set whoisDataButtonsFrame [frame $whoisDataFrame.whoisDataButtonsFrame]
      set dnsButton [checkbutton $whoisDataButtonsFrame.dnsButton -text "Reverse DNS" -variable REVERSE_DNS\
       -command ResolveHosts -foreground navy -anchor w]
      set whoisLabel [label $whoisDataButtonsFrame.whoisLabel -text "Whois Query:" -foreground navy]
      set whoisNoneButton [radiobutton $whoisDataButtonsFrame.whoisNoneButton -variable WHOISLIST -value none\
       -text "None" -command ClearWhoisData]
      set whoisSrcButton [radiobutton $whoisDataButtonsFrame.whoisSrcButton -variable WHOISLIST -value srcIPFrame\
       -text "Src IP" -command GetWhoisData]
      set whoisDstButton [radiobutton $whoisDataButtonsFrame.whoisDstButton -variable WHOISLIST -value dstIPFrame\
       -text "Dst IP" -command GetWhoisData]
      pack $dnsButton -side left -anchor e
      pack $whoisDstButton $whoisSrcButton $whoisNoneButton $whoisLabel -side right -anchor w
    set whoisDataTextFrame [frame $whoisDataFrame.whoisDataTextFrame]
      set whoisText [text $whoisDataTextFrame.whoisText -width 20 -height 8\
       -yscrollcommand "$whoisDataTextFrame.whoisScroll set" -background white]
      set whoisScroll [scrollbar $whoisDataTextFrame.whoisScroll -command "$whoisText yview" -width 10]
      pack $whoisScroll -side right -fill y
      pack $whoisText -side left -fill both -expand true
    pack $whoisDataButtonsFrame -side top -fill x
    pack $whoisDataTextFrame -side bottom -fill both -expand true
  pack $dnsDataFrame -side top -fill x
  pack $whoisDataFrame -side bottom -fill both -expand true
pack $ipDataFrame -fill both -expand true -padx 0 -pady 0
$whoisNoneButton invoke

set messageTabs [tabnotebook [$ipDataPane childsite 1].messageTabs\
 -angle 0 -bevelamount 4 -tabpos n -tabbackground darkgrey]
pack $messageTabs -side left -expand true -fill both -padx 0 -pady 0
$messageTabs add -label "System Messages"\
 -command "$messageTabs pageconfigure 0 -foreground black"
$messageTabs add -label "User Messages"\
 -command "$messageTabs pageconfigure 1 -foreground black"
set systemInfoFrame [frame [$messageTabs childsite 0].systemInfoFrame]
set systemInfoText [scrolledtext $systemInfoFrame.systemInfoText -vscrollmode static -hscrollmode dynamic\
 -wrap word -visibleitems 20x4 -sbwidth 10]
pack $systemInfoText -side top -fill both -expand true
pack $systemInfoFrame -fill both -expand true
set userMsgsFrame [frame [$messageTabs childsite 1].userMsgsFrame]
  set userMsgText [scrolledtext $userMsgsFrame.userMsgText -vscrollmode static -hscrollmode dynamic\
   -wrap word -visibleitems 20x3 -sbwidth 10]
  set userMsgEntry [entryfield $userMsgsFrame.userMsgEntry -textvariable USERMSG\
   -labeltext "MSG: " -labelpos w -width 20]
  pack $userMsgText -side top -fill both -expand true
  pack $userMsgEntry -side top -fill x
  bind [$userMsgEntry component entry] <Return> { SendUserMsg }
pack $userMsgsFrame -side top -fill both -expand true
$messageTabs select 0
bind [$userMsgText component vertsb] <ButtonRelease-1> {
  set scrollbarPosition [lindex [%W get] 1]
  if {$scrollbarPosition == 1.0} {set USER_MSG_SCROLL 1} else { set USER_MSG_SCROLL 0 }
}
set USER_MSG_SCROLL 1


set detailDataFrame [frame [$detailPane childsite 1].packetDataFrame]
    set portscanDataFrame [frame $detailDataFrame.portscanFrame]
      set psOptionsFrame [frame $portscanDataFrame.psOptionsFrame]
        set displayPSButton [checkbutton $psOptionsFrame.displayPSButton -variable PSINFO\
         -command DisplayPortscanData -text "Display Portscan Data"]
        set psMaxRows [entryfield $psOptionsFrame.psMaxRows -labeltext "Max Rows"\
         -labelpos e -width 5 -textvariable MAX_PS_ROWS -state disabled]
        bind [$psMaxRows component entry] <Return> { DisplayPortscanData }
        if { [info exists MAX_PS_ROWS] && $MAX_PS_ROWS == "" } { set MAX_PS_ROWS 200 }
        pack $displayPSButton $psMaxRows -side left -padx 10
      set portscanLabelListFrame [frame $portscanDataFrame.portscanLabelListFrame]
        set psSensorFrame [frame $portscanLabelListFrame.psSensorFrame]
          set psSensorLabel [label $psSensorFrame.label -text Sensor -background black -foreground white]
          set psSensorList [listbox $psSensorFrame.list -width 10 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psSensorLabel -side top -fill x
          pack $psSensorList -side bottom -fill both -expand true
	  BindSelectionToAllPSLists $psSensorList
        set psDateTimeFrame [frame $portscanLabelListFrame.psDateTimeFrame]
          set psDateTimeLabel [label $psDateTimeFrame.label -text TimeStamp -background black\
           -foreground white]
          set psDateTimeList [listbox $psDateTimeFrame.list -width 18 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDateTimeLabel -side top -fill x
          pack $psDateTimeList -side bottom -fill both -expand true
           BindSelectionToAllPSLists $psDateTimeList
        set psSrcIPFrame [frame $portscanLabelListFrame.psSrcIPFrame]
          set psSrcIPLabel [label $psSrcIPFrame.label -text SrcIP -background black -foreground white]
          set psSrcIPList [listbox $psSrcIPFrame.list -width 15 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psSrcIPLabel -side top -fill x
          pack $psSrcIPList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psSrcIPList
        set psSrcPortFrame [frame $portscanLabelListFrame.psSrcPortFrame]
          set psSrcPortLabel [label $psSrcPortFrame.label -text SrcPort -background black\
           -foreground white]
          set psSrcPortList [listbox $psSrcPortFrame.list -width 6 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psSrcPortLabel -side top -fill x
          pack $psSrcPortList -side bottom -fill both -expand true
	 BindSelectionToAllPSLists $srcPortList  
        set psDstIPFrame [frame $portscanLabelListFrame.psDstIPFrame]
          set psDstIPLabel [label $psDstIPFrame.label -text DstIP -background black -foreground white]
          set psDstIPList [listbox $psDstIPFrame.list -width 15 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDstIPLabel -side top -fill x
          pack $psDstIPList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psDstIPList
        set psDstPortFrame [frame $portscanLabelListFrame.psDstPortFrame]
          set psDstPortLabel [label $psDstPortFrame.label -text DstPort -background black\
           -foreground white]
          set psDstPortList [listbox $psDstPortFrame.list -width 6 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDstPortLabel -side top -fill x
          pack $psDstPortList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psDstPortList
        set psDataFrame [frame $portscanLabelListFrame.psDataFrame]
          set psDataLabel [label $psDataFrame.label -text "Scan Info" -background black\
           -foreground white]
          set psDataList [listbox $psDataFrame.list -width 15 -height 5 -borderwidth 0\
           -background white -yscrollcommand "$portscanLabelListFrame.scroll set"]
          pack $psDataLabel -side top -fill x
          pack $psDataList -side bottom -fill both -expand true
	   BindSelectionToAllPSLists $psDataList
        set psScroll [scrollbar $portscanLabelListFrame.scroll -command "MultiScrollBar \"$psSensorList\
         $psDateTimeList $psSrcIPList $psSrcPortList $psDstIPList $psDstPortList $psDataList\""\
         -width 10]
        pack $psScroll -side right -fill y
        pack $psSensorFrame $psDateTimeFrame $psSrcIPFrame $psSrcPortFrame $psDstIPFrame\
         $psDstPortFrame $psDataFrame -side left -fill both -expand true
      pack $psOptionsFrame -side top
      pack $portscanLabelListFrame -side bottom -fill both -expand true

    set packetDataFrame [frame $detailDataFrame.packetDataFrame]
    set ruleButtonFrame [frame $packetDataFrame.ruleButtonFrame]
      set displayPacketButton [checkbutton $ruleButtonFrame.displayPacketButton\
       -text "Show Packet Data" -variable PACKETINFO -command GetPacketInfo]
      set displayRuleButton [checkbutton $ruleButtonFrame.displayRuleButton\
       -text "Show Rule" -variable SHOWRULE -command GetRuleInfo]
        set referenceButton [button $ruleButtonFrame.referenceButton\
         -text "www.snort.org" -command "GetReference" -state disabled]
      pack $displayPacketButton $displayRuleButton $referenceButton -side left
    set ruleText [scrolledtext $packetDataFrame.ruleText -hscrollmode static -visibleitems 10x1\
     -sbwidth 10 -vscrollmode none -wrap none]
  set packetFrame [frame $packetDataFrame.packetFrame -background black -borderwidth 1]
    ################ IP HEADER #############################
    set ipHdrFrame [frame $packetFrame.ipHdrFrame -background black -borderwidth 1]
      set ipHdrLabel [label $ipHdrFrame.ipHdrLabel -text IP -width 8 -foreground white -background deepskyblue]
      set srcIPHdrFrame [frame $ipHdrFrame.srcIPHdrFrame]
        LabelText $srcIPHdrFrame 15 "Source IP"
      set dstIPHdrFrame [frame $ipHdrFrame.dstIPHdrFrame]
        LabelText $dstIPHdrFrame 15 "Dest IP"
      set verIPHdrFrame [frame $ipHdrFrame.verIPHdrFrame]
        LabelText $verIPHdrFrame 2 "Ver"
      set hdrLenIPHdrFrame [frame $ipHdrFrame.hdrLenIPHdrFrame]
        LabelText $hdrLenIPHdrFrame 3 "HL"
      set tosIPHdrFrame [frame $ipHdrFrame.tosIPHdrFrame]
        LabelText $tosIPHdrFrame 3 "TOS"
      set lenIPHdrFrame [frame $ipHdrFrame.lenIPHdrFrame]
        LabelText $lenIPHdrFrame 5 "len"
      set idIPHdrFrame [frame $ipHdrFrame.idIPHdrFrame]
        LabelText $idIPHdrFrame 5 "ID"
      set flagsIPHdrFrame [frame $ipHdrFrame.flagsIPHdrFrame]
        LabelText $flagsIPHdrFrame 4 "Flags"
      set offsetIPHdrFrame [frame $ipHdrFrame.offsetIPHdrFrame]
        LabelText $offsetIPHdrFrame 5 "Offset"
      set ttlIPHdrFrame [frame $ipHdrFrame.ttlIPHdrFrame]
        LabelText $ttlIPHdrFrame 4 "TTL"
      set chksumIPHdrFrame [frame $ipHdrFrame.chksumIPHdrFrame]
        LabelText $chksumIPHdrFrame 6 "ChkSum"
      pack $ipHdrLabel -side left -anchor w -fill y
      pack $srcIPHdrFrame $dstIPHdrFrame $verIPHdrFrame $hdrLenIPHdrFrame $tosIPHdrFrame $lenIPHdrFrame\
       $idIPHdrFrame $flagsIPHdrFrame $offsetIPHdrFrame $ttlIPHdrFrame $chksumIPHdrFrame\
       -side left -anchor w -fill x -expand true
    ##################### TCP HEADER ###########################
    set tcpHdrFrame [frame $packetFrame.tcpHdrFrame -background black -borderwidth 1]
      set tcpHdrLabel [label $tcpHdrFrame.tcpHdrLabel -text TCP -width 8 -foreground white -background blue]
      set sPortTcpHdrFrame [frame $tcpHdrFrame.sPortTcpHdrFrame]
        LabelText $sPortTcpHdrFrame 5 "Source\nPort" 3
      set dPortTcpHdrFrame [frame $tcpHdrFrame.dPortTcpHdrFrame]
        LabelText $dPortTcpHdrFrame 5 "Dest\nPort" 3
      set r1TcpHdrFrame [frame $tcpHdrFrame.r1TcpHdrFrame]
        LabelText $r1TcpHdrFrame 1 "R\n1" 3
      set r0TcpHdrFrame [frame $tcpHdrFrame.r0TcpHdrFrame]
        LabelText $r0TcpHdrFrame 1 "R\n0" 3
      set urgTcpHdrFrame [frame $tcpHdrFrame.urgTcpHdrFrame]
        LabelText $urgTcpHdrFrame 1 "U\nR\nG" 3
      set ackTcpHdrFrame [frame $tcpHdrFrame.ackTcpHdrFrame]
        LabelText $ackTcpHdrFrame 1 "A\nC\nK" 3
      set pshTcpHdrFrame [frame $tcpHdrFrame.pshTcpHdrFrame]
        LabelText $pshTcpHdrFrame 1 "P\nS\nH" 3
      set rstTcpHdrFrame [frame $tcpHdrFrame.rstTcpHdrFrame]
        LabelText $rstTcpHdrFrame 1 "R\nS\nT" 3
      set synTcpHdrFrame [frame $tcpHdrFrame.synTcpHdrFrame]
        LabelText $synTcpHdrFrame 1 "S\nY\nN" 3
      set finTcpHdrFrame [frame $tcpHdrFrame.finTcpHdrFrame]
        LabelText $finTcpHdrFrame 1 "F\nI\nN" 3
      set seqTcpHdrFrame [frame $tcpHdrFrame.seqTcpHdrFrame]
        LabelText $seqTcpHdrFrame 9 "Seq #" 3
      set acknoTcpHdrFrame [frame $tcpHdrFrame.acknoTcpHdrFrame]
        LabelText $acknoTcpHdrFrame 9 "Ack #" 3
      set tcpoffsetTcpHdrFrame [frame $tcpHdrFrame.tcpoffsetTcpHdrFrame]
        LabelText $tcpoffsetTcpHdrFrame 5 "Offset" 3
      set resTcpHdrFrame [frame $tcpHdrFrame.resTcpHdrFrame]
        LabelText $resTcpHdrFrame 3 "Res" 3
      set windowTcpHdrFrame [frame $tcpHdrFrame.windowTcpHdrFrame]
        LabelText $windowTcpHdrFrame 6 "Window" 3
      set urpTcpHdrFrame [frame $tcpHdrFrame.urpTcpHdrFrame]
        LabelText $urpTcpHdrFrame 3 "Urp" 3
      set tcpchksumTcpHdrFrame [frame $tcpHdrFrame.tcpchksumTcpHdrFrame]
        LabelText $tcpchksumTcpHdrFrame 6 "ChkSum" 3
      pack $tcpHdrLabel -side left -anchor w -fill y
      pack $sPortTcpHdrFrame $dPortTcpHdrFrame $r1TcpHdrFrame $r0TcpHdrFrame $urgTcpHdrFrame\
       $ackTcpHdrFrame $pshTcpHdrFrame $rstTcpHdrFrame $synTcpHdrFrame $finTcpHdrFrame\
       $seqTcpHdrFrame $acknoTcpHdrFrame $tcpoffsetTcpHdrFrame $resTcpHdrFrame $windowTcpHdrFrame\
       $urpTcpHdrFrame $tcpchksumTcpHdrFrame -side left -anchor w -fill x -expand true
    ##################### UDP HEADER ###########################
    set udpHdrFrame [frame $packetFrame.udpHdrFrame -background black -borderwidth 1]
      set udpHdrLabel [label $udpHdrFrame.udpHdrLabel -text UDP -width 8 -foreground white -background blue]
      set sPortUdpHdrFrame [frame $udpHdrFrame.sPortUdpHdrFrame]
        LabelText $sPortUdpHdrFrame 5 "Source\nPort"
      set dPortUdpHdrFrame [frame $udpHdrFrame.dPortUdpHdrFrame]
       LabelText $dPortUdpHdrFrame 5 "Dest\nPort"
      set udplenUdpHdrFrame [frame $udpHdrFrame.udplenUdpHdrFrame]
        LabelText $udplenUdpHdrFrame 6 "Length"
      set udpchksumUdpHdrFrame [frame $udpHdrFrame.udpchksumUdpHdrFrame]
       LabelText $udpchksumUdpHdrFrame 6 "ChkSum"
      pack $udpHdrLabel -side left -anchor w -fill y
      pack $sPortUdpHdrFrame $dPortUdpHdrFrame $udplenUdpHdrFrame $udpchksumUdpHdrFrame\
       -side left -anchor w -fill x -expand true
    ##################### ICMP HEADER ###########################
    set icmpHdrFrame [frame $packetFrame.icmpHdrFrame -background black -borderwidth 1]
      set icmpHdrLabel [label $icmpHdrFrame.icmpHdrLabel -text ICMP -width 8 -foreground white -background blue]
      set typeIcmpHdrFrame [frame $icmpHdrFrame.typeIcmpHdrFrame]
        LabelText $typeIcmpHdrFrame 23 "Type"
      set codeIcmpHdrFrame [frame $icmpHdrFrame.codeIcmpHdrFrame]
        LabelText $codeIcmpHdrFrame 4 "Code"
     set chksumIcmpHdrFrame [frame $icmpHdrFrame.chksumIcmpHdrFrame]
        LabelText $chksumIcmpHdrFrame 6 "ChkSum"
      set idIcmpHdrFrame [frame $icmpHdrFrame.idIcmpHdrFrame]
        LabelText $idIcmpHdrFrame 6 "ID"
      set seqIcmpHdrFrame [frame $icmpHdrFrame.seqIcmpHdrFrame]
        LabelText $seqIcmpHdrFrame 6 "Seq #"
      pack $icmpHdrLabel -side left -anchor w -fill y
      pack $typeIcmpHdrFrame $codeIcmpHdrFrame $chksumIcmpHdrFrame $idIcmpHdrFrame $seqIcmpHdrFrame\
       -side left -anchor w -fill x -expand true
    ##################### ICMP DATA DECODE ###########################
    set icmpDecodeFrame [frame $packetFrame.icmpDecodeFrame -background black -borderwidth 1]
      set icmpDecodeLabel [label $icmpDecodeFrame.icmpDecodeLabel -text "ICMP\nDECODE" -width 8\
        -foreground white -background mediumblue]
      set protoIcmpDecodeFrame [frame $icmpDecodeFrame.protoIcmpDecodeFrame]
        LabelText $protoIcmpDecodeFrame  5 "Proto"
      set sipIcmpDecodeFrame [frame $icmpDecodeFrame.sipIcmpDecodeFrame]
        LabelText $sipIcmpDecodeFrame 15 "Orig Src IP"
      set sportIcmpDecodeFrame [frame $icmpDecodeFrame.sportIcmpDecodeFrame]
        LabelText $sportIcmpDecodeFrame 8 "Src Port"
      set dipIcmpDecodeFrame [frame $icmpDecodeFrame.dipIcmpDecodeFrame]
        LabelText $dipIcmpDecodeFrame 15 "Orig Dst IP"
      set dportIcmpDecodeFrame [frame $icmpDecodeFrame.dportIcmpDecodeFrame]
        LabelText $dportIcmpDecodeFrame 8 "Dst Port"
      set gipIcmpDecodeFrame [frame $icmpDecodeFrame.gipIcmpDecodeFrame]
	LabelText $gipIcmpDecodeFrame 15 "Gateway IP"
      pack $icmpDecodeLabel -side left -anchor w -fill y
      pack $protoIcmpDecodeFrame $sipIcmpDecodeFrame $sportIcmpDecodeFrame $dipIcmpDecodeFrame\
        $dportIcmpDecodeFrame $gipIcmpDecodeFrame -side left -anchor w -fill both -expand true
   ##################### DATA ###########################
    set dataFrame [frame $packetFrame.dataFrame -background black -borderwidth 1]
      set dataFrameLabel [label $dataFrame.dataFrameLabel -text DATA -width 8 -foreground white -background navy]
      set dataTextFrame [frame $dataFrame.dataTextFrame]
        set dataText [text $dataTextFrame.dataText -height 10 -width 20\
         -yscrollcommand "$dataFrame.dataScroll set" -background white -font ourFixedFont]
        set dataScroll [scrollbar $dataFrame.dataScroll -command "$dataText yview" -width 10]
        pack $dataScroll -side right -fill y
        pack $dataText -side left -fill both -expand true
     pack $dataFrameLabel -side left -anchor w -fill y
     pack $dataTextFrame -side left -anchor w -fill both -expand true
    
    pack $ipHdrFrame $tcpHdrFrame -fill x -side top
    pack $dataFrame -fill both -expand true -side bottom
    set DISPLAYEDHDR $tcpHdrFrame
     pack $ruleButtonFrame $ruleText -side top -fill x
  pack $packetFrame -side bottom -fill both -expand true
pack $packetDataFrame -fill both -expand true
set DISPLAYEDDETAIL $packetDataFrame
pack $detailDataFrame -fill both -expand true
$ipDataPane fraction 70 30
$eventPane fraction 55 45
$detailPane fraction 40 60

# Xscript Menu
set eventIDMenut [ menu .eventIDMenut -background blue -foreground white -activeforeground blue\
 -activebackground white -tearoff 0 ]
$eventIDMenut add command -label "Event History" -command "GetEventHistory"
$eventIDMenut add command -label "Transcript" -command "GetXscript xscript 0"
$eventIDMenut add command -label "Transcript (force new)" -command "GetXscript xscript 1"
$eventIDMenut add command -label "Ethereal" -command "GetXscript ethereal 0"
$eventIDMenut add command -label "Ethereal (force new)" -command "GetXscript ethereal 1"

# IPQuery Menu
set ipQueryMenu [ menu .ipQueryMenu -background blue -foreground white -activeforeground blue\
 -activebackground white -tearoff 0 ]
.ipQueryMenu add cascade -label "Query Event Table" -menu $ipQueryMenu.eventMenu
.ipQueryMenu add cascade -label "Query Sessions Table" -menu $ipQueryMenu.sessionsMenu
.ipQueryMenu add cascade -label "Dshield IP Lookup" -menu $ipQueryMenu.dshieldIPMenu
menu $ipQueryMenu.eventMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
menu $ipQueryMenu.sessionsMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
menu $ipQueryMenu.dshieldIPMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
$ipQueryMenu.eventMenu add command -label "Query SrcIP" -command "QueryRequest event srcip"
$ipQueryMenu.eventMenu add command -label "Query DstIP" -command "QueryRequest event dstip"
$ipQueryMenu.eventMenu add command -label "Query Src To Dst" -command "QueryRequest event src2dst"
$ipQueryMenu.sessionsMenu add command -label "Query SrcIP" -command "QueryRequest sessions srcip"
$ipQueryMenu.sessionsMenu add command -label "Query DstIP" -command "QueryRequest sessions dstip"
$ipQueryMenu.sessionsMenu add command -label "Query Src To Dst" -command "QueryRequest sessions src2dst"
$ipQueryMenu.dshieldIPMenu add command -label "SrcIP" -command "GetDshieldIP srcip"
$ipQueryMenu.dshieldIPMenu add command -label "DstIP" -command "GetDshieldIP dstip"

# Port Query Menu
set portQueryMenu [ menu .portQueryMenu -background blue -foreground white -activeforeground blue\
-activebackground white -tearoff 0 ]
.portQueryMenu add cascade -label "Dshield Port Lookup" -menu $portQueryMenu.dshieldPortMenu
menu $portQueryMenu.dshieldPortMenu -tearoff 0 -background blue -foreground white -activeforeground blue\
 -activebackground white
$portQueryMenu.dshieldPortMenu add command -label "SrcPort" -command "GetDshieldPort srcport"
$portQueryMenu.dshieldPortMenu add command -label "DstPort" -command "GetDshieldPort dstport"

# Sig Query Menu
set sigQueryMenu [ menu .sigQueryMenu -background blue -foreground white -activeforeground blue\
 -activebackground white -tearoff 0 ]
$sigQueryMenu add command -label "Query Event" -command "QueryRequest event signature"

# Correlate Events Menu
set correlateMenu [ menu .correlateMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$correlateMenu add command -label "View Correlated Events"\
 -command "DisplayCorrelatedEvents \$currentSelectedPane.countFrame.list"

# Query Incident Categories Menu
set statusMenu [ menu .statusMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$statusMenu add command -label "Expire Event (F8)" -command "ValidateEvent 1"
$statusMenu add cascade -label "Query" -menu $statusMenu.incidentMenu
set incidentMenu [menu $statusMenu.incidentMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$incidentMenu add command -label "Cat I: Unauthorized Root Access"\
  -command "QueryRequest event category 11"
$incidentMenu add command -label "Cat II: Unauthorized User Access"\
  -command "QueryRequest event category 12"
$incidentMenu add command -label "Cat III: Attempted Unauthorized Access"\
  -command "QueryRequest event category 13"
$incidentMenu add command -label "Cat IV: Successful Denial of Service Attack"\
  -command "QueryRequest event category 14"
$incidentMenu add command -label "Cat V: Poor Security Practice or Policy Violation"\
  -command "QueryRequest event category 15"
$incidentMenu add command -label "Cat VI: Reconnaissance/Probes/Scans"\
  -command "QueryRequest event category 16"
$incidentMenu add command -label "Cat VII: Virus Infection"\
  -command "QueryRequest event category 17"
$statusMenu add cascade -label "Update Event Status" -menu $statusMenu.validateMenu
set validateMenu [menu $statusMenu.validateMenu -background blue -foreground white\
 -activeforeground blue -activebackground white -tearoff 0 ]
$validateMenu add command -label "Escalate (F9)" -command "ValidateEvent 2"
$validateMenu add command -label "Cat I: Unauthorized Root Access (F1)"\
  -command "ValidateEvent 11"
$validateMenu add command -label "Cat II: Unauthorized User Access (F2)"\
  -command "ValidateEvent 12"
$validateMenu add command -label "Cat III: Attempted Unauthorized Access (F3)"\
  -command "ValidateEvent 13"
$validateMenu add command -label "Cat IV: Successful Denial of Service Attack (F4)"\
  -command "ValidateEvent 14"
$validateMenu add command -label "Cat V: Poor Security Practice or Policy Violation (F5)"\
  -command "ValidateEvent 15"
$validateMenu add command -label "Cat VI: Reconnaissance/Probes/Scans (F6)"\
  -command "ValidateEvent 16"
$validateMenu add command -label "Cat VII: Virus Infection(F7)"\
  -command "ValidateEvent 17"


################### GENERAL KEY BINDINGS ########################

# F8 deletes the highlighted event
bind . <F8> {
  ValidateEvent 1
}
bind . <Shift-Key-F8> {
  ValidateEvent 1 1
}
# F1 deletes the highlighted event and marks the event as 11 (CatI)
bind . <F1> {
  ValidateEvent 11
}
bind . <Shift-Key-F1> {
  ValidateEvent 11 1
}
# F2 deletes the highlighted event and marks the event as 12 (CatII)
bind . <F2> {
  ValidateEvent 12
}
bind . <Shift-Key-F2> {
  ValidateEvent 12 1
}
# F3 deletes the highlighted event and marks the event as 13 (CatIII)
bind . <F3> {
  ValidateEvent 13
}
bind . <Shift-Key-F3> {
  ValidateEvent 13 1
}
# F4 deletes the highlighted event and marks the event as 14 (CatIV)
bind . <F4> {
  ValidateEvent 14
}
bind . <Shift-Key-F4> {
  ValidateEvent 14 1
}
# F5 deletes the highlighted event and marks the event as 15 (CatV)
bind . <F5> {
  ValidateEvent 15
}
bind . <Shift-Key-F5> {
  ValidateEvent 15 1
}
# F6 deletes the highlighted event and marks the event as 16 (CatVI)
bind . <F6> {
  ValidateEvent 16
}
bind . <Shift-Key-F6> {
  ValidateEvent 16 1
}
# F7 deletes the highlighted event and marks the event as 17 (CatVII)
bind . <F7> {
  ValidateEvent 17
}
bind . <Shift-Key-F7> {
  ValidateEvent 17 1
}
# F9 Escalates the event
bind . <F9> {
  ValidateEvent 2
}
bind . <Shift-Key-F9> {
  ValidateEvent 2 1
}
# Ctl-s initiates Sleep function.
bind . <Control-Key-s> {
  GoToSleep
}
# Ctl-q launches Std query window
bind . <Control-Key-q> {
  GetStdQuery
}
# Ctl right/left arrow selects next/prev tab
bind . <Control-Key-Right> {
  $eventTabs next
}
bind . <Control-Key-Left> {
  $eventTabs prev
}
# Space selects the active event.  Used when navigating using ctrl-arrow
# Globally grabbing the space bar is bad :)  Bammkkkk
bind . <Control-Key-space> {
    if {!$SSN_QUERY} { 
      set activeIndex [$currentSelectedPane.eventIDFrame.list index active]
      CtrlSelect $currentSelectedPane.eventIDFrame.list $activeIndex
    }
}
# ctrl-up moves active event without changing selection
bind . <Control-Key-Up> {
    set activeIndex [$currentSelectedPane.eventIDFrame.list index active]
    $currentSelectedPane.eventIDFrame.list activate [expr $activeIndex-1]
    foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
          $childWin.list itemconfigure $activeIndex -foreground black
	    $childWin.list itemconfigure [expr $activeIndex - 1] -foreground red
	    $childWin.list see [expr $activeIndex-1]
	}
    }
}
bind . <Control-Key-Down> {
    set activeIndex [$currentSelectedPane.eventIDFrame.list index active]
    $currentSelectedPane.eventIDFrame.list activate [expr $activeIndex+1]
    foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
          $childWin.list itemconfigure $activeIndex -foreground black
	    $childWin.list itemconfigure [expr $activeIndex + 1] -foreground red
	    $childWin.list see [expr $activeIndex+1]
	}
    }
}
# Up arrow moves selected event up one.
bind . <Key-Up> {
  if {$ACTIVE_EVENT} {
      set selectedIndex [$currentSelectedPane.eventIDFrame.list index active]
    
    set listSize [$currentSelectedPane.eventIDFrame.list size]
    if { $selectedIndex != 0 && $selectedIndex < $listSize  } {
      SingleSelect $currentSelectedPane.eventIDFrame.list [expr $selectedIndex - 1]
      foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
	    $childWin.list itemconfigure $selectedIndex -foreground black
	    $childWin.list see [expr $selectedIndex - 1]
          set SCROLL_HOME($currentSelectedPane) 0
	}        
      }
    }
  }
}

# Down arrow moves selected event down one.
bind . <Key-Down> {
  if {$ACTIVE_EVENT} {
    set selectedIndex [$currentSelectedPane.eventIDFrame.list index active]
    set listSize [$currentSelectedPane.eventIDFrame.list size]
    if { $selectedIndex < $listSize  } {
      SingleSelect $currentSelectedPane.eventIDFrame.list [expr $selectedIndex + 1]
      foreach childWin [winfo children $currentSelectedPane] {
        if { [winfo name $childWin] != "scroll" } {
          $childWin.list see [expr $selectedIndex + 1]
	  $childWin.list itemconfigure $selectedIndex -foreground black
          set SCROLL_HOME($currentSelectedPane) 0
        }
      }
    }
  }
}

# Esc unselects all options
bind . <Key-Escape> {
  UnSelectPacketOptions
  UnSelectHostLookups
}

bind . <MouseWheel> {
    if { $currentSelectedPane != 0 } {
	WheelScroll %D $currentSelectedPane "MouseWheel"
    }
}

# Toggle SOUND when off/on is clicked
bind $soundStatus <Button-1> {
  if {$SOUND} {
    # Sound is on. turn it off
    set SOUND 0
    $soundStatus configure -text Off -foreground red
    InfoMessage "Sound has been deactivated."
  } else {
    # Sound is off. turn it on
    if { [file exists /dev/speech]} {
      set SOUND 1
      $soundStatus configure -text On -foreground darkgreen
      Speak "Sound has been activated"
    } else {
      InfoMessage "/dev/speech was not found. Download and install speechd from www.speechio.org."
    }
  }
}
#########################################################################

#################### Connect To The Server ##############################

if [catch { ConnectToSguild } socketID] {
  ErrorMessage $socketID
  CleanExit
} else {
  set CONNECTED 1
  GetUserName
  SendToSguild "ValidateUser $USERNAME"
  set saltNonce [gets $socketID]
  set tmpSalt [lindex $saltNonce 0]
  set tmpNonce [lindex $saltNonce 1]
  set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
  set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
  puts $socketID $finalCheck
  set USERID [lindex [gets $socketID] 1]
  while { $USERID == "INVALID" } {
    set PASSWD ""
    ErrorMessage "Invalid USERNAME and/or PASSWORD"
    GetUserName 
    SendToSguild "ValidateUser $USERNAME"
    set saltNonce [gets $socketID]
    set tmpSalt [lindex $saltNonce 0]
    set tmpNonce [lindex $saltNonce 1]
    set passwdHash [::sha1::sha1 "${PASSWD}${tmpSalt}"]
    set finalCheck [::sha1::sha1 "${tmpNonce}${tmpSalt}${passwdHash}"]
    puts $socketID $finalCheck
    set USERID [lindex [gets $socketID] 1]
  } 
  fileevent $socketID readable [list ServerCommandRcvd $socketID]
  SendToSguild "SendDBInfo"
  SendToSguild "SendSensorList"
  tkwait variable MONITORFLAG
  wm deiconify .
  update
  SendToSguild "SendEscalatedEvents"
  SendToSguild "SendGlobalQryList"
}
